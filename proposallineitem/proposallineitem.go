// Code generated by gowsdl DO NOT EDIT.

package proposallineitem

import (
	"context"
	"encoding/xml"
	"github.com/hooklift/gowsdl/soap"
	"time"
)

// against "unused imports"
var _ time.Time
var _ xml.Name

type AnyType struct {
	InnerXML string `xml:",innerxml"`
}

type AnyURI string

type NCName string

//
// The formats that a publisher allows on their programmatic {@link LineItem}
// or {@link ProposalLineItem}.
//

type AllowedFormats string

const (

	//
	// Audio format.
	// This is only relevant for programmatic video line items.
	//
	AllowedFormatsAUDIO AllowedFormats = "AUDIO"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AllowedFormatsUNKNOWN AllowedFormats = "UNKNOWN"
)

type ApiVersionError_Reason string

const (

	//
	// Indicates that the operation is not allowed in the version the request
	// was made in.
	//
	ApiVersionError_ReasonUPDATE_TO_NEWER_VERSION ApiVersionError_Reason = "UPDATE_TO_NEWER_VERSION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ApiVersionError_ReasonUNKNOWN ApiVersionError_Reason = "UNKNOWN"
)

type AuthenticationError_Reason string

const (

	//
	// The SOAP message contains a request header with an ambiguous definition of the authentication
	// header fields. This means either the {@code authToken} and {@code oAuthToken} fields were
	// both null or both were specified. Exactly one value should be specified with each request.
	//
	AuthenticationError_ReasonAMBIGUOUS_SOAP_REQUEST_HEADER AuthenticationError_Reason = "AMBIGUOUS_SOAP_REQUEST_HEADER"

	//
	// The login provided is invalid.
	//
	AuthenticationError_ReasonINVALID_EMAIL AuthenticationError_Reason = "INVALID_EMAIL"

	//
	// Tried to authenticate with provided information, but failed.
	//
	AuthenticationError_ReasonAUTHENTICATION_FAILED AuthenticationError_Reason = "AUTHENTICATION_FAILED"

	//
	// The OAuth provided is invalid.
	//
	AuthenticationError_ReasonINVALID_OAUTH_SIGNATURE AuthenticationError_Reason = "INVALID_OAUTH_SIGNATURE"

	//
	// The specified service to use was not recognized.
	//
	AuthenticationError_ReasonINVALID_SERVICE AuthenticationError_Reason = "INVALID_SERVICE"

	//
	// The SOAP message is missing a request header with an {@code authToken} and optional {@code
	// networkCode}.
	//
	AuthenticationError_ReasonMISSING_SOAP_REQUEST_HEADER AuthenticationError_Reason = "MISSING_SOAP_REQUEST_HEADER"

	//
	// The HTTP request is missing a request header with an {@code authToken}
	//
	AuthenticationError_ReasonMISSING_AUTHENTICATION_HTTP_HEADER AuthenticationError_Reason = "MISSING_AUTHENTICATION_HTTP_HEADER"

	//
	// The request is missing an {@code authToken}
	//
	AuthenticationError_ReasonMISSING_AUTHENTICATION AuthenticationError_Reason = "MISSING_AUTHENTICATION"

	//
	// The network does not have API access enabled.
	//
	AuthenticationError_ReasonNETWORK_API_ACCESS_DISABLED AuthenticationError_Reason = "NETWORK_API_ACCESS_DISABLED"

	//
	// The user is not associated with any network.
	//
	AuthenticationError_ReasonNO_NETWORKS_TO_ACCESS AuthenticationError_Reason = "NO_NETWORKS_TO_ACCESS"

	//
	// No network for the given {@code networkCode} was found.
	//
	AuthenticationError_ReasonNETWORK_NOT_FOUND AuthenticationError_Reason = "NETWORK_NOT_FOUND"

	//
	// The user has access to more than one network, but did not provide a {@code networkCode}.
	//
	AuthenticationError_ReasonNETWORK_CODE_REQUIRED AuthenticationError_Reason = "NETWORK_CODE_REQUIRED"

	//
	// An error happened on the server side during connection to authentication service.
	//
	AuthenticationError_ReasonCONNECTION_ERROR AuthenticationError_Reason = "CONNECTION_ERROR"

	//
	// The user tried to create a test network using an account that already is associated with a
	// network.
	//
	AuthenticationError_ReasonGOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK AuthenticationError_Reason = "GOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK"

	//
	// The account is blocked and under investigation by the collections team. Please contact Google
	// for more information.
	//
	AuthenticationError_ReasonUNDER_INVESTIGATION AuthenticationError_Reason = "UNDER_INVESTIGATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AuthenticationError_ReasonUNKNOWN AuthenticationError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type BillingError_Reason string

const (

	//
	// Found unsupported billing schedule.
	//
	BillingError_ReasonUNSUPPORTED_BILLING_SCHEDULE BillingError_Reason = "UNSUPPORTED_BILLING_SCHEDULE"

	//
	// Found unsupported billing cap.
	//
	BillingError_ReasonUNSUPPORTED_BILLING_CAP BillingError_Reason = "UNSUPPORTED_BILLING_CAP"

	//
	// Billing source is missing when either billing scheule or billing cap is provided.
	//
	BillingError_ReasonMISSING_BILLING_SOURCE BillingError_Reason = "MISSING_BILLING_SOURCE"

	//
	// Billing schedule is missing when the provided billing source is CONSTRACTED.
	//
	BillingError_ReasonMISSING_BILLING_SCHEDULE BillingError_Reason = "MISSING_BILLING_SCHEDULE"

	//
	// Billing cap is missing when the provided billing source is not CONSTRACTED.
	//
	BillingError_ReasonMISSING_BILLING_CAP BillingError_Reason = "MISSING_BILLING_CAP"

	//
	// The billing source is invalid for offline proposal line item.
	//
	BillingError_ReasonINVALID_BILLING_SOURCE_FOR_OFFLINE BillingError_Reason = "INVALID_BILLING_SOURCE_FOR_OFFLINE"

	//
	// Billing settings cannot be updated once the proposal has been approved.
	//
	BillingError_ReasonUPDATE_BILLING_NOT_ALLOWED BillingError_Reason = "UPDATE_BILLING_NOT_ALLOWED"

	//
	// Billing base is missing when the provided billing source is CONTRACTED.
	//
	BillingError_ReasonMISSING_BILLING_BASE BillingError_Reason = "MISSING_BILLING_BASE"

	//
	// The billing base is invalid for the provided billing source.
	//
	BillingError_ReasonINVALID_BILLING_BASE BillingError_Reason = "INVALID_BILLING_BASE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	BillingError_ReasonUNKNOWN BillingError_Reason = "UNKNOWN"
)

type CollectionSizeError_Reason string

const (
	CollectionSizeError_ReasonTOO_LARGE CollectionSizeError_Reason = "TOO_LARGE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CollectionSizeError_ReasonUNKNOWN CollectionSizeError_Reason = "UNKNOWN"
)

//
// Describes reasons for common errors
//

type CommonError_Reason string

const (

	//
	// Indicates that an attempt was made to retrieve an entity that does not
	// exist.
	//
	CommonError_ReasonNOT_FOUND CommonError_Reason = "NOT_FOUND"

	//
	// Indicates that an attempt was made to create an entity that already
	// exists.
	//
	CommonError_ReasonALREADY_EXISTS CommonError_Reason = "ALREADY_EXISTS"

	//
	// Indicates that a value is not applicable for given use case.
	//
	CommonError_ReasonNOT_APPLICABLE CommonError_Reason = "NOT_APPLICABLE"

	//
	// Indicates that two elements in the collection were identical.
	//
	CommonError_ReasonDUPLICATE_OBJECT CommonError_Reason = "DUPLICATE_OBJECT"

	//
	// Indicates that an attempt was made to change an immutable field.
	//
	CommonError_ReasonCANNOT_UPDATE CommonError_Reason = "CANNOT_UPDATE"

	//
	// Indicates that the requested operation is not supported.
	//
	CommonError_ReasonUNSUPPORTED_OPERATION CommonError_Reason = "UNSUPPORTED_OPERATION"

	//
	// Indicates that another request attempted to update the same data in the same network
	// at about the same time. Please wait and try the request again.
	//
	CommonError_ReasonCONCURRENT_MODIFICATION CommonError_Reason = "CONCURRENT_MODIFICATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CommonError_ReasonUNKNOWN CommonError_Reason = "UNKNOWN"
)

//
// The delivery option for companions.  Used for line items whose environmentType is
// {@link EnvironmentType#VIDEO_PLAYER}.
//

type CompanionDeliveryOption string

const (

	//
	// Companions are not required to serve a creative set. The creative set can
	// serve to inventory that has zero or more matching companions.
	//
	CompanionDeliveryOptionOPTIONAL CompanionDeliveryOption = "OPTIONAL"

	//
	// At least one companion must be served in order for the creative set to be used.
	//
	CompanionDeliveryOptionAT_LEAST_ONE CompanionDeliveryOption = "AT_LEAST_ONE"

	//
	// All companions in the set must be served in order for the creative set to
	// be used. This can still serve to inventory that has more companions
	// than can be filled.
	//
	CompanionDeliveryOptionALL CompanionDeliveryOption = "ALL"

	//
	// The delivery type is unknown.
	//
	CompanionDeliveryOptionUNKNOWN CompanionDeliveryOption = "UNKNOWN"
)

//
// Describes the computed {@link LineItem} status that is derived from the
// current state of the line item.
//

type ComputedStatus string

const (

	//
	// The {@link LineItem} has past its {@link LineItem#endDateTime} with an auto extension, but
	// hasn't met its goal.
	//
	ComputedStatusDELIVERY_EXTENDED ComputedStatus = "DELIVERY_EXTENDED"

	//
	// The {@link LineItem} has begun serving.
	//
	ComputedStatusDELIVERING ComputedStatus = "DELIVERING"

	//
	// The {@link LineItem} has been activated and is ready to serve.
	//
	ComputedStatusREADY ComputedStatus = "READY"

	//
	// The {@link LineItem} has been paused from serving.
	//
	ComputedStatusPAUSED ComputedStatus = "PAUSED"

	//
	// The {@link LineItem} is inactive. It is either caused by missing creatives or
	// the network disabling auto-activation.
	//
	ComputedStatusINACTIVE ComputedStatus = "INACTIVE"

	//
	// The {@link LineItem} has been paused and its reserved inventory has been
	// released. The {@code LineItem} will not serve.
	//
	ComputedStatusPAUSED_INVENTORY_RELEASED ComputedStatus = "PAUSED_INVENTORY_RELEASED"

	//
	// The {@link LineItem} has been submitted for approval.
	//
	ComputedStatusPENDING_APPROVAL ComputedStatus = "PENDING_APPROVAL"

	//
	// The {@link LineItem} has completed its run.
	//
	ComputedStatusCOMPLETED ComputedStatus = "COMPLETED"

	//
	// The {@link LineItem} has been disapproved and is not eligible to serve.
	//
	ComputedStatusDISAPPROVED ComputedStatus = "DISAPPROVED"

	//
	// The {@link LineItem} is still being drafted.
	//
	ComputedStatusDRAFT ComputedStatus = "DRAFT"

	//
	// The {@link LineItem} has been canceled and is no longer eligible to serve.
	// This is a legacy status imported from Google Ad Manager orders.
	//
	ComputedStatusCANCELED ComputedStatus = "CANCELED"
)

//
// Descriptions of the types of sizes a creative can be.  Not all creatives can
// be described by a height-width pair, this provides additional context.
//

type CreativeSizeType string

const (

	//
	// Dimension based size, an actual height and width.
	//
	CreativeSizeTypePIXEL CreativeSizeType = "PIXEL"

	//
	// Mobile size, that is expressed as a ratio of say 4 by 1, that could be
	// met by a 100 x 25 sized image.
	//
	CreativeSizeTypeASPECT_RATIO CreativeSizeType = "ASPECT_RATIO"

	//
	// Out-of-page size, that is not related to the slot it is served.  But rather
	// is a function of the snippet, and the values set. This must be used with
	// 1x1 size.
	//
	CreativeSizeTypeINTERSTITIAL CreativeSizeType = "INTERSTITIAL"

	//
	// Size has no meaning
	//
	// <p>1. For Click Tracking entities, where size doesn't matter 2. For entities that allow all
	// requested sizes, where the size represents all sizes.
	//
	CreativeSizeTypeIGNORED CreativeSizeType = "IGNORED"

	//
	// Native size, which is a function of the how the client renders the creative.
	// This must be used with 1x1 size.
	//
	CreativeSizeTypeNATIVE CreativeSizeType = "NATIVE"

	//
	// Audio size. Used with audio ads. This must be used with 1x1 size.
	//
	CreativeSizeTypeAUDIO CreativeSizeType = "AUDIO"
)

//
// The reason behind the currency code error.
//

type CurrencyCodeError_Reason string

const (

	//
	// The currency code is invalid and does not follow ISO 4217.
	//
	CurrencyCodeError_ReasonINVALID CurrencyCodeError_Reason = "INVALID"

	//
	// The currency code is valid, but is not supported.
	//
	CurrencyCodeError_ReasonUNSUPPORTED CurrencyCodeError_Reason = "UNSUPPORTED"

	//
	// The currency has been used for entity creation after its deprecation
	//
	CurrencyCodeError_ReasonDEPRECATED_CURRENCY_USED CurrencyCodeError_Reason = "DEPRECATED_CURRENCY_USED"
)

//
// Specifies the available comparison operators.
//

type CustomCriteria_ComparisonOperator string

const (
	CustomCriteria_ComparisonOperatorIS CustomCriteria_ComparisonOperator = "IS"

	CustomCriteria_ComparisonOperatorIS_NOT CustomCriteria_ComparisonOperator = "IS_NOT"
)

//
// Specifies the available logical operators.
//

type CustomCriteriaSet_LogicalOperator string

const (
	CustomCriteriaSet_LogicalOperatorAND CustomCriteriaSet_LogicalOperator = "AND"

	CustomCriteriaSet_LogicalOperatorOR CustomCriteriaSet_LogicalOperator = "OR"
)

//
// The reasons for the target error.
//

type CustomFieldValueError_Reason string

const (

	//
	// An attempt was made to modify or create a {@link CustomFieldValue} for
	// a {@link CustomField} that does not exist.
	//
	CustomFieldValueError_ReasonCUSTOM_FIELD_NOT_FOUND CustomFieldValueError_Reason = "CUSTOM_FIELD_NOT_FOUND"

	//
	// An attempt was made to create a new value for a custom field
	// that is inactive.
	//
	CustomFieldValueError_ReasonCUSTOM_FIELD_INACTIVE CustomFieldValueError_Reason = "CUSTOM_FIELD_INACTIVE"

	//
	// An attempt was made to modify or create a {@link CustomFieldValue} corresponding
	// to a {@link CustomFieldOption} that could not be found.
	//
	CustomFieldValueError_ReasonCUSTOM_FIELD_OPTION_NOT_FOUND CustomFieldValueError_Reason = "CUSTOM_FIELD_OPTION_NOT_FOUND"

	//
	// An attempt was made to modify or create a {@link CustomFieldValue} with an
	// association to an entity of the wrong type for its field.
	//
	CustomFieldValueError_ReasonINVALID_ENTITY_TYPE CustomFieldValueError_Reason = "INVALID_ENTITY_TYPE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CustomFieldValueError_ReasonUNKNOWN CustomFieldValueError_Reason = "UNKNOWN"
)

//
// Specifies the available comparison operators.
//

type CmsMetadataCriteria_ComparisonOperator string

const (
	CmsMetadataCriteria_ComparisonOperatorEQUALS CmsMetadataCriteria_ComparisonOperator = "EQUALS"

	CmsMetadataCriteria_ComparisonOperatorNOT_EQUALS CmsMetadataCriteria_ComparisonOperator = "NOT_EQUALS"
)

//
// The reasons for the target error.
//

type CustomTargetingError_Reason string

const (

	//
	// Requested {@link CustomTargetingKey} is not found.
	//
	CustomTargetingError_ReasonKEY_NOT_FOUND CustomTargetingError_Reason = "KEY_NOT_FOUND"

	//
	// Number of {@link CustomTargetingKey} objects created exceeds the limit
	// allowed for the network.
	//
	CustomTargetingError_ReasonKEY_COUNT_TOO_LARGE CustomTargetingError_Reason = "KEY_COUNT_TOO_LARGE"

	//
	// {@link CustomTargetingKey} with the same {@link CustomTargetingKey#name}
	// already exists.
	//
	CustomTargetingError_ReasonKEY_NAME_DUPLICATE CustomTargetingError_Reason = "KEY_NAME_DUPLICATE"

	//
	// {@link CustomTargetingKey#name} is empty.
	//
	CustomTargetingError_ReasonKEY_NAME_EMPTY CustomTargetingError_Reason = "KEY_NAME_EMPTY"

	//
	// {@link CustomTargetingKey#name} is too long.
	//
	CustomTargetingError_ReasonKEY_NAME_INVALID_LENGTH CustomTargetingError_Reason = "KEY_NAME_INVALID_LENGTH"

	//
	// {@link CustomTargetingKey#name} contains unsupported or reserved
	// characters.
	//
	CustomTargetingError_ReasonKEY_NAME_INVALID_CHARS CustomTargetingError_Reason = "KEY_NAME_INVALID_CHARS"

	//
	// {@link CustomTargetingKey#name} matches one of the reserved custom
	// targeting key names.
	//
	CustomTargetingError_ReasonKEY_NAME_RESERVED CustomTargetingError_Reason = "KEY_NAME_RESERVED"

	//
	// {@link CustomTargetingKey#displayName} is too long.
	//
	CustomTargetingError_ReasonKEY_DISPLAY_NAME_INVALID_LENGTH CustomTargetingError_Reason = "KEY_DISPLAY_NAME_INVALID_LENGTH"

	//
	// Key is not active.
	//
	CustomTargetingError_ReasonKEY_STATUS_NOT_ACTIVE CustomTargetingError_Reason = "KEY_STATUS_NOT_ACTIVE"

	//
	// Requested {@link CustomTargetingValue} is not found.
	//
	CustomTargetingError_ReasonVALUE_NOT_FOUND CustomTargetingError_Reason = "VALUE_NOT_FOUND"

	//
	// The {@code WHERE} clause in the {@link Statement#query} must always
	// contain {@link CustomTargetingValue#customTargetingKeyId} as one of its
	// columns in a way that it is AND'ed with the rest of the query.
	//
	CustomTargetingError_ReasonGET_VALUES_BY_STATEMENT_MUST_CONTAIN_KEY_ID CustomTargetingError_Reason = "GET_VALUES_BY_STATEMENT_MUST_CONTAIN_KEY_ID"

	//
	// The number of {@link CustomTargetingValue} objects associated with a
	// {@link CustomTargetingKey} exceeds the network limit. This is only
	// applicable for keys of type {@code CustomTargetingKey.Type#PREDEFINED}.
	//
	CustomTargetingError_ReasonVALUE_COUNT_FOR_KEY_TOO_LARGE CustomTargetingError_Reason = "VALUE_COUNT_FOR_KEY_TOO_LARGE"

	//
	// {@link CustomTargetingValue} with the same
	// {@link CustomTargetingValue#name} already exists.
	//
	CustomTargetingError_ReasonVALUE_NAME_DUPLICATE CustomTargetingError_Reason = "VALUE_NAME_DUPLICATE"

	//
	// {@link CustomTargetingValue#name} is empty.
	//
	CustomTargetingError_ReasonVALUE_NAME_EMPTY CustomTargetingError_Reason = "VALUE_NAME_EMPTY"

	//
	// {@link CustomTargetingValue#name} is too long.
	//
	CustomTargetingError_ReasonVALUE_NAME_INVALID_LENGTH CustomTargetingError_Reason = "VALUE_NAME_INVALID_LENGTH"

	//
	// {@link CustomTargetingValue#name} contains unsupported or reserved
	// characters.
	//
	CustomTargetingError_ReasonVALUE_NAME_INVALID_CHARS CustomTargetingError_Reason = "VALUE_NAME_INVALID_CHARS"

	//
	// {@link CustomTargetingValue#displayName} is too long.
	//
	CustomTargetingError_ReasonVALUE_DISPLAY_NAME_INVALID_LENGTH CustomTargetingError_Reason = "VALUE_DISPLAY_NAME_INVALID_LENGTH"

	//
	// Only Ad Manager 360 networks can have {@link CustomTargetingValue#matchType}
	// other than {@link CustomTargetingValue.MatchType#EXACT}.
	//
	CustomTargetingError_ReasonVALUE_MATCH_TYPE_NOT_ALLOWED CustomTargetingError_Reason = "VALUE_MATCH_TYPE_NOT_ALLOWED"

	//
	// You can only create {@link CustomTargetingValue} objects with match type
	// {@link CustomTargetingValue.MatchType#EXACT} when associating
	// with {@link CustomTargetingKey} objects of type
	// {@link CustomTargetingKey.Type#PREDEFINED}
	//
	CustomTargetingError_ReasonVALUE_MATCH_TYPE_NOT_EXACT_FOR_PREDEFINED_KEY CustomTargetingError_Reason = "VALUE_MATCH_TYPE_NOT_EXACT_FOR_PREDEFINED_KEY"

	//
	// {@link CustomTargetingValue} object cannot have match type of
	// {@link CustomTargetingValue.MatchType#SUFFIX} when adding a
	// {@link CustomTargetingValue} to a line item.
	//
	CustomTargetingError_ReasonSUFFIX_MATCH_TYPE_NOT_ALLOWED CustomTargetingError_Reason = "SUFFIX_MATCH_TYPE_NOT_ALLOWED"

	//
	// {@link CustomTargetingValue} object cannot have match type of
	// {@link CustomTargetingValue.MatchType#CONTAINS} when adding a
	// {@link CustomTargetingValue} to targeting expression of a line item.
	//
	CustomTargetingError_ReasonCONTAINS_MATCH_TYPE_NOT_ALLOWED CustomTargetingError_Reason = "CONTAINS_MATCH_TYPE_NOT_ALLOWED"

	//
	// Value is not active.
	//
	CustomTargetingError_ReasonVALUE_STATUS_NOT_ACTIVE CustomTargetingError_Reason = "VALUE_STATUS_NOT_ACTIVE"

	//
	// The {@link CustomTargetingKey} does not have any
	// {@link CustomTargetingValue} associated with it.
	//
	CustomTargetingError_ReasonKEY_WITH_MISSING_VALUES CustomTargetingError_Reason = "KEY_WITH_MISSING_VALUES"

	//
	// The {@link CustomTargetingKey} has a {@link CustomTargetingValue} specified for which the
	// value is not a valid child.
	//
	CustomTargetingError_ReasonINVALID_VALUE_FOR_KEY CustomTargetingError_Reason = "INVALID_VALUE_FOR_KEY"

	//
	// {@link CustomCriteriaSet.LogicalOperator#OR} operation cannot be applied
	// to values with different keys.
	//
	CustomTargetingError_ReasonCANNOT_OR_DIFFERENT_KEYS CustomTargetingError_Reason = "CANNOT_OR_DIFFERENT_KEYS"

	//
	// Targeting expression is invalid. This can happen if the sequence of
	// operators is wrong, or a node contains invalid number of children.
	//
	CustomTargetingError_ReasonINVALID_TARGETING_EXPRESSION CustomTargetingError_Reason = "INVALID_TARGETING_EXPRESSION"

	//
	// The key has been deleted. {@link CustomCriteria} cannot have deleted
	// keys.
	//
	CustomTargetingError_ReasonDELETED_KEY_CANNOT_BE_USED_FOR_TARGETING CustomTargetingError_Reason = "DELETED_KEY_CANNOT_BE_USED_FOR_TARGETING"

	//
	// The value has been deleted. {@link CustomCriteria} cannot have deleted
	// values.
	//
	CustomTargetingError_ReasonDELETED_VALUE_CANNOT_BE_USED_FOR_TARGETING CustomTargetingError_Reason = "DELETED_VALUE_CANNOT_BE_USED_FOR_TARGETING"

	//
	// The key is set as the video browse-by key, which cannot be used for
	// custom targeting.
	//
	CustomTargetingError_ReasonVIDEO_BROWSE_BY_KEY_CANNOT_BE_USED_FOR_CUSTOM_TARGETING CustomTargetingError_Reason = "VIDEO_BROWSE_BY_KEY_CANNOT_BE_USED_FOR_CUSTOM_TARGETING"

	//
	// Only active custom-criteria keys are supported in content metadata mapping.
	//
	CustomTargetingError_ReasonCANNOT_DELETE_CUSTOM_KEY_USED_IN_CONTENT_METADATA_MAPPING CustomTargetingError_Reason = "CANNOT_DELETE_CUSTOM_KEY_USED_IN_CONTENT_METADATA_MAPPING"

	//
	// Only active custom-criteria values are supported in content metadata mapping.
	//
	CustomTargetingError_ReasonCANNOT_DELETE_CUSTOM_VALUE_USED_IN_CONTENT_METADATA_MAPPING CustomTargetingError_Reason = "CANNOT_DELETE_CUSTOM_VALUE_USED_IN_CONTENT_METADATA_MAPPING"

	//
	// Cannot delete a custom criteria key that is targeted by an active partner assignment.
	//
	CustomTargetingError_ReasonCANNOT_DELETE_CUSTOM_KEY_USED_IN_PARTNER_ASSIGNMENT_TARGETING CustomTargetingError_Reason = "CANNOT_DELETE_CUSTOM_KEY_USED_IN_PARTNER_ASSIGNMENT_TARGETING"

	//
	// Cannot delete a custom criteria value that is targeted by an active partner assignment.
	//
	CustomTargetingError_ReasonCANNOT_DELETE_CUSTOM_VALUE_USED_IN_PARTNER_ASSIGNMENT_TARGETING CustomTargetingError_Reason = "CANNOT_DELETE_CUSTOM_VALUE_USED_IN_PARTNER_ASSIGNMENT_TARGETING"

	//
	// {@link AudienceSegment} object cannot be targeted.
	//
	CustomTargetingError_ReasonCANNOT_TARGET_AUDIENCE_SEGMENT CustomTargetingError_Reason = "CANNOT_TARGET_AUDIENCE_SEGMENT"

	//
	// Third party {@link AudienceSegment} cannot be targeted.
	//
	CustomTargetingError_ReasonCANNOT_TARGET_THIRD_PARTY_AUDIENCE_SEGMENT CustomTargetingError_Reason = "CANNOT_TARGET_THIRD_PARTY_AUDIENCE_SEGMENT"

	//
	// Inactive {@link AudienceSegment} object cannot be targeted.
	//
	CustomTargetingError_ReasonCANNOT_TARGET_INACTIVE_AUDIENCE_SEGMENT CustomTargetingError_Reason = "CANNOT_TARGET_INACTIVE_AUDIENCE_SEGMENT"

	//
	// Targeted {@link AudienceSegment} object is not valid.
	//
	CustomTargetingError_ReasonINVALID_AUDIENCE_SEGMENTS CustomTargetingError_Reason = "INVALID_AUDIENCE_SEGMENTS"

	//
	// Mapped metadata key-values are deprecated and cannot be targeted.
	//
	CustomTargetingError_ReasonCANNOT_TARGET_MAPPED_METADATA CustomTargetingError_Reason = "CANNOT_TARGET_MAPPED_METADATA"

	//
	// Targeted {@link AudienceSegment} objects have not been approved.
	//
	CustomTargetingError_ReasonONLY_APPROVED_AUDIENCE_SEGMENTS_CAN_BE_TARGETED CustomTargetingError_Reason = "ONLY_APPROVED_AUDIENCE_SEGMENTS_CAN_BE_TARGETED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CustomTargetingError_ReasonUNKNOWN CustomTargetingError_Reason = "UNKNOWN"
)

//
// Specifies the available comparison operators.
//

type AudienceSegmentCriteria_ComparisonOperator string

const (
	AudienceSegmentCriteria_ComparisonOperatorIS AudienceSegmentCriteria_ComparisonOperator = "IS"

	AudienceSegmentCriteria_ComparisonOperatorIS_NOT AudienceSegmentCriteria_ComparisonOperator = "IS_NOT"
)

//
// {@link ApiErrorReason} enum for date time range targeting error.
//

type DateTimeRangeTargetingError_Reason string

const (

	//
	// No targeted ranges exists.
	//
	DateTimeRangeTargetingError_ReasonEMPTY_RANGES DateTimeRangeTargetingError_Reason = "EMPTY_RANGES"

	//
	// Type of lineitem is not sponsorship.
	//
	DateTimeRangeTargetingError_ReasonNOT_SPONSORSHIP_LINEITEM DateTimeRangeTargetingError_Reason = "NOT_SPONSORSHIP_LINEITEM"

	//
	// Type of lineitem is not sponsorship or standard.
	//
	DateTimeRangeTargetingError_ReasonNOT_SPONSORSHIP_OR_STANDARD_LINEITEM DateTimeRangeTargetingError_Reason = "NOT_SPONSORSHIP_OR_STANDARD_LINEITEM"

	//
	// Line item must have a reservation type of sponsorship, standard or preferred deal to use date
	// time range targeting.
	//
	DateTimeRangeTargetingError_ReasonUNSUPPORTED_LINEITEM_RESERVATION_TYPE DateTimeRangeTargetingError_Reason = "UNSUPPORTED_LINEITEM_RESERVATION_TYPE"

	//
	// Past ranges are changed.
	//
	DateTimeRangeTargetingError_ReasonPAST_RANGES_CHANGED DateTimeRangeTargetingError_Reason = "PAST_RANGES_CHANGED"

	//
	// Targeted date time ranges overlap.
	//
	DateTimeRangeTargetingError_ReasonRANGES_OVERLAP DateTimeRangeTargetingError_Reason = "RANGES_OVERLAP"

	//
	// First date time does not match line item's start time.
	//
	DateTimeRangeTargetingError_ReasonFIRST_DATE_TIME_DOES_NOT_MATCH_START_TIME DateTimeRangeTargetingError_Reason = "FIRST_DATE_TIME_DOES_NOT_MATCH_START_TIME"

	//
	// Last date time does not match line item's end time.
	//
	DateTimeRangeTargetingError_ReasonLAST_DATE_TIME_DOES_NOT_MATCH_END_TIME DateTimeRangeTargetingError_Reason = "LAST_DATE_TIME_DOES_NOT_MATCH_END_TIME"

	//
	// Targeted date time ranges fall out the active period of lineitem.
	//
	DateTimeRangeTargetingError_ReasonRANGES_OUT_OF_LINEITEM_ACTIVE_PERIOD DateTimeRangeTargetingError_Reason = "RANGES_OUT_OF_LINEITEM_ACTIVE_PERIOD"

	//
	// Start time of range (except the earliest range) is not at start of day.
	// Start of day is 00:00:00.
	//
	DateTimeRangeTargetingError_ReasonSTART_TIME_IS_NOT_START_OF_DAY DateTimeRangeTargetingError_Reason = "START_TIME_IS_NOT_START_OF_DAY"

	//
	// End time of range (except the latest range) is not at end of day.
	// End of day is 23:59:59.
	//
	DateTimeRangeTargetingError_ReasonEND_TIME_IS_NOT_END_OF_DAY DateTimeRangeTargetingError_Reason = "END_TIME_IS_NOT_END_OF_DAY"

	//
	// Start date time of earliest targeted ranges is in past.
	//
	DateTimeRangeTargetingError_ReasonSTART_DATE_TIME_IS_IN_PAST DateTimeRangeTargetingError_Reason = "START_DATE_TIME_IS_IN_PAST"

	//
	// Cannot modify the start date time for date time targeting to the past.
	//
	DateTimeRangeTargetingError_ReasonMODIFY_START_DATE_TIME_TO_PAST DateTimeRangeTargetingError_Reason = "MODIFY_START_DATE_TIME_TO_PAST"

	//
	// The end time of range is before the start time.
	// Could happen when start type is IMMEDIATE or ONE_HOUR_LATER.
	//
	DateTimeRangeTargetingError_ReasonRANGE_END_TIME_BEFORE_START_TIME DateTimeRangeTargetingError_Reason = "RANGE_END_TIME_BEFORE_START_TIME"

	//
	// End date time of latest targeted ranges is too late.
	//
	DateTimeRangeTargetingError_ReasonEND_DATE_TIME_IS_TOO_LATE DateTimeRangeTargetingError_Reason = "END_DATE_TIME_IS_TOO_LATE"

	DateTimeRangeTargetingError_ReasonLIMITED_RANGES_IN_UNLIMITED_LINEITEM DateTimeRangeTargetingError_Reason = "LIMITED_RANGES_IN_UNLIMITED_LINEITEM"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DateTimeRangeTargetingError_ReasonUNKNOWN DateTimeRangeTargetingError_Reason = "UNKNOWN"
)

//
// Days of the week.
//

type DayOfWeek string

const (

	//
	// The day of week named Monday.
	//
	DayOfWeekMONDAY DayOfWeek = "MONDAY"

	//
	// The day of week named Tuesday.
	//
	DayOfWeekTUESDAY DayOfWeek = "TUESDAY"

	//
	// The day of week named Wednesday.
	//
	DayOfWeekWEDNESDAY DayOfWeek = "WEDNESDAY"

	//
	// The day of week named Thursday.
	//
	DayOfWeekTHURSDAY DayOfWeek = "THURSDAY"

	//
	// The day of week named Friday.
	//
	DayOfWeekFRIDAY DayOfWeek = "FRIDAY"

	//
	// The day of week named Saturday.
	//
	DayOfWeekSATURDAY DayOfWeek = "SATURDAY"

	//
	// The day of week named Sunday.
	//
	DayOfWeekSUNDAY DayOfWeek = "SUNDAY"
)

//
// The reasons for the target error.
//

type DayPartTargetingError_Reason string

const (

	//
	// Hour of day must be between 0 and 24, inclusive.
	//
	DayPartTargetingError_ReasonINVALID_HOUR DayPartTargetingError_Reason = "INVALID_HOUR"

	//
	// Minute of hour must be one of 0, 15,30, 45.
	//
	DayPartTargetingError_ReasonINVALID_MINUTE DayPartTargetingError_Reason = "INVALID_MINUTE"

	//
	// The {@link DayPart#endTime} cannot be after {@link DayPart#startTime}.
	//
	DayPartTargetingError_ReasonEND_TIME_NOT_AFTER_START_TIME DayPartTargetingError_Reason = "END_TIME_NOT_AFTER_START_TIME"

	//
	// Cannot create day-parts that overlap.
	//
	DayPartTargetingError_ReasonTIME_PERIODS_OVERLAP DayPartTargetingError_Reason = "TIME_PERIODS_OVERLAP"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DayPartTargetingError_ReasonUNKNOWN DayPartTargetingError_Reason = "UNKNOWN"
)

//
// Represents the time zone to be used for {@link DayPartTargeting}.
//

type DeliveryTimeZone string

const (

	//
	// Use the time zone of the publisher.
	//
	DeliveryTimeZonePUBLISHER DeliveryTimeZone = "PUBLISHER"

	//
	// Use the time zone of the browser.
	//
	DeliveryTimeZoneBROWSER DeliveryTimeZone = "BROWSER"
)

//
// The reasons for the target error.
//

type DealError_Reason string

const (

	//
	// Cannot add new {@link ProposalLineItem proposal line items} to a {@link Proposal} when
	// {@link Proposal#isSold} is {@code true}.
	//
	DealError_ReasonCANNOT_ADD_LINE_ITEM_WHEN_SOLD DealError_Reason = "CANNOT_ADD_LINE_ITEM_WHEN_SOLD"

	//
	// Cannot archive {@link ProposalLineItem proposal line items} from a {@link Proposal} when
	// {@link Proposal#isSold} is {@code true}.
	//
	DealError_ReasonCANNOT_ARCHIVE_LINE_ITEM_WHEN_SOLD DealError_Reason = "CANNOT_ARCHIVE_LINE_ITEM_WHEN_SOLD"

	//
	// Cannot archive a {@link Proposal} when {@link Proposal#isSold} is {@code true}.
	//
	DealError_ReasonCANNOT_ARCHIVE_PROPOSAL_WHEN_SOLD DealError_Reason = "CANNOT_ARCHIVE_PROPOSAL_WHEN_SOLD"

	//
	// Cannot change a field that requires buyer approval during the current operation.
	//
	DealError_ReasonCANNOT_CHANGE_FIELD_REQUIRING_BUYER_APPROVAL DealError_Reason = "CANNOT_CHANGE_FIELD_REQUIRING_BUYER_APPROVAL"

	//
	// Cannot find seller ID for the {@link Proposal}.
	//
	DealError_ReasonCANNOT_GET_SELLER_ID DealError_Reason = "CANNOT_GET_SELLER_ID"

	//
	// {@link Proposal} must be marked as editable by {@link EditProposalsForNegotiation} before
	// performing requested action.
	//
	DealError_ReasonCAN_ONLY_EXECUTE_IF_LOCAL_EDITS DealError_Reason = "CAN_ONLY_EXECUTE_IF_LOCAL_EDITS"

	//
	// {@link Proposal} contains no {@link ProposalLineItem proposal line items}.
	//
	DealError_ReasonMISSING_PROPOSAL_LINE_ITEMS DealError_Reason = "MISSING_PROPOSAL_LINE_ITEMS"

	//
	// No environment set for {@link Proposal}.
	//
	DealError_ReasonMISSING_ENVIRONMENT DealError_Reason = "MISSING_ENVIRONMENT"

	//
	// The Ad Exchange property is not associated with the current network.
	//
	DealError_ReasonMISSING_AD_EXCHANGE_PROPERTY DealError_Reason = "MISSING_AD_EXCHANGE_PROPERTY"

	//
	// Cannot find {@link Proposal} in Marketplace.
	//
	DealError_ReasonCANNOT_FIND_PROPOSAL_IN_MARKETPLACE DealError_Reason = "CANNOT_FIND_PROPOSAL_IN_MARKETPLACE"

	//
	// No {@link Product} exists for buyer-initiated programmatic {@link Proposal proposals}.
	//
	DealError_ReasonCANNOT_GET_PRODUCT DealError_Reason = "CANNOT_GET_PRODUCT"

	//
	// A new version of the {@link Proposal} was sent from buyer, cannot execute the requested
	// action before performing {@link DiscardLocalVersionEdits}.
	//
	DealError_ReasonNEW_VERSION_FROM_BUYER DealError_Reason = "NEW_VERSION_FROM_BUYER"

	//
	// A new version of the {@link Proposal} exists in Marketplace, cannot execute the requested
	// action before the proposal is synced to newest revision.
	//
	DealError_ReasonPROPOSAL_OUT_OF_SYNC_WITH_MARKETPLACE DealError_Reason = "PROPOSAL_OUT_OF_SYNC_WITH_MARKETPLACE"

	//
	// No {@link Proposal} changes were found.
	//
	DealError_ReasonNO_PROPOSAL_CHANGES_FOUND DealError_Reason = "NO_PROPOSAL_CHANGES_FOUND"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DealError_ReasonUNKNOWN DealError_Reason = "UNKNOWN"
)

//
// Possible delivery rates for a {@link LineItem}, which dictate the manner in
// which they are served.
//

type DeliveryRateType string

const (

	//
	// Line items are served as evenly as possible across the number of
	// days specified in a line item's {@link LineItem#duration}.
	//
	DeliveryRateTypeEVENLY DeliveryRateType = "EVENLY"

	//
	// Line items are served more aggressively in the beginning of the flight
	// date.
	//
	DeliveryRateTypeFRONTLOADED DeliveryRateType = "FRONTLOADED"

	//
	// The booked impressions for a line item may be delivered well before the
	// {@link LineItem#endDateTime}. Other lower-priority or lower-value line
	// items will be stopped from delivering until this line item meets the number
	// of impressions or clicks it is booked for.
	//
	DeliveryRateTypeAS_FAST_AS_POSSIBLE DeliveryRateType = "AS_FAST_AS_POSSIBLE"
)

//
// The reasons for the entity children limit reached error.
//

type EntityChildrenLimitReachedError_Reason string

const (

	//
	// The number of line items on the order exceeds the max number of line items allowed per order
	// in the network.
	//
	EntityChildrenLimitReachedError_ReasonLINE_ITEM_LIMIT_FOR_ORDER_REACHED EntityChildrenLimitReachedError_Reason = "LINE_ITEM_LIMIT_FOR_ORDER_REACHED"

	//
	// The number of creatives associated with the line item exceeds the max number of creatives
	// allowed to be associated with a line item in the network.
	//
	EntityChildrenLimitReachedError_ReasonCREATIVE_ASSOCIATION_LIMIT_FOR_LINE_ITEM_REACHED EntityChildrenLimitReachedError_Reason = "CREATIVE_ASSOCIATION_LIMIT_FOR_LINE_ITEM_REACHED"

	//
	// The number of ad units on the placement exceeds the max number of ad units
	// allowed per placement in the network.
	//
	EntityChildrenLimitReachedError_ReasonAD_UNIT_LIMIT_FOR_PLACEMENT_REACHED EntityChildrenLimitReachedError_Reason = "AD_UNIT_LIMIT_FOR_PLACEMENT_REACHED"

	//
	// The number of targeting expressions on the line item exceeds the max number of targeting
	// expressions allowed per line item in the network.
	//
	EntityChildrenLimitReachedError_ReasonTARGETING_EXPRESSION_LIMIT_FOR_LINE_ITEM_REACHED EntityChildrenLimitReachedError_Reason = "TARGETING_EXPRESSION_LIMIT_FOR_LINE_ITEM_REACHED"

	//
	// The size of a single targeting expression tree exceeds the max size allowed by the network.
	//
	EntityChildrenLimitReachedError_ReasonTARGETING_EXPRESSION_SIZE_LIMIT_REACHED EntityChildrenLimitReachedError_Reason = "TARGETING_EXPRESSION_SIZE_LIMIT_REACHED"

	//
	// The number of custom targeting values for the free-form or predefined custom targeting key
	// exceeds the max number allowed.
	//
	EntityChildrenLimitReachedError_ReasonCUSTOM_TARGETING_VALUES_FOR_KEY_LIMIT_REACHED EntityChildrenLimitReachedError_Reason = "CUSTOM_TARGETING_VALUES_FOR_KEY_LIMIT_REACHED"

	//
	// The total number of targeting expressions on the creatives for the line item exceeds
	// the max number allowed per line item in the network.
	//
	EntityChildrenLimitReachedError_ReasonTARGETING_EXPRESSION_LIMIT_FOR_CREATIVES_ON_LINE_ITEM_REACHED EntityChildrenLimitReachedError_Reason = "TARGETING_EXPRESSION_LIMIT_FOR_CREATIVES_ON_LINE_ITEM_REACHED"

	//
	// The number of attachments added to the proposal exceeds the max number
	// allowed per proposal in the network.
	//
	EntityChildrenLimitReachedError_ReasonATTACHMENT_LIMIT_FOR_PROPOSAL_REACHED EntityChildrenLimitReachedError_Reason = "ATTACHMENT_LIMIT_FOR_PROPOSAL_REACHED"

	//
	// The number of proposal line items on the proposal exceeds the max number
	// allowed per proposal in the network.
	//
	EntityChildrenLimitReachedError_ReasonPROPOSAL_LINE_ITEM_LIMIT_FOR_PROPOSAL_REACHED EntityChildrenLimitReachedError_Reason = "PROPOSAL_LINE_ITEM_LIMIT_FOR_PROPOSAL_REACHED"

	//
	// The number of product package items on the product package exceeds the max number
	// allowed per product package in the network.
	//
	EntityChildrenLimitReachedError_ReasonPRODUCT_LIMIT_FOR_PRODUCT_PACKAGE_REACHED EntityChildrenLimitReachedError_Reason = "PRODUCT_LIMIT_FOR_PRODUCT_PACKAGE_REACHED"

	//
	// The number of product template and product base rates on the rate card (including excluded
	// product base rates) exceeds the max number allowed per rate card in the network.
	//
	EntityChildrenLimitReachedError_ReasonPRODUCT_TEMPLATE_AND_PRODUCT_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED EntityChildrenLimitReachedError_Reason = "PRODUCT_TEMPLATE_AND_PRODUCT_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED"

	//
	// The number of product package item base rates on the rate card exceeds the max number
	// allowed per rate card in the network.
	//
	EntityChildrenLimitReachedError_ReasonPRODUCT_PACKAGE_ITEM_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED EntityChildrenLimitReachedError_Reason = "PRODUCT_PACKAGE_ITEM_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED"

	//
	// The number of premiums of the rate card exceeds the max number allowed per rate card
	// in the network.
	//
	EntityChildrenLimitReachedError_ReasonPREMIUM_LIMIT_FOR_RATE_CARD_REACHED EntityChildrenLimitReachedError_Reason = "PREMIUM_LIMIT_FOR_RATE_CARD_REACHED"

	//
	// The number of ad units on {@link AdExclusionRule#inventoryTargeting} exceeds the max number
	// of ad units allowed per ad exclusion rule inventory targeting in the network.
	//
	EntityChildrenLimitReachedError_ReasonAD_UNIT_LIMIT_FOR_AD_EXCLUSION_RULE_TARGETING_REACHED EntityChildrenLimitReachedError_Reason = "AD_UNIT_LIMIT_FOR_AD_EXCLUSION_RULE_TARGETING_REACHED"

	//
	// The number of native styles under the native creative template exceeds the
	// max number of native styles allowed per native creative template in the
	// network.
	//
	EntityChildrenLimitReachedError_ReasonNATIVE_STYLE_LIMIT_FOR_NATIVE_AD_FORMAT_REACHED EntityChildrenLimitReachedError_Reason = "NATIVE_STYLE_LIMIT_FOR_NATIVE_AD_FORMAT_REACHED"

	//
	// The number of targeting expressions on the native style exceeds the max number of targeting
	// expressions allowed per native style in the network.
	//
	EntityChildrenLimitReachedError_ReasonTARGETING_EXPRESSION_LIMIT_FOR_PRESENTATION_ASSIGNMENT_REACHED EntityChildrenLimitReachedError_Reason = "TARGETING_EXPRESSION_LIMIT_FOR_PRESENTATION_ASSIGNMENT_REACHED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityChildrenLimitReachedError_ReasonUNKNOWN EntityChildrenLimitReachedError_Reason = "UNKNOWN"
)

//
// The reasons for the entity limit reached error.
//

type EntityLimitReachedError_Reason string

const (

	//
	// The number of custom targeting values exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonCUSTOM_TARGETING_VALUES_LIMIT_REACHED EntityLimitReachedError_Reason = "CUSTOM_TARGETING_VALUES_LIMIT_REACHED"

	//
	// The number of ad exclusion rules exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonAD_EXCLUSION_RULES_LIMIT_REACHED EntityLimitReachedError_Reason = "AD_EXCLUSION_RULES_LIMIT_REACHED"

	//
	// The number of first party audience segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonFIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "FIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED"

	//
	// The number of active placements exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonPLACEMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "PLACEMENTS_LIMIT_REACHED"

	//
	// The number of line items excceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonLINE_ITEMS_LIMIT_REACHED EntityLimitReachedError_Reason = "LINE_ITEMS_LIMIT_REACHED"

	//
	// The number of active line items exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonACTIVE_LINE_ITEMS_LIMIT_REACHED EntityLimitReachedError_Reason = "ACTIVE_LINE_ITEMS_LIMIT_REACHED"

	//
	// The number of not-archived encoding profiles exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonDAI_ENCODING_PROFILES_LIMIT_REACHED EntityLimitReachedError_Reason = "DAI_ENCODING_PROFILES_LIMIT_REACHED"

	//
	// The number of traffic forecast segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonTRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "TRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED"

	//
	// The number of forecast adjustments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonFORECAST_ADJUSTMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "FORECAST_ADJUSTMENTS_LIMIT_REACHED"

	//
	// The number of active experiments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonACTIVE_EXPERIMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "ACTIVE_EXPERIMENTS_LIMIT_REACHED"

	//
	// The number of sites exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonSITES_LIMIT_REACHED EntityLimitReachedError_Reason = "SITES_LIMIT_REACHED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityLimitReachedError_ReasonUNKNOWN EntityLimitReachedError_Reason = "UNKNOWN"
)

//
// Enum for the valid environments in which ads can be shown.
//

type EnvironmentType string

const (

	//
	// A regular web browser.
	//
	EnvironmentTypeBROWSER EnvironmentType = "BROWSER"

	//
	// Video players.
	//
	EnvironmentTypeVIDEO_PLAYER EnvironmentType = "VIDEO_PLAYER"
)

//
// The reasons for the target error.
//

type ExchangeRateError_Reason string

const (

	//
	// The currency code is invalid and does not follow ISO 4217.
	//
	ExchangeRateError_ReasonINVALID_CURRENCY_CODE ExchangeRateError_Reason = "INVALID_CURRENCY_CODE"

	//
	// The currency code is not supported.
	//
	ExchangeRateError_ReasonUNSUPPORTED_CURRENCY_CODE ExchangeRateError_Reason = "UNSUPPORTED_CURRENCY_CODE"

	//
	// The currency code already exists. When creating an exchange rate, its currency should not be
	// associated with any existing exchange rate. When creating a list of exchange rates, there
	// should not be two exchange rates associated with same currency.
	//
	ExchangeRateError_ReasonCURRENCY_CODE_ALREADY_EXISTS ExchangeRateError_Reason = "CURRENCY_CODE_ALREADY_EXISTS"

	//
	// The exchange rate value is invalid. When the {@link ExchangeRate#refreshRate} is
	// {@link ExchangeRateRefreshRate#FIXED}, the {@link ExchangeRate#exchangeRate} should be larger
	// than 0. Otherwise it is invalid.
	//
	ExchangeRateError_ReasonINVALID_EXCHANGE_RATE ExchangeRateError_Reason = "INVALID_EXCHANGE_RATE"

	//
	// The exchange rate value is not found. When the {@link ExchangeRate#refreshRate} is
	// {@link ExchangeRateRefreshRate#DAILY} or {@link ExchangeRateRefreshRate#MONTHLY}, the
	// {@link ExchangeRate#exchangeRate} should be assigned by Google. It is not found if Google
	// cannot find such an exchange rate.
	//
	ExchangeRateError_ReasonEXCHANGE_RATE_NOT_FOUND ExchangeRateError_Reason = "EXCHANGE_RATE_NOT_FOUND"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ExchangeRateError_ReasonUNKNOWN ExchangeRateError_Reason = "UNKNOWN"
)

type FeatureError_Reason string

const (

	//
	// A feature is being used that is not enabled on the current network.
	//
	FeatureError_ReasonMISSING_FEATURE FeatureError_Reason = "MISSING_FEATURE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FeatureError_ReasonUNKNOWN FeatureError_Reason = "UNKNOWN"
)

//
// Reason why a forecast could not be retrieved.
//

type ForecastError_Reason string

const (

	//
	// The forecast could not be retrieved due to a server side
	// connection problem. Please try again soon.
	//
	ForecastError_ReasonSERVER_NOT_AVAILABLE ForecastError_Reason = "SERVER_NOT_AVAILABLE"

	//
	// There was an unexpected internal error.
	//
	ForecastError_ReasonINTERNAL_ERROR ForecastError_Reason = "INTERNAL_ERROR"

	//
	// The forecast could not be retrieved because there is not
	// enough forecasting data available yet. It may take up to one week before
	// enough data is available.
	//
	ForecastError_ReasonNO_FORECAST_YET ForecastError_Reason = "NO_FORECAST_YET"

	//
	// There's not enough inventory for the requested reservation.
	//
	ForecastError_ReasonNOT_ENOUGH_INVENTORY ForecastError_Reason = "NOT_ENOUGH_INVENTORY"

	//
	// No error from forecast.
	//
	ForecastError_ReasonSUCCESS ForecastError_Reason = "SUCCESS"

	//
	// The requested reservation is of zero length.  No forecast is returned.
	//
	ForecastError_ReasonZERO_LENGTH_RESERVATION ForecastError_Reason = "ZERO_LENGTH_RESERVATION"

	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>
	// Another way to mitigate this error is to limit requests to 2 per second.
	// Once again this does not guarantee that every request will succeed, but
	// may help reduce the number of times you receive this error.
	// </p>
	//
	ForecastError_ReasonEXCEEDED_QUOTA ForecastError_Reason = "EXCEEDED_QUOTA"

	//
	// The request falls outside the date range of the available data.
	//
	ForecastError_ReasonOUTSIDE_AVAILABLE_DATE_RANGE ForecastError_Reason = "OUTSIDE_AVAILABLE_DATE_RANGE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ForecastError_ReasonUNKNOWN ForecastError_Reason = "UNKNOWN"
)

type FrequencyCapError_Reason string

const (
	FrequencyCapError_ReasonIMPRESSION_LIMIT_EXCEEDED FrequencyCapError_Reason = "IMPRESSION_LIMIT_EXCEEDED"

	FrequencyCapError_ReasonIMPRESSIONS_TOO_LOW FrequencyCapError_Reason = "IMPRESSIONS_TOO_LOW"

	FrequencyCapError_ReasonRANGE_LIMIT_EXCEEDED FrequencyCapError_Reason = "RANGE_LIMIT_EXCEEDED"

	FrequencyCapError_ReasonRANGE_TOO_LOW FrequencyCapError_Reason = "RANGE_TOO_LOW"

	FrequencyCapError_ReasonDUPLICATE_TIME_RANGE FrequencyCapError_Reason = "DUPLICATE_TIME_RANGE"

	FrequencyCapError_ReasonTOO_MANY_FREQUENCY_CAPS FrequencyCapError_Reason = "TOO_MANY_FREQUENCY_CAPS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FrequencyCapError_ReasonUNKNOWN FrequencyCapError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type GenericTargetingError_Reason string

const (

	//
	// Both including and excluding sibling criteria is disallowed.
	//
	GenericTargetingError_ReasonCONFLICTING_INCLUSION_OR_EXCLUSION_OF_SIBLINGS GenericTargetingError_Reason = "CONFLICTING_INCLUSION_OR_EXCLUSION_OF_SIBLINGS"

	//
	// Including descendants of excluded criteria is disallowed.
	//
	GenericTargetingError_ReasonINCLUDING_DESCENDANTS_OF_EXCLUDED_CRITERIA GenericTargetingError_Reason = "INCLUDING_DESCENDANTS_OF_EXCLUDED_CRITERIA"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GenericTargetingError_ReasonUNKNOWN GenericTargetingError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type GeoTargetingError_Reason string

const (

	//
	// A location that is targeted cannot also be excluded.
	//
	GeoTargetingError_ReasonTARGETED_LOCATIONS_NOT_EXCLUDABLE GeoTargetingError_Reason = "TARGETED_LOCATIONS_NOT_EXCLUDABLE"

	//
	// Excluded locations cannot have any of their children targeted.
	//
	GeoTargetingError_ReasonEXCLUDED_LOCATIONS_CANNOT_HAVE_CHILDREN_TARGETED GeoTargetingError_Reason = "EXCLUDED_LOCATIONS_CANNOT_HAVE_CHILDREN_TARGETED"

	//
	// Postal codes cannot be excluded.
	//
	GeoTargetingError_ReasonPOSTAL_CODES_CANNOT_BE_EXCLUDED GeoTargetingError_Reason = "POSTAL_CODES_CANNOT_BE_EXCLUDED"

	//
	// Indicates that location targeting is not allowed.
	//
	GeoTargetingError_ReasonUNTARGETABLE_LOCATION GeoTargetingError_Reason = "UNTARGETABLE_LOCATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GeoTargetingError_ReasonUNKNOWN GeoTargetingError_Reason = "UNKNOWN"
)

//
// Specifies the type of the goal for a {@link LineItem}.
//

type GoalType string

const (

	//
	// No goal is specified for the number of ads delivered. The
	// {@link LineItem#lineItemType} must be one of:
	// <ul>
	// <li>{@link LineItemType#PRICE_PRIORITY}</li>
	// <li>{@link LineItemType#AD_EXCHANGE}</li>
	// <li>{@link LineItemType#CLICK_TRACKING}</li>
	// </ul>
	//
	GoalTypeNONE GoalType = "NONE"

	//
	// There is a goal on the number of ads delivered for this line item during
	// its entire lifetime. The {@link LineItem#lineItemType} must be
	// one of:
	// <ul>
	// <li>{@link LineItemType#STANDARD}</li>
	// <li>{@link LineItemType#BULK}</li>
	// <li>{@link LineItemType#PRICE_PRIORITY}</li>
	// <li>{@link LineItemType#ADSENSE}</li>
	// <li>{@link LineItemType#AD_EXCHANGE}</li>
	// <li>{@link LineItemType#ADMOB}</li>
	// <li>{@link LineItemType#CLICK_TRACKING}</li>
	// </ul>
	//
	GoalTypeLIFETIME GoalType = "LIFETIME"

	//
	// There is a daily goal on the number of ads delivered for this line item.
	// The {@link LineItem#lineItemType} must be one of:
	// <ul>
	// <li>{@link LineItemType#SPONSORSHIP}</li>
	// <li>{@link LineItemType#NETWORK}</li>
	// <li>{@link LineItemType#PRICE_PRIORITY}</li>
	// <li>{@link LineItemType#HOUSE}</li>
	// <li>{@link LineItemType#ADSENSE}</li>
	// <li>{@link LineItemType#AD_EXCHANGE}</li>
	// <li>{@link LineItemType#ADMOB}</li>
	// <li>{@link LineItemType#BUMPER}</li>
	// </ul>
	//
	GoalTypeDAILY GoalType = "DAILY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GoalTypeUNKNOWN GoalType = "UNKNOWN"
)

//
// Represents available GRP providers that a line item will have its target demographic measured
// by.
//

type GrpProvider string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GrpProviderUNKNOWN GrpProvider = "UNKNOWN"

	GrpProviderNIELSEN GrpProvider = "NIELSEN"

	//
	// Renamed to {@code GOOGLE} beginning in V201608.
	//
	GrpProviderGOOGLE GrpProvider = "GOOGLE"
)

//
// Reason for GRP settings error.
//

type GrpSettingsError_Reason string

const (

	//
	// Age range for GRP audience is not valid. Please see the
	// <a href="https://support.google.com/admanager/answer/6135438">Ad Manager Help Center</a>
	// for more information.
	//
	GrpSettingsError_ReasonINVALID_AGE_RANGE GrpSettingsError_Reason = "INVALID_AGE_RANGE"

	//
	// Age range for GRP audience is not allowed to include ages under 18 unless designating all
	// ages in target(2-65+).
	//
	GrpSettingsError_ReasonUNDER_18_MIN_AGE_REQUIRES_ALL_AGES GrpSettingsError_Reason = "UNDER_18_MIN_AGE_REQUIRES_ALL_AGES"

	//
	// GRP settings are only supported for video line items.
	//
	GrpSettingsError_ReasonLINE_ITEM_ENVIRONMENT_TYPE_NOT_SUPPORTED GrpSettingsError_Reason = "LINE_ITEM_ENVIRONMENT_TYPE_NOT_SUPPORTED"

	//
	// For deals with Nielsen DAR enabled, there must be an instream video environment.
	//
	GrpSettingsError_ReasonNIELSEN_DAR_REQUIRES_INSTREAM_VIDEO GrpSettingsError_Reason = "NIELSEN_DAR_REQUIRES_INSTREAM_VIDEO"

	//
	// GRP settings are not supported for the given line item type.
	//
	GrpSettingsError_ReasonLINE_ITEM_TYPE_NOT_SUPPORTED GrpSettingsError_Reason = "LINE_ITEM_TYPE_NOT_SUPPORTED"

	//
	// GRP audience gender cannot be specified for the selected age range.
	//
	GrpSettingsError_ReasonCANNOT_SPECIFY_GENDER_FOR_GIVEN_AGE_RANGE GrpSettingsError_Reason = "CANNOT_SPECIFY_GENDER_FOR_GIVEN_AGE_RANGE"

	//
	// Minimum age for GRP audience is not valid.
	//
	GrpSettingsError_ReasonINVALID_MIN_AGE GrpSettingsError_Reason = "INVALID_MIN_AGE"

	//
	// Maximum age for GRP audience is not valid.
	//
	GrpSettingsError_ReasonINVALID_MAX_AGE GrpSettingsError_Reason = "INVALID_MAX_AGE"

	//
	// GRP settings cannot be disabled.
	//
	GrpSettingsError_ReasonCANNOT_DISABLE_GRP_AFTER_ENABLING GrpSettingsError_Reason = "CANNOT_DISABLE_GRP_AFTER_ENABLING"

	//
	// GRP provider cannot be updated.
	//
	GrpSettingsError_ReasonCANNOT_CHANGE_GRP_PROVIDERS GrpSettingsError_Reason = "CANNOT_CHANGE_GRP_PROVIDERS"

	//
	// GRP settings cannot be updated once the line item has started serving.
	//
	GrpSettingsError_ReasonCANNOT_CHANGE_GRP_SETTINGS GrpSettingsError_Reason = "CANNOT_CHANGE_GRP_SETTINGS"

	//
	// Impression goal based on GRP audience is not supported.
	//
	GrpSettingsError_ReasonGRP_AUDIENCE_GOAL_NOT_SUPPORTED GrpSettingsError_Reason = "GRP_AUDIENCE_GOAL_NOT_SUPPORTED"

	//
	// Impression goal based on GRP audience expected.
	//
	GrpSettingsError_ReasonDEMOG_GOAL_EXPECTED GrpSettingsError_Reason = "DEMOG_GOAL_EXPECTED"

	//
	// Impression goal based on GRP audience cannot be set once the line item has started serving.
	//
	GrpSettingsError_ReasonCANNOT_SET_GRP_AUDIENCE_GOAL GrpSettingsError_Reason = "CANNOT_SET_GRP_AUDIENCE_GOAL"

	//
	// Impression goal based on GRP audience cannot be removed once the line item has started
	// serving.
	//
	GrpSettingsError_ReasonCANNOT_REMOVE_GRP_AUDIENCE_GOAL GrpSettingsError_Reason = "CANNOT_REMOVE_GRP_AUDIENCE_GOAL"

	//
	// Unsupported geographic location targeted for line item with GRP audience goal.
	//
	GrpSettingsError_ReasonUNSUPPORTED_GEO_TARGETING GrpSettingsError_Reason = "UNSUPPORTED_GEO_TARGETING"

	//
	// GRP Settings specified are unsupported.
	//
	GrpSettingsError_ReasonUNSUPPORTED_GRP_SETTING GrpSettingsError_Reason = "UNSUPPORTED_GRP_SETTING"

	//
	// In-target line items should be set through the grpSettings target impression goal.
	//
	GrpSettingsError_ReasonSHOULD_SET_IN_TARGET_GOAL_THROUGH_GRP_SETTINGS GrpSettingsError_Reason = "SHOULD_SET_IN_TARGET_GOAL_THROUGH_GRP_SETTINGS"

	//
	// In-target line items should be set through the primaryReservationUnit's in-target Impressions
	// unit type.
	//
	GrpSettingsError_ReasonSHOULD_SET_IN_TARGET_GOAL_THROUGH_PRIMARY_GOAL GrpSettingsError_Reason = "SHOULD_SET_IN_TARGET_GOAL_THROUGH_PRIMARY_GOAL"

	//
	// Attempt to register with Nielsen failed.
	//
	GrpSettingsError_ReasonNIELSEN_REGISTRATION_FAILED GrpSettingsError_Reason = "NIELSEN_REGISTRATION_FAILED"

	//
	// Attempted to register a placement on a legacy Nielsen campaign.
	//
	GrpSettingsError_ReasonLEGACY_NIELSEN_CAMPAIGN_REGISTRATION_ATTEMPT GrpSettingsError_Reason = "LEGACY_NIELSEN_CAMPAIGN_REGISTRATION_ATTEMPT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GrpSettingsError_ReasonUNKNOWN GrpSettingsError_Reason = "UNKNOWN"
)

//
// Represents the target gender for a GRP demographic targeted line item.
//

type GrpTargetGender string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GrpTargetGenderUNKNOWN GrpTargetGender = "UNKNOWN"

	//
	// Indicates that the GRP target gender is Male.
	//
	GrpTargetGenderMALE GrpTargetGender = "MALE"

	//
	// Indicates that the GRP target gender is Female.
	//
	GrpTargetGenderFEMALE GrpTargetGender = "FEMALE"

	//
	// Indicates that the GRP target gender is both male and female.
	//
	GrpTargetGenderBOTH GrpTargetGender = "BOTH"
)

//
// The single reason for the internal API error.
//

type InternalApiError_Reason string

const (

	//
	// API encountered an unexpected internal error.
	//
	InternalApiError_ReasonUNEXPECTED_INTERNAL_API_ERROR InternalApiError_Reason = "UNEXPECTED_INTERNAL_API_ERROR"

	//
	// A temporary error occurred during the request. Please retry.
	//
	InternalApiError_ReasonTRANSIENT_ERROR InternalApiError_Reason = "TRANSIENT_ERROR"

	//
	// The cause of the error is not known or only defined in newer versions.
	//
	InternalApiError_ReasonUNKNOWN InternalApiError_Reason = "UNKNOWN"

	//
	// The API is currently unavailable for a planned downtime.
	//
	InternalApiError_ReasonDOWNTIME InternalApiError_Reason = "DOWNTIME"

	//
	// Mutate succeeded but server was unable to build response. Client should not retry mutate.
	//
	InternalApiError_ReasonERROR_GENERATING_RESPONSE InternalApiError_Reason = "ERROR_GENERATING_RESPONSE"
)

//
// The reasons for the target error.
//

type InventoryTargetingError_Reason string

const (

	//
	// At least one placement or inventory unit is required
	//
	InventoryTargetingError_ReasonAT_LEAST_ONE_PLACEMENT_OR_INVENTORY_UNIT_REQUIRED InventoryTargetingError_Reason = "AT_LEAST_ONE_PLACEMENT_OR_INVENTORY_UNIT_REQUIRED"

	//
	// The same inventory unit or placement cannot be targeted and excluded at
	// the same time
	//
	InventoryTargetingError_ReasonINVENTORY_CANNOT_BE_TARGETED_AND_EXCLUDED InventoryTargetingError_Reason = "INVENTORY_CANNOT_BE_TARGETED_AND_EXCLUDED"

	//
	// A child inventory unit cannot be targeted if its ancestor inventory unit
	// is also targeted.
	//
	InventoryTargetingError_ReasonINVENTORY_UNIT_CANNOT_BE_TARGETED_IF_ANCESTOR_IS_TARGETED InventoryTargetingError_Reason = "INVENTORY_UNIT_CANNOT_BE_TARGETED_IF_ANCESTOR_IS_TARGETED"

	//
	// A child inventory unit cannot be targeted if its ancestor inventory unit
	// is excluded.
	//
	InventoryTargetingError_ReasonINVENTORY_UNIT_CANNOT_BE_TARGETED_IF_ANCESTOR_IS_EXCLUDED InventoryTargetingError_Reason = "INVENTORY_UNIT_CANNOT_BE_TARGETED_IF_ANCESTOR_IS_EXCLUDED"

	//
	// A child inventory unit cannot be excluded if its ancestor inventory unit
	// is also excluded.
	//
	InventoryTargetingError_ReasonINVENTORY_UNIT_CANNOT_BE_EXCLUDED_IF_ANCESTOR_IS_EXCLUDED InventoryTargetingError_Reason = "INVENTORY_UNIT_CANNOT_BE_EXCLUDED_IF_ANCESTOR_IS_EXCLUDED"

	//
	// An explicitly targeted inventory unit cannot be targeted.
	//
	InventoryTargetingError_ReasonEXPLICITLY_TARGETED_INVENTORY_UNIT_CANNOT_BE_TARGETED InventoryTargetingError_Reason = "EXPLICITLY_TARGETED_INVENTORY_UNIT_CANNOT_BE_TARGETED"

	//
	// An explicitly targeted inventory unit cannot be excluded.
	//
	InventoryTargetingError_ReasonEXPLICITLY_TARGETED_INVENTORY_UNIT_CANNOT_BE_EXCLUDED InventoryTargetingError_Reason = "EXPLICITLY_TARGETED_INVENTORY_UNIT_CANNOT_BE_EXCLUDED"

	//
	// A landing page-only ad unit cannot be targeted.
	//
	InventoryTargetingError_ReasonSELF_ONLY_INVENTORY_UNIT_NOT_ALLOWED InventoryTargetingError_Reason = "SELF_ONLY_INVENTORY_UNIT_NOT_ALLOWED"

	//
	// A landing page-only ad unit cannot be targeted if it doesn't have any
	// children.
	//
	InventoryTargetingError_ReasonSELF_ONLY_INVENTORY_UNIT_WITHOUT_DESCENDANTS InventoryTargetingError_Reason = "SELF_ONLY_INVENTORY_UNIT_WITHOUT_DESCENDANTS"

	//
	// Audience segments shared from YouTube can only be targeted with inventory shared
	// from YouTube for cross selling.
	//
	InventoryTargetingError_ReasonYOUTUBE_AUDIENCE_SEGMENTS_CAN_ONLY_BE_TARGETED_WITH_YOUTUBE_SHARED_INVENTORY InventoryTargetingError_Reason = "YOUTUBE_AUDIENCE_SEGMENTS_CAN_ONLY_BE_TARGETED_WITH_YOUTUBE_SHARED_INVENTORY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InventoryTargetingError_ReasonUNKNOWN InventoryTargetingError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type LabelEntityAssociationError_Reason string

const (

	//
	// The label has already been attached to the entity.
	//
	LabelEntityAssociationError_ReasonDUPLICATE_ASSOCIATION LabelEntityAssociationError_Reason = "DUPLICATE_ASSOCIATION"

	//
	// A label is being applied to an entity that does not support that entity
	// type.
	//
	LabelEntityAssociationError_ReasonINVALID_ASSOCIATION LabelEntityAssociationError_Reason = "INVALID_ASSOCIATION"

	//
	// Label negation cannot be applied to the entity type.
	//
	LabelEntityAssociationError_ReasonNEGATION_NOT_ALLOWED LabelEntityAssociationError_Reason = "NEGATION_NOT_ALLOWED"

	//
	// The same label is being applied and negated to the same entity.
	//
	LabelEntityAssociationError_ReasonDUPLICATE_ASSOCIATION_WITH_NEGATION LabelEntityAssociationError_Reason = "DUPLICATE_ASSOCIATION_WITH_NEGATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LabelEntityAssociationError_ReasonUNKNOWN LabelEntityAssociationError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type LineItemError_Reason string

const (

	//
	// Some changes may not be allowed because a line item has already started.
	//
	LineItemError_ReasonALREADY_STARTED LineItemError_Reason = "ALREADY_STARTED"

	//
	// Update reservation is not allowed because a line item has
	// already started, users must pause the line item first.
	//
	LineItemError_ReasonUPDATE_RESERVATION_NOT_ALLOWED LineItemError_Reason = "UPDATE_RESERVATION_NOT_ALLOWED"

	//
	// Roadblocking to display all creatives is not allowed.
	//
	LineItemError_ReasonALL_ROADBLOCK_NOT_ALLOWED LineItemError_Reason = "ALL_ROADBLOCK_NOT_ALLOWED"

	//
	// Companion delivery to display all creatives is not allowed.
	//
	LineItemError_ReasonALL_COMPANION_DELIVERY_NOT_ALLOWED LineItemError_Reason = "ALL_COMPANION_DELIVERY_NOT_ALLOWED"

	//
	// Roadblocking to display all master and companion creative set is not allowed.
	//
	LineItemError_ReasonCREATIVE_SET_ROADBLOCK_NOT_ALLOWED LineItemError_Reason = "CREATIVE_SET_ROADBLOCK_NOT_ALLOWED"

	//
	// Fractional percentage is not allowed.
	//
	LineItemError_ReasonFRACTIONAL_PERCENTAGE_NOT_ALLOWED LineItemError_Reason = "FRACTIONAL_PERCENTAGE_NOT_ALLOWED"

	//
	// For certain LineItem configurations discounts are not allowed.
	//
	LineItemError_ReasonDISCOUNT_NOT_ALLOWED LineItemError_Reason = "DISCOUNT_NOT_ALLOWED"

	//
	// Updating a canceled line item is not allowed.
	//
	LineItemError_ReasonUPDATE_CANCELED_LINE_ITEM_NOT_ALLOWED LineItemError_Reason = "UPDATE_CANCELED_LINE_ITEM_NOT_ALLOWED"

	//
	// Updating a pending approval line item is not allowed.
	//
	LineItemError_ReasonUPDATE_PENDING_APPROVAL_LINE_ITEM_NOT_ALLOWED LineItemError_Reason = "UPDATE_PENDING_APPROVAL_LINE_ITEM_NOT_ALLOWED"

	//
	// Updating an archived line item is not allowed.
	//
	LineItemError_ReasonUPDATE_ARCHIVED_LINE_ITEM_NOT_ALLOWED LineItemError_Reason = "UPDATE_ARCHIVED_LINE_ITEM_NOT_ALLOWED"

	//
	// Create or update legacy dfp line item type is not allowed.
	//
	LineItemError_ReasonCREATE_OR_UPDATE_LEGACY_DFP_LINE_ITEM_TYPE_NOT_ALLOWED LineItemError_Reason = "CREATE_OR_UPDATE_LEGACY_DFP_LINE_ITEM_TYPE_NOT_ALLOWED"

	//
	// Copying line item from different company (advertiser)
	// to the same order is not allowed.
	//
	LineItemError_ReasonCOPY_LINE_ITEM_FROM_DIFFERENT_COMPANY_NOT_ALLOWED LineItemError_Reason = "COPY_LINE_ITEM_FROM_DIFFERENT_COMPANY_NOT_ALLOWED"

	//
	// The size is invalid for the specified platform.
	//
	LineItemError_ReasonINVALID_SIZE_FOR_PLATFORM LineItemError_Reason = "INVALID_SIZE_FOR_PLATFORM"

	//
	// The line item type is invalid for the specified platform.
	//
	LineItemError_ReasonINVALID_LINE_ITEM_TYPE_FOR_PLATFORM LineItemError_Reason = "INVALID_LINE_ITEM_TYPE_FOR_PLATFORM"

	//
	// The web property cannot be served on the specified platform.
	//
	LineItemError_ReasonINVALID_WEB_PROPERTY_FOR_PLATFORM LineItemError_Reason = "INVALID_WEB_PROPERTY_FOR_PLATFORM"

	//
	// The web property cannot be served on the specified environment.
	//
	LineItemError_ReasonINVALID_WEB_PROPERTY_FOR_ENVIRONMENT LineItemError_Reason = "INVALID_WEB_PROPERTY_FOR_ENVIRONMENT"

	//
	// AFMA backfill not supported.
	//
	LineItemError_ReasonAFMA_BACKFILL_NOT_ALLOWED LineItemError_Reason = "AFMA_BACKFILL_NOT_ALLOWED"

	//
	// Environment type cannot change once saved.
	//
	LineItemError_ReasonUPDATE_ENVIRONMENT_TYPE_NOT_ALLOWED LineItemError_Reason = "UPDATE_ENVIRONMENT_TYPE_NOT_ALLOWED"

	//
	// The placeholders are invalid because they contain companions,
	// but the line item does not support companions.
	//
	LineItemError_ReasonCOMPANIONS_NOT_ALLOWED LineItemError_Reason = "COMPANIONS_NOT_ALLOWED"

	//
	// The placeholders are invalid because some of them are roadblocks,
	// and some are not.  Either all roadblock placeholders must contain
	// companions, or no placeholders may contain companions.  This does
	// not apply to video creative sets.
	//
	LineItemError_ReasonROADBLOCKS_WITH_NONROADBLOCKS_NOT_ALLOWED LineItemError_Reason = "ROADBLOCKS_WITH_NONROADBLOCKS_NOT_ALLOWED"

	//
	// A line item cannot be updated from having
	// {@link RoadblockingType#CREATIVE_SET} to having a different
	// RoadblockingType, or vice versa.
	//
	LineItemError_ReasonCANNOT_UPDATE_TO_OR_FROM_CREATIVE_SET_ROADBLOCK LineItemError_Reason = "CANNOT_UPDATE_TO_OR_FROM_CREATIVE_SET_ROADBLOCK"

	//
	// Can not change from a backfill line item type once creatives have been
	// assigned.
	//
	LineItemError_ReasonUPDATE_FROM_BACKFILL_LINE_ITEM_TYPE_NOT_ALLOWED LineItemError_Reason = "UPDATE_FROM_BACKFILL_LINE_ITEM_TYPE_NOT_ALLOWED"

	//
	// Can not change to a backfill line item type once creatives have been
	// assigned.
	//
	LineItemError_ReasonUPDATE_TO_BACKFILL_LINE_ITEM_TYPE_NOT_ALLOWED LineItemError_Reason = "UPDATE_TO_BACKFILL_LINE_ITEM_TYPE_NOT_ALLOWED"

	//
	// Can not change to backfill web property once creatives have been
	// assigned.
	//
	LineItemError_ReasonUPDATE_BACKFILL_WEB_PROPERTY_NOT_ALLOWED LineItemError_Reason = "UPDATE_BACKFILL_WEB_PROPERTY_NOT_ALLOWED"

	//
	// The companion delivery option is not valid for your environment type.
	//
	LineItemError_ReasonINVALID_COMPANION_DELIVERY_OPTION_FOR_ENVIRONMENT_TYPE LineItemError_Reason = "INVALID_COMPANION_DELIVERY_OPTION_FOR_ENVIRONMENT_TYPE"

	//
	// Companion backfill is enabled but environment type not video.
	//
	LineItemError_ReasonCOMPANION_BACKFILL_REQUIRES_VIDEO LineItemError_Reason = "COMPANION_BACKFILL_REQUIRES_VIDEO"

	//
	// Companion delivery options require Ad Manager 360 networks.
	//
	LineItemError_ReasonCOMPANION_DELIVERY_OPTION_REQUIRE_PREMIUM LineItemError_Reason = "COMPANION_DELIVERY_OPTION_REQUIRE_PREMIUM"

	//
	// The master size of placeholders have duplicates.
	//
	LineItemError_ReasonDUPLICATE_MASTER_SIZES LineItemError_Reason = "DUPLICATE_MASTER_SIZES"

	//
	// The line item priority is invalid if for dynamic allocation line items
	// it is different than the default for free publishers.  When allowed,
	// Ad Manager 360 users can change the priority to any value.
	//
	LineItemError_ReasonINVALID_PRIORITY_FOR_LINE_ITEM_TYPE LineItemError_Reason = "INVALID_PRIORITY_FOR_LINE_ITEM_TYPE"

	//
	// The environment type is not valid.
	//
	LineItemError_ReasonINVALID_ENVIRONMENT_TYPE LineItemError_Reason = "INVALID_ENVIRONMENT_TYPE"

	//
	// The environment type is not valid for the target platform.
	//
	LineItemError_ReasonINVALID_ENVIRONMENT_TYPE_FOR_PLATFORM LineItemError_Reason = "INVALID_ENVIRONMENT_TYPE_FOR_PLATFORM"

	//
	// Only {@link LineItemType#STANDARD} line items can be auto extended.
	//
	LineItemError_ReasonINVALID_TYPE_FOR_AUTO_EXTENSION LineItemError_Reason = "INVALID_TYPE_FOR_AUTO_EXTENSION"

	//
	// Video line items cannot change the roadblocking type.
	//
	LineItemError_ReasonVIDEO_INVALID_ROADBLOCKING LineItemError_Reason = "VIDEO_INVALID_ROADBLOCKING"

	//
	// The backfill feature is not enabled according to your features.
	//
	LineItemError_ReasonBACKFILL_TYPE_NOT_ALLOWED LineItemError_Reason = "BACKFILL_TYPE_NOT_ALLOWED"

	//
	// The web property is invalid. A line item must have an appropriate web property selected.
	//
	LineItemError_ReasonINVALID_BACKFILL_LINK_TYPE LineItemError_Reason = "INVALID_BACKFILL_LINK_TYPE"

	//
	// All line items in a programmatic order must have web property codes from the same account.
	//
	LineItemError_ReasonDIFFERENT_BACKFILL_ACCOUNT LineItemError_Reason = "DIFFERENT_BACKFILL_ACCOUNT"

	//
	// Companion delivery options are not allowed with dynamic allocation line
	// items.
	//
	LineItemError_ReasonCOMPANION_DELIVERY_OPTIONS_NOT_ALLOWED_WITH_BACKFILL LineItemError_Reason = "COMPANION_DELIVERY_OPTIONS_NOT_ALLOWED_WITH_BACKFILL"

	//
	// Dynamic allocation using the AdExchange should always use an AFC web
	// property.
	//
	LineItemError_ReasonINVALID_WEB_PROPERTY_FOR_ADX_BACKFILL LineItemError_Reason = "INVALID_WEB_PROPERTY_FOR_ADX_BACKFILL"

	//
	// CPM for backfill inventory must be 0.
	//
	LineItemError_ReasonINVALID_COST_PER_UNIT_FOR_BACKFILL LineItemError_Reason = "INVALID_COST_PER_UNIT_FOR_BACKFILL"

	//
	// Aspect ratio sizes cannot be used with video line items.
	//
	LineItemError_ReasonINVALID_SIZE_FOR_ENVIRONMENT LineItemError_Reason = "INVALID_SIZE_FOR_ENVIRONMENT"

	//
	// The specified target platform is not allowed.
	//
	LineItemError_ReasonTARGET_PLATOFRM_NOT_ALLOWED LineItemError_Reason = "TARGET_PLATOFRM_NOT_ALLOWED"

	//
	// Currency on a line item must be one of the specified network currencies.
	//
	LineItemError_ReasonINVALID_LINE_ITEM_CURRENCY LineItemError_Reason = "INVALID_LINE_ITEM_CURRENCY"

	//
	// All money fields on a line item must specify the same currency.
	//
	LineItemError_ReasonLINE_ITEM_CANNOT_HAVE_MULTIPLE_CURRENCIES LineItemError_Reason = "LINE_ITEM_CANNOT_HAVE_MULTIPLE_CURRENCIES"

	//
	// Once a line item has moved into a a delivering state the currency cannot be changed.
	//
	LineItemError_ReasonCANNOT_CHANGE_CURRENCY LineItemError_Reason = "CANNOT_CHANGE_CURRENCY"

	//
	// A DateTime associated with the line item is not valid.
	//
	LineItemError_ReasonINVALID_LINE_ITEM_DATE_TIME LineItemError_Reason = "INVALID_LINE_ITEM_DATE_TIME"

	//
	// CPA {@link LineItem line items} must specify a zero cost for the
	// {@link LineItem#costPerUnit}.
	//
	LineItemError_ReasonINVALID_COST_PER_UNIT_FOR_CPA LineItemError_Reason = "INVALID_COST_PER_UNIT_FOR_CPA"

	//
	// Once a {@link LineItem} is activated its {@link LineItem#costPerUnit} cannot be updated
	// to/from CPA.
	//
	LineItemError_ReasonUPDATE_CPA_COST_TYPE_NOT_ALLOWED LineItemError_Reason = "UPDATE_CPA_COST_TYPE_NOT_ALLOWED"

	//
	// Once a {@link LineItem} is activated its {@link LineItem#costPerUnit} cannot be updated
	// to/from Viewable CPM.
	//
	LineItemError_ReasonUPDATE_VCPM_COST_TYPE_NOT_ALLOWED LineItemError_Reason = "UPDATE_VCPM_COST_TYPE_NOT_ALLOWED"

	//
	// A {@link LineItem} with master/companion creative placeholders cannot have Viewable CPM
	// as its {@link LineItem#costPerUnit}.
	//
	LineItemError_ReasonMASTER_COMPANION_LINE_ITEM_CANNOT_HAVE_VCPM_COST_TYPE LineItemError_Reason = "MASTER_COMPANION_LINE_ITEM_CANNOT_HAVE_VCPM_COST_TYPE"

	//
	// There cannot be goals with duplicated unit type among the secondary goals for a
	// {@link LineItem line items}.
	//
	LineItemError_ReasonDUPLICATED_UNIT_TYPE LineItemError_Reason = "DUPLICATED_UNIT_TYPE"

	//
	// The secondary goals of a {@link LineItem line items} must have the same goal type.
	//
	LineItemError_ReasonMULTIPLE_GOAL_TYPE_NOT_ALLOWED LineItemError_Reason = "MULTIPLE_GOAL_TYPE_NOT_ALLOWED"

	//
	// For a CPA {@link LineItem line item}, the possible combinations for secondary goals must
	// be either click-through conversion only, click-through conversion with view-through
	// conversion or total conversion only. For a Viewable CPM {@link LineItem line item} or a
	// CPM based Sponsorship {@link LineItem line item}, its secondary goal has to be
	// impression-based.
	//
	LineItemError_ReasonINVALID_UNIT_TYPE_COMBINATION_FOR_SECONDARY_GOALS LineItemError_Reason = "INVALID_UNIT_TYPE_COMBINATION_FOR_SECONDARY_GOALS"

	//
	// One or more of the targeting names specified by a creative placeholder or line item
	// creative association were not found on the line item.
	//
	LineItemError_ReasonINVALID_CREATIVE_TARGETING_NAME LineItemError_Reason = "INVALID_CREATIVE_TARGETING_NAME"

	//
	// Creative targeting expressions on the line item can only have custom criteria targeting
	// with {@link CustomTargetingValue.MatchType#EXACT}.
	//
	LineItemError_ReasonINVALID_CREATIVE_CUSTOM_TARGETING_MATCH_TYPE LineItemError_Reason = "INVALID_CREATIVE_CUSTOM_TARGETING_MATCH_TYPE"

	//
	// Line item with creative targeting expressions cannot have creative rotation type set to
	// {@link CreativeRotationType#SEQUENTIAL}.
	//
	LineItemError_ReasonINVALID_CREATIVE_ROTATION_TYPE_WITH_CREATIVE_TARGETING LineItemError_Reason = "INVALID_CREATIVE_ROTATION_TYPE_WITH_CREATIVE_TARGETING"

	//
	// Line items cannot overbook inventory when applying creative-level targeting if the
	// originating proposal line item did not overbook inventory. Remove creative-level targeting
	// and try again.
	//
	LineItemError_ReasonCANNOT_OVERBOOK_WITH_CREATIVE_TARGETING LineItemError_Reason = "CANNOT_OVERBOOK_WITH_CREATIVE_TARGETING"

	//
	// For a managed line item, inventory sizes must match sizes that are set on the originating
	// proposal line item. In the case that a size is broken out by creative-level targeting,
	// the sum of the creative counts for each size must equal the expected creative count that
	// is set for that size on the originating proposal line item.
	//
	LineItemError_ReasonPLACEHOLDERS_DO_NOT_MATCH_PROPOSAL LineItemError_Reason = "PLACEHOLDERS_DO_NOT_MATCH_PROPOSAL"

	//
	// The line item type is not supported for this API version.
	//
	LineItemError_ReasonUNSUPPORTED_LINE_ITEM_TYPE_FOR_THIS_API_VERSION LineItemError_Reason = "UNSUPPORTED_LINE_ITEM_TYPE_FOR_THIS_API_VERSION"

	//
	// Placeholders can only have native creative templates.
	//
	LineItemError_ReasonNATIVE_CREATIVE_TEMPLATE_REQUIRED LineItemError_Reason = "NATIVE_CREATIVE_TEMPLATE_REQUIRED"

	//
	// Non-native placeholders cannot have creative templates.
	//
	LineItemError_ReasonCANNOT_HAVE_CREATIVE_TEMPLATE LineItemError_Reason = "CANNOT_HAVE_CREATIVE_TEMPLATE"

	//
	// Cannot include native creative templates in the placeholders for Ad Exchange line items.
	//
	LineItemError_ReasonCANNOT_INCLUDE_NATIVE_CREATIVE_TEMPLATE LineItemError_Reason = "CANNOT_INCLUDE_NATIVE_CREATIVE_TEMPLATE"

	//
	// Cannot include native placeholders without native creative templates for direct-sold line
	// items.
	//
	LineItemError_ReasonCANNOT_INCLUDE_NATIVE_PLACEHOLDER_WITHOUT_TEMPLATE_ID LineItemError_Reason = "CANNOT_INCLUDE_NATIVE_PLACEHOLDER_WITHOUT_TEMPLATE_ID"

	//
	// For forecasting only, error when line item has duration, but no creative sizes specified.
	//
	LineItemError_ReasonNO_SIZE_WITH_DURATION LineItemError_Reason = "NO_SIZE_WITH_DURATION"

	//
	// Used when the company pointed to by the viewabilityProviderCompanyId is not of type
	// VIEWABILITY_PROVIDER.
	//
	LineItemError_ReasonINVALID_VIEWABILITY_PROVIDER_COMPANY LineItemError_Reason = "INVALID_VIEWABILITY_PROVIDER_COMPANY"

	//
	// An error occurred while accessing the custom pacing curve Google Cloud Storage bucket.
	//
	LineItemError_ReasonCANNOT_ACCESS_CUSTOM_PACING_CURVE_CLOUD_STORAGE_BUCKET LineItemError_Reason = "CANNOT_ACCESS_CUSTOM_PACING_CURVE_CLOUD_STORAGE_BUCKET"

	//
	// CMS Metadata targeting is only supported for video line items.
	//
	LineItemError_ReasonCMS_METADATA_LINE_ITEM_ENVIRONMENT_TYPE_NOT_SUPPORTED LineItemError_Reason = "CMS_METADATA_LINE_ITEM_ENVIRONMENT_TYPE_NOT_SUPPORTED"

	//
	// The {@code SkippableAdType} is not allowed.
	//
	LineItemError_ReasonSKIPPABLE_AD_TYPE_NOT_ALLOWED LineItemError_Reason = "SKIPPABLE_AD_TYPE_NOT_ALLOWED"

	//
	// Custom pacing curve start time must match the line item's start time.
	//
	LineItemError_ReasonCUSTOM_PACING_CURVE_START_TIME_MUST_MATCH_LINE_ITEM_START_TIME LineItemError_Reason = "CUSTOM_PACING_CURVE_START_TIME_MUST_MATCH_LINE_ITEM_START_TIME"

	//
	// Custom pacing curve goal start time must be before line item end time.
	//
	LineItemError_ReasonCUSTOM_PACING_CURVE_START_TIME_PAST_LINE_ITEM_END_TIME LineItemError_Reason = "CUSTOM_PACING_CURVE_START_TIME_PAST_LINE_ITEM_END_TIME"

	//
	// The line item type is invalid for the specified delivery forecast source.
	//
	LineItemError_ReasonINVALID_LINE_ITEM_TYPE_FOR_DELIVERY_FORECAST_SOURCE LineItemError_Reason = "INVALID_LINE_ITEM_TYPE_FOR_DELIVERY_FORECAST_SOURCE"

	//
	// The sum of the custom pacing goal amounts is invalid.
	//
	LineItemError_ReasonINVALID_TOTAL_CUSTOM_PACING_GOAL_AMOUNTS LineItemError_Reason = "INVALID_TOTAL_CUSTOM_PACING_GOAL_AMOUNTS"

	//
	// Copying line items with custom pacing curves that are totally in the past is not allowed.
	//
	LineItemError_ReasonCOPY_LINE_ITEM_WITH_CUSTOM_PACING_CURVE_FULLY_IN_PAST_NOT_ALLOWED LineItemError_Reason = "COPY_LINE_ITEM_WITH_CUSTOM_PACING_CURVE_FULLY_IN_PAST_NOT_ALLOWED"

	//
	// The last custom pacing goal cannot be zero.
	//
	LineItemError_ReasonLAST_CUSTOM_PACING_GOAL_AMOUNT_CANNOT_BE_ZERO LineItemError_Reason = "LAST_CUSTOM_PACING_GOAL_AMOUNT_CANNOT_BE_ZERO"

	//
	// GRP paced line items cannot have absolute custom pacing curve goals.
	//
	LineItemError_ReasonGRP_PACED_LINE_ITEM_CANNOT_HAVE_ABSOLUTE_CUSTOM_PACING_CURVE_GOALS LineItemError_Reason = "GRP_PACED_LINE_ITEM_CANNOT_HAVE_ABSOLUTE_CUSTOM_PACING_CURVE_GOALS"

	//
	// {@link LineItem line item} has invalid video creative duration.
	//
	LineItemError_ReasonINVALID_MAX_VIDEO_CREATIVE_DURATION LineItemError_Reason = "INVALID_MAX_VIDEO_CREATIVE_DURATION"

	//
	// Native size types must by 1x1.
	//
	LineItemError_ReasonINVALID_NATIVE_SIZE LineItemError_Reason = "INVALID_NATIVE_SIZE"

	//
	// For AdExchange Line Items, the targeted request platform must match the syndication type of
	// the web property code.
	//
	LineItemError_ReasonINVALID_TARGETED_REQUEST_PLATFORM_FOR_WEB_PROPERTY_CODE LineItemError_Reason = "INVALID_TARGETED_REQUEST_PLATFORM_FOR_WEB_PROPERTY_CODE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LineItemError_ReasonUNKNOWN LineItemError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type LineItemFlightDateError_Reason string

const (
	LineItemFlightDateError_ReasonSTART_DATE_TIME_IS_IN_PAST LineItemFlightDateError_Reason = "START_DATE_TIME_IS_IN_PAST"

	LineItemFlightDateError_ReasonEND_DATE_TIME_IS_IN_PAST LineItemFlightDateError_Reason = "END_DATE_TIME_IS_IN_PAST"

	LineItemFlightDateError_ReasonEND_DATE_TIME_NOT_AFTER_START_TIME LineItemFlightDateError_Reason = "END_DATE_TIME_NOT_AFTER_START_TIME"

	LineItemFlightDateError_ReasonEND_DATE_TIME_TOO_LATE LineItemFlightDateError_Reason = "END_DATE_TIME_TOO_LATE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LineItemFlightDateError_ReasonUNKNOWN LineItemFlightDateError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type LineItemOperationError_Reason string

const (

	//
	// The operation is not allowed due to lack of permissions.
	//
	LineItemOperationError_ReasonNOT_ALLOWED LineItemOperationError_Reason = "NOT_ALLOWED"

	//
	// The operation is not applicable for the current state of the
	// {@link LineItem}.
	//
	LineItemOperationError_ReasonNOT_APPLICABLE LineItemOperationError_Reason = "NOT_APPLICABLE"

	//
	// The {@link LineItem} is completed. A {@link LineItemAction} cannot
	// be applied to a line item that is completed.
	//
	LineItemOperationError_ReasonHAS_COMPLETED LineItemOperationError_Reason = "HAS_COMPLETED"

	//
	// The {@link LineItem} has no active creatives. A line item cannot be
	// activated with no active creatives.
	//
	LineItemOperationError_ReasonHAS_NO_ACTIVE_CREATIVES LineItemOperationError_Reason = "HAS_NO_ACTIVE_CREATIVES"

	//
	// A {@link LineItem} of type {@link LineItemType#LEGACY_DFP} cannot be
	// Activated.
	//
	LineItemOperationError_ReasonCANNOT_ACTIVATE_LEGACY_DFP_LINE_ITEM LineItemOperationError_Reason = "CANNOT_ACTIVATE_LEGACY_DFP_LINE_ITEM"

	//
	// A {@link LineItem} with publisher creative source cannot be activated if the corresponding
	// deal is not yet configured by the buyer.
	//
	LineItemOperationError_ReasonCANNOT_ACTIVATE_UNCONFIGURED_LINE_ITEM LineItemOperationError_Reason = "CANNOT_ACTIVATE_UNCONFIGURED_LINE_ITEM"

	//
	// Deleting an {@link LineItem} that has delivered is not allowed
	//
	LineItemOperationError_ReasonCANNOT_DELETE_DELIVERED_LINE_ITEM LineItemOperationError_Reason = "CANNOT_DELETE_DELIVERED_LINE_ITEM"

	//
	// Reservation cannot be made for line item because the
	// {@link LineItem#advertiserId} it is associated with has
	// {@link Company#creditStatus} that is not {@code ACTIVE}
	// or {@code ON_HOLD}.
	//
	LineItemOperationError_ReasonCANNOT_RESERVE_COMPANY_CREDIT_STATUS_NOT_ACTIVE LineItemOperationError_Reason = "CANNOT_RESERVE_COMPANY_CREDIT_STATUS_NOT_ACTIVE"

	//
	// Cannot activate line item  because the {@link LineItem#advertiserId}
	// it is associated with has {@link Company#creditStatus} that is not
	// {@code ACTIVE}, {@code INACTIVE}, or {@code ON_HOLD}.
	//
	LineItemOperationError_ReasonCANNOT_ACTIVATE_INVALID_COMPANY_CREDIT_STATUS LineItemOperationError_Reason = "CANNOT_ACTIVATE_INVALID_COMPANY_CREDIT_STATUS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LineItemOperationError_ReasonUNKNOWN LineItemOperationError_Reason = "UNKNOWN"
)

//
// {@code LineItemType} indicates the priority of a {@link LineItem}, determined
// by the way in which impressions are reserved to be served for it.
//

type LineItemType string

const (

	//
	// The type of {@link LineItem} for which a percentage of all the impressions that are being sold
	// are reserved.
	//
	LineItemTypeSPONSORSHIP LineItemType = "SPONSORSHIP"

	//
	// The type of {@link LineItem} for which a fixed quantity of impressions or clicks are reserved.
	//
	LineItemTypeSTANDARD LineItemType = "STANDARD"

	//
	// The type of {@link LineItem} most commonly used to fill a site's unsold
	// inventory if not contractually obligated to deliver a requested number of
	// impressions. Users specify the daily percentage of unsold impressions or
	// clicks when creating this line item.
	//
	LineItemTypeNETWORK LineItemType = "NETWORK"

	//
	// The type of {@link LineItem} for which a fixed quantity of impressions or
	// clicks will be delivered at a priority lower than the
	// {@link LineItemType#STANDARD} type.
	//
	LineItemTypeBULK LineItemType = "BULK"

	//
	// The type of {@link LineItem} most commonly used to fill a site's unsold
	// inventory if not contractually obligated to deliver a requested number of
	// impressions. Users specify the fixed quantity of unsold impressions or
	// clicks when creating this line item.
	//
	LineItemTypePRICE_PRIORITY LineItemType = "PRICE_PRIORITY"

	//
	// The type of {@link LineItem} typically used for ads that promote products
	// and services chosen by the publisher. These usually do not generate revenue
	// and have the lowest delivery priority.
	//
	LineItemTypeHOUSE LineItemType = "HOUSE"

	//
	// Represents a legacy {@link LineItem} that has been migrated from the DFP
	// system. Such line items cannot be created any more. Also, these line items
	// cannot be activated or resumed.
	//
	LineItemTypeLEGACY_DFP LineItemType = "LEGACY_DFP"

	//
	// The type of {@link LineItem} used for ads that track ads being served
	// externally of Ad Manager, for example an email newsletter. The click through would
	// reference this ad, and the click would be tracked via this ad.
	//
	LineItemTypeCLICK_TRACKING LineItemType = "CLICK_TRACKING"

	//
	// A {@link LineItem} using dynamic allocation backed by AdSense.
	//
	LineItemTypeADSENSE LineItemType = "ADSENSE"

	//
	// A {@link LineItem} using dynamic allocation backed by the Google Ad Exchange.
	//
	LineItemTypeAD_EXCHANGE LineItemType = "AD_EXCHANGE"

	//
	// Represents a non-monetizable video {@link LineItem} that targets one or
	// more bumper positions, which are short house video messages used by
	// publishers to separate content from ad breaks.
	//
	LineItemTypeBUMPER LineItemType = "BUMPER"

	//
	// A {@link LineItem} using dynamic allocation backed by AdMob.
	//
	LineItemTypeADMOB LineItemType = "ADMOB"

	//
	// The type of {@link LineItem} for which there are no impressions reserved, and will serve for a
	// second price bid. All {@link LineItem}s of type {@link LineItemType#PREFERRED_DEAL} should
	// be created via a {@link ProposalLineItem} with a matching  type. When creating a
	// {@link LineItem} of type {@link LineItemType#PREFERRED_DEAL}, the
	// {@link ProposalLineItem#estimatedMinimumImpressions} field is required.
	//
	LineItemTypePREFERRED_DEAL LineItemType = "PREFERRED_DEAL"

	//
	// The value returned if the actual value is not exposed by the requested API
	// version.
	//
	LineItemTypeUNKNOWN LineItemType = "UNKNOWN"
)

//
// Minutes in an hour. Currently, only 0, 15, 30, and 45 are supported. This
// field is required.
//

type MinuteOfHour string

const (

	//
	// Zero minutes past hour.
	//
	MinuteOfHourZERO MinuteOfHour = "ZERO"

	//
	// Fifteen minutes past hour.
	//
	MinuteOfHourFIFTEEN MinuteOfHour = "FIFTEEN"

	//
	// Thirty minutes past hour.
	//
	MinuteOfHourTHIRTY MinuteOfHour = "THIRTY"

	//
	// Forty-five minutes past hour.
	//
	MinuteOfHourFORTY_FIVE MinuteOfHour = "FORTY_FIVE"
)

//
// {@link ApiErrorReason} enum for user domain targeting error.
//

type MobileApplicationTargetingError_Reason string

const (

	//
	// Only applications that are linked to a store entry may be targeted.
	//
	MobileApplicationTargetingError_ReasonCANNOT_TARGET_UNLINKED_APPLICATION MobileApplicationTargetingError_Reason = "CANNOT_TARGET_UNLINKED_APPLICATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	MobileApplicationTargetingError_ReasonUNKNOWN MobileApplicationTargetingError_Reason = "UNKNOWN"
)

//
// The role (buyer or seller) that performed an action in the negotiation of a {@code Proposal}.
//

type NegotiationRole string

const (
	NegotiationRoleBUYER NegotiationRole = "BUYER"

	NegotiationRoleSELLER NegotiationRole = "SELLER"

	NegotiationRoleUNKNOWN NegotiationRole = "UNKNOWN"
)

//
// Represents the pacing computation method for impressions on connected devices for a Nielsen
// measured line item. This only applies when Nielsen measurement is enabled for connected devices.
//

type NielsenCtvPacingType string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NielsenCtvPacingTypeUNKNOWN NielsenCtvPacingType = "UNKNOWN"

	//
	// The value returned if Nielsen measurement is disabled for connected devices.
	//
	NielsenCtvPacingTypeNONE NielsenCtvPacingType = "NONE"

	//
	// Indicates that Nielsen impressions on connected devices are included, and we apply coviewing in
	// pacing.
	//
	NielsenCtvPacingTypeCOVIEW NielsenCtvPacingType = "COVIEW"

	//
	// Indicates that Nielsen impressions on connected devices are included, and we apply strict
	// coviewing in pacing.
	//
	NielsenCtvPacingTypeSTRICT_COVIEW NielsenCtvPacingType = "STRICT_COVIEW"
)

//
// The reasons for the target error.
//

type NotNullError_Reason string

const (

	//
	// Assuming that a method will not have more than 3 arguments, if it does,
	// return NULL
	//
	NotNullError_ReasonARG1_NULL NotNullError_Reason = "ARG1_NULL"

	NotNullError_ReasonARG2_NULL NotNullError_Reason = "ARG2_NULL"

	NotNullError_ReasonARG3_NULL NotNullError_Reason = "ARG3_NULL"

	NotNullError_ReasonNULL NotNullError_Reason = "NULL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NotNullError_ReasonUNKNOWN NotNullError_Reason = "UNKNOWN"
)

//
// Represents whose device categorization to use on Nielsen measured line item with auto-pacing
// enabled.
//

type PacingDeviceCategorizationType string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PacingDeviceCategorizationTypeUNKNOWN PacingDeviceCategorizationType = "UNKNOWN"

	//
	// Use Google's device categorization in auto-pacing.
	//
	PacingDeviceCategorizationTypeGOOGLE PacingDeviceCategorizationType = "GOOGLE"

	//
	// Use Nielsen device categorization in auto-pacing
	//
	PacingDeviceCategorizationTypeNIELSEN PacingDeviceCategorizationType = "NIELSEN"
)

//
// The reasons for the target error.
//

type ParseError_Reason string

const (

	//
	// Indicates an error in parsing an attribute.
	//
	ParseError_ReasonUNPARSABLE ParseError_Reason = "UNPARSABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ParseError_ReasonUNKNOWN ParseError_Reason = "UNKNOWN"
)

//
// Describes reasons for permission errors.
//

type PermissionError_Reason string

const (

	//
	// User does not have the required permission for the request.
	//
	PermissionError_ReasonPERMISSION_DENIED PermissionError_Reason = "PERMISSION_DENIED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PermissionError_ReasonUNKNOWN PermissionError_Reason = "UNKNOWN"
)

//
// Describes reasons for precision errors.
//

type PrecisionError_Reason string

const (

	//
	// The lowest N digits of the number must be zero.
	//
	PrecisionError_ReasonWRONG_PRECISION PrecisionError_Reason = "WRONG_PRECISION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PrecisionError_ReasonUNKNOWN PrecisionError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PreferredDealError_Reason string

const (
	PreferredDealError_ReasonINVALID_PRIORITY PreferredDealError_Reason = "INVALID_PRIORITY"

	//
	// Preferred deal {@link ProposalLineItem proposal line items} only support
	// {@link RateType#CPM}.
	//
	PreferredDealError_ReasonINVALID_RATE_TYPE PreferredDealError_Reason = "INVALID_RATE_TYPE"

	//
	// Preferred deal {@link ProposalLineItem proposal line items} do not support frequency caps.
	//
	PreferredDealError_ReasonINVALID_FREQUENCY_CAPS PreferredDealError_Reason = "INVALID_FREQUENCY_CAPS"

	//
	// Preferred deal {@link ProposalLineItem proposal line items} only support
	// {@link RoadblockingType#ONE_OR_MORE}.
	//
	PreferredDealError_ReasonINVALID_ROADBLOCKING_TYPE PreferredDealError_Reason = "INVALID_ROADBLOCKING_TYPE"

	//
	// Preferred deal {@link ProposalLineItem proposal line items} only support
	// {@link DeliveryRateType#FRONTLOADED}.
	//
	PreferredDealError_ReasonINVALID_DELIVERY_RATE_TYPE PreferredDealError_Reason = "INVALID_DELIVERY_RATE_TYPE"

	PreferredDealError_ReasonUNKNOWN PreferredDealError_Reason = "UNKNOWN"
)

//
// Types of programmatic creative sources.
//

type ProgrammaticCreativeSource string

const (

	//
	// Indicates that the programmatic line item is associated with creatives provided by
	// the publisher.
	//
	ProgrammaticCreativeSourcePUBLISHER ProgrammaticCreativeSource = "PUBLISHER"

	//
	// Indicates that the programmatic line item is associated with creatives provided by
	// the advertiser.
	//
	ProgrammaticCreativeSourceADVERTISER ProgrammaticCreativeSource = "ADVERTISER"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProgrammaticCreativeSourceUNKNOWN ProgrammaticCreativeSource = "UNKNOWN"
)

//
// Possible error reasons for a programmatic error.
//

type ProgrammaticError_Reason string

const (

	//
	// Audience extension is not supported by programmatic line items.
	//
	ProgrammaticError_ReasonAUDIENCE_EXTENSION_NOT_SUPPORTED ProgrammaticError_Reason = "AUDIENCE_EXTENSION_NOT_SUPPORTED"

	//
	// Auto extension days is not supported by programmatic line items.
	//
	ProgrammaticError_ReasonAUTO_EXTENSION_DAYS_NOT_SUPPORTED ProgrammaticError_Reason = "AUTO_EXTENSION_DAYS_NOT_SUPPORTED"

	//
	// Video is currently not supported.
	//
	ProgrammaticError_ReasonVIDEO_NOT_SUPPORTED ProgrammaticError_Reason = "VIDEO_NOT_SUPPORTED"

	//
	// Roadblocking is not supported by programmatic line items.
	//
	ProgrammaticError_ReasonROADBLOCKING_NOT_SUPPORTED ProgrammaticError_Reason = "ROADBLOCKING_NOT_SUPPORTED"

	//
	// Programmatic line items do not support {@link CreativeRotationType#SEQUENTIAL}.
	//
	ProgrammaticError_ReasonINVALID_CREATIVE_ROTATION ProgrammaticError_Reason = "INVALID_CREATIVE_ROTATION"

	//
	// Programmatic line items only support {@link LineItemType#STANDARD} and
	// {@link LineItemType#SPONSORSHIP} if the relevant feature is on.
	//
	ProgrammaticError_ReasonINVALID_LINE_ITEM_TYPE ProgrammaticError_Reason = "INVALID_LINE_ITEM_TYPE"

	//
	// Programmatic line items only support {@link CostType#CPM}.
	//
	ProgrammaticError_ReasonINVALID_COST_TYPE ProgrammaticError_Reason = "INVALID_COST_TYPE"

	//
	// Programmatic line items only support a creative size that is supported by AdX.
	// The list of supported sizes is maintained based on the list published in the help docs:
	// <a href="https://support.google.com/adxseller/answer/1100453">
	// https://support.google.com/adxseller/answer/1100453</a>
	//
	ProgrammaticError_ReasonSIZE_NOT_SUPPORTED ProgrammaticError_Reason = "SIZE_NOT_SUPPORTED"

	//
	// Zero cost per unit is not supported by programmatic line items.
	//
	ProgrammaticError_ReasonZERO_COST_PER_UNIT_NOT_SUPPORTED ProgrammaticError_Reason = "ZERO_COST_PER_UNIT_NOT_SUPPORTED"

	//
	// Some fields cannot be updated on approved line items.
	//
	ProgrammaticError_ReasonCANNOT_UPDATE_FIELD_FOR_APPROVED_LINE_ITEMS ProgrammaticError_Reason = "CANNOT_UPDATE_FIELD_FOR_APPROVED_LINE_ITEMS"

	//
	// Creating a new line item in an approved order is not allowed.
	//
	ProgrammaticError_ReasonCANNOT_CREATE_LINE_ITEM_FOR_APPROVED_ORDER ProgrammaticError_Reason = "CANNOT_CREATE_LINE_ITEM_FOR_APPROVED_ORDER"

	//
	// Cannot change backfill web property for a programmatic line item whose order has been
	// approved.
	//
	ProgrammaticError_ReasonCANNOT_UPDATE_BACKFILL_WEB_PROPERTY_FOR_APPROVED_LINE_ITEMS ProgrammaticError_Reason = "CANNOT_UPDATE_BACKFILL_WEB_PROPERTY_FOR_APPROVED_LINE_ITEMS"

	//
	// Cost per unit is too low. It has to be at least 0.005 USD.
	//
	ProgrammaticError_ReasonCOST_PER_UNIT_TOO_LOW ProgrammaticError_Reason = "COST_PER_UNIT_TOO_LOW"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProgrammaticError_ReasonUNKNOWN ProgrammaticError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ProposalActionError_Reason string

const (

	//
	// The operation is not applicable to the current state.
	//
	ProposalActionError_ReasonNOT_APPLICABLE ProposalActionError_Reason = "NOT_APPLICABLE"

	//
	// The operation cannot be applied because the proposal is archived.
	//
	ProposalActionError_ReasonIS_ARCHIVED ProposalActionError_Reason = "IS_ARCHIVED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalActionError_ReasonUNKNOWN ProposalActionError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ProposalError_Reason string

const (

	//
	// Unknown error from ad-server
	//
	ProposalError_ReasonAD_SERVER_UNKNOWN_ERROR ProposalError_Reason = "AD_SERVER_UNKNOWN_ERROR"

	//
	// Ad-server reports an api error for the operation.
	//
	ProposalError_ReasonAD_SERVER_API_ERROR ProposalError_Reason = "AD_SERVER_API_ERROR"

	//
	// Advertiser cannot be updated once the proposal has been reserved.
	//
	ProposalError_ReasonUPDATE_ADVERTISER_NOT_ALLOWED ProposalError_Reason = "UPDATE_ADVERTISER_NOT_ALLOWED"

	//
	// Proposal cannot be updated when its status is not {@code DRAFT} or it is archived.
	//
	ProposalError_ReasonUPDATE_PROPOSAL_NOT_ALLOWED ProposalError_Reason = "UPDATE_PROPOSAL_NOT_ALLOWED"

	//
	// {@link Contact Contacts} are not supported for {@link Company.Type#ADVERTISER advertisers}
	// in a programmatic {@link Proposal}.
	//
	ProposalError_ReasonCONTACT_UNSUPPORTED_FOR_ADVERTISER ProposalError_Reason = "CONTACT_UNSUPPORTED_FOR_ADVERTISER"

	//
	// Contact associated with a proposal does not belong to the specific company.
	//
	ProposalError_ReasonINVALID_CONTACT ProposalError_Reason = "INVALID_CONTACT"

	//
	// Contact associated with a proposal's advertiser or agency is duplicated.
	//
	ProposalError_ReasonDUPLICATED_CONTACT ProposalError_Reason = "DUPLICATED_CONTACT"

	//
	// A proposal cannot be created or updated because the company
	// it is associated with has {@link Company#creditStatus}
	// that is not {@code ACTIVE} or {@code ON_HOLD}.
	//
	ProposalError_ReasonUNACCEPTABLE_COMPANY_CREDIT_STATUS ProposalError_Reason = "UNACCEPTABLE_COMPANY_CREDIT_STATUS"

	//
	// Advertiser or agency associated with the proposal has {@link Company#creditStatus} that is
	// not {@code ACTIVE}.
	//
	ProposalError_ReasonCOMPANY_CREDIT_STATUS_NOT_ACTIVE ProposalError_Reason = "COMPANY_CREDIT_STATUS_NOT_ACTIVE"

	//
	// Cannot have other agencies without a primary agency.
	//
	ProposalError_ReasonPRIMARY_AGENCY_REQUIRED ProposalError_Reason = "PRIMARY_AGENCY_REQUIRED"

	//
	// Cannot have more than one primary agency.
	//
	ProposalError_ReasonPRIMARY_AGENCY_NOT_UNIQUE ProposalError_Reason = "PRIMARY_AGENCY_NOT_UNIQUE"

	//
	// The {@link Company} association type is not supported for programmatic
	// {@link Proposal proposals}.
	//
	ProposalError_ReasonUNSUPPORTED_COMPANY_ASSOCIATION_TYPE_FOR_PROGRAMMATIC_PROPOSAL ProposalError_Reason = "UNSUPPORTED_COMPANY_ASSOCIATION_TYPE_FOR_PROGRAMMATIC_PROPOSAL"

	//
	// Advertiser or agency associated with a proposal is duplicated.
	//
	ProposalError_ReasonDUPLICATED_COMPANY_ASSOCIATION ProposalError_Reason = "DUPLICATED_COMPANY_ASSOCIATION"

	//
	// Found duplicated primary or secondary sales person.
	//
	ProposalError_ReasonDUPLICATED_SALESPERSON ProposalError_Reason = "DUPLICATED_SALESPERSON"

	//
	// Found duplicated sales planner.
	//
	ProposalError_ReasonDUPLICATED_SALES_PLANNER ProposalError_Reason = "DUPLICATED_SALES_PLANNER"

	//
	// Found duplicated primary or secondary trafficker.
	//
	ProposalError_ReasonDUPLICATED_TRAFFICKER ProposalError_Reason = "DUPLICATED_TRAFFICKER"

	//
	// The proposal has no unarchived proposal line items.
	//
	ProposalError_ReasonHAS_NO_UNARCHIVED_PROPOSAL_LINEITEMS ProposalError_Reason = "HAS_NO_UNARCHIVED_PROPOSAL_LINEITEMS"

	//
	// One or more of the terms and conditions being added already exists on the proposal.
	//
	ProposalError_ReasonDUPLICATE_TERMS_AND_CONDITIONS ProposalError_Reason = "DUPLICATE_TERMS_AND_CONDITIONS"

	//
	// The currency code of the proposal is not supported by the current network. All supported
	// currencies can be found in the union of {@link Network#currencyCode} and
	// {@link Network#secondaryCurrencyCodes}.
	//
	ProposalError_ReasonUNSUPPORTED_PROPOSAL_CURRENCY_CODE ProposalError_Reason = "UNSUPPORTED_PROPOSAL_CURRENCY_CODE"

	//
	// The currency code of the proposal is not supported by the selected buyer.
	//
	ProposalError_ReasonUNSUPPORTED_BUYER_CURRENCY_CODE ProposalError_Reason = "UNSUPPORTED_BUYER_CURRENCY_CODE"

	//
	// The POC value of the proposal is invalid.
	//
	ProposalError_ReasonINVALID_POC ProposalError_Reason = "INVALID_POC"

	//
	// Currency cannot be updated once the proposal has been reserved.
	//
	ProposalError_ReasonUPDATE_CURRENCY_NOT_ALLOWED ProposalError_Reason = "UPDATE_CURRENCY_NOT_ALLOWED"

	//
	// Time zone cannot be updated once the proposal has been sold.
	//
	ProposalError_ReasonUPDATE_TIME_ZONE_NOT_ALLOWED ProposalError_Reason = "UPDATE_TIME_ZONE_NOT_ALLOWED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalError_ReasonUNKNOWN ProposalError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ProposalLineItemActionError_Reason string

const (

	//
	// The operation is not applicable to the current state.
	//
	ProposalLineItemActionError_ReasonNOT_APPLICABLE ProposalLineItemActionError_Reason = "NOT_APPLICABLE"

	//
	// The operation is not applicable because the containing proposal is not editable.
	//
	ProposalLineItemActionError_ReasonPROPOSAL_NOT_EDITABLE ProposalLineItemActionError_Reason = "PROPOSAL_NOT_EDITABLE"

	//
	// The archive operation is not applicable because it would cause some mandatory products
	// to have no unarchived proposal line items in the package.
	//
	ProposalLineItemActionError_ReasonCANNOT_SELECTIVELY_ARCHIVE_PROPOSAL_LINE_ITEMS_FROM_MANDATORY_PRODUCTS ProposalLineItemActionError_Reason = "CANNOT_SELECTIVELY_ARCHIVE_PROPOSAL_LINE_ITEMS_FROM_MANDATORY_PRODUCTS"

	//
	// The unarchive operation is not applicable because it would cause some mandatory products
	// to have no unarchived proposal line items in the package.
	//
	ProposalLineItemActionError_ReasonCANNOT_SELECTIVELY_UNARCHIVE_PROPOSAL_LINE_ITEMS_FROM_MANDATORY_PRODUCTS ProposalLineItemActionError_Reason = "CANNOT_SELECTIVELY_UNARCHIVE_PROPOSAL_LINE_ITEMS_FROM_MANDATORY_PRODUCTS"

	//
	// Sold programmatic {@link ProposalLineItem} cannot be unarchived.
	//
	ProposalLineItemActionError_ReasonCANNOT_UNARCHIVE_SOLD_PROGRAMMATIC_PROPOSAL_LINE_ITEM ProposalLineItemActionError_Reason = "CANNOT_UNARCHIVE_SOLD_PROGRAMMATIC_PROPOSAL_LINE_ITEM"

	//
	// Active {@link ProposalLineItem} cannot be archived
	//
	ProposalLineItemActionError_ReasonCANNOT_ARCHIVE_ONGOING_PROPOSAL_LINE_ITEM ProposalLineItemActionError_Reason = "CANNOT_ARCHIVE_ONGOING_PROPOSAL_LINE_ITEM"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalLineItemActionError_ReasonUNKNOWN ProposalLineItemActionError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ProposalLineItemError_Reason string

const (

	//
	// The proposal line item's rate card is not the same as other proposal line items
	// in the proposal.
	//
	ProposalLineItemError_ReasonNOT_SAME_RATE_CARD ProposalLineItemError_Reason = "NOT_SAME_RATE_CARD"

	//
	// The proposal line item's type is not yet supported by Sales Manager.
	//
	ProposalLineItemError_ReasonLINE_ITEM_TYPE_NOT_ALLOWED ProposalLineItemError_Reason = "LINE_ITEM_TYPE_NOT_ALLOWED"

	//
	// The proposal line item's end date time is not after its start date time.
	//
	ProposalLineItemError_ReasonEND_DATE_TIME_NOT_AFTER_START_TIME ProposalLineItemError_Reason = "END_DATE_TIME_NOT_AFTER_START_TIME"

	//
	// The proposal line item's start date time is too late in the month. This error applies to
	// Programmatic Guaranteed deals sold on Nielsen audience measurement.
	//
	ProposalLineItemError_ReasonSTART_DATE_TIME_TOO_LATE_IN_MONTH ProposalLineItemError_Reason = "START_DATE_TIME_TOO_LATE_IN_MONTH"

	//
	// The proposal line item's end date time is after 1/1/2037.
	//
	ProposalLineItemError_ReasonEND_DATE_TIME_TOO_LATE ProposalLineItemError_Reason = "END_DATE_TIME_TOO_LATE"

	//
	// The proposal line item's start date time is in past.
	//
	ProposalLineItemError_ReasonSTART_DATE_TIME_IS_IN_PAST ProposalLineItemError_Reason = "START_DATE_TIME_IS_IN_PAST"

	//
	// The proposal line item's end date time is in past.
	//
	ProposalLineItemError_ReasonEND_DATE_TIME_IS_IN_PAST ProposalLineItemError_Reason = "END_DATE_TIME_IS_IN_PAST"

	//
	// Frontloaded delivery rate type is not allowed.
	//
	ProposalLineItemError_ReasonFRONTLOADED_NOT_ALLOWED ProposalLineItemError_Reason = "FRONTLOADED_NOT_ALLOWED"

	//
	// Roadblocking to display all creatives is not allowed.
	//
	ProposalLineItemError_ReasonALL_ROADBLOCK_NOT_ALLOWED ProposalLineItemError_Reason = "ALL_ROADBLOCK_NOT_ALLOWED"

	//
	// Display all companions is not allowed.
	//
	ProposalLineItemError_ReasonALL_COMPANION_DELIVERY_NOT_ALLOWED ProposalLineItemError_Reason = "ALL_COMPANION_DELIVERY_NOT_ALLOWED"

	//
	// Roadblocking to display all master and companion creative set is not allowed.
	//
	ProposalLineItemError_ReasonCREATIVE_SET_ROADBLOCK_NOT_ALLOWED ProposalLineItemError_Reason = "CREATIVE_SET_ROADBLOCK_NOT_ALLOWED"

	//
	// Some changes may not be allowed because the related line item has already started.
	//
	ProposalLineItemError_ReasonALREADY_STARTED ProposalLineItemError_Reason = "ALREADY_STARTED"

	//
	// The setting is conflict with product's restriction.
	//
	ProposalLineItemError_ReasonCONFLICT_WITH_PRODUCT ProposalLineItemError_Reason = "CONFLICT_WITH_PRODUCT"

	//
	// The proposal line item's setting violates the product's built-in targeting
	// compatibility restriction.
	//
	ProposalLineItemError_ReasonVIOLATE_BUILT_IN_TARGETING_COMPATIBILITY_RESTRICTION ProposalLineItemError_Reason = "VIOLATE_BUILT_IN_TARGETING_COMPATIBILITY_RESTRICTION"

	//
	// The proposal line item's setting violates the product's built-in targeting
	// locked restriction.
	//
	ProposalLineItemError_ReasonVIOLATE_BUILT_IN_TARGETING_LOCKED_RESTRICTION ProposalLineItemError_Reason = "VIOLATE_BUILT_IN_TARGETING_LOCKED_RESTRICTION"

	//
	// Cannot target mobile-only targeting criteria.
	//
	ProposalLineItemError_ReasonMOBILE_TECH_CRITERIA_NOT_SUPPORTED ProposalLineItemError_Reason = "MOBILE_TECH_CRITERIA_NOT_SUPPORTED"

	//
	// The targeting criteria type is unsupported.
	//
	ProposalLineItemError_ReasonUNSUPPORTED_TARGETING_TYPE ProposalLineItemError_Reason = "UNSUPPORTED_TARGETING_TYPE"

	//
	// The contracted cost does not match with what calculated from final rate and units bought.
	//
	ProposalLineItemError_ReasonWRONG_COST ProposalLineItemError_Reason = "WRONG_COST"

	//
	// The proposal line item targets an inventory type for which the network does not have a
	// corresponding web property.
	//
	ProposalLineItemError_ReasonNO_WEB_PROPERTY_FOR_TARGETED_REQUEST_PLATFORM ProposalLineItemError_Reason = "NO_WEB_PROPERTY_FOR_TARGETED_REQUEST_PLATFORM"

	//
	// The cost calculated from cost per unit and units is too high.
	//
	ProposalLineItemError_ReasonCALCULATED_COST_TOO_HIGH ProposalLineItemError_Reason = "CALCULATED_COST_TOO_HIGH"

	//
	// The line item priority is invalid if it's different than the default.
	//
	ProposalLineItemError_ReasonINVALID_PRIORITY_FOR_LINE_ITEM_TYPE ProposalLineItemError_Reason = "INVALID_PRIORITY_FOR_LINE_ITEM_TYPE"

	//
	// Propsoal line item cannot update when it is archived.
	//
	ProposalLineItemError_ReasonUPDATE_PROPOSAL_LINE_ITEM_NOT_ALLOWED ProposalLineItemError_Reason = "UPDATE_PROPOSAL_LINE_ITEM_NOT_ALLOWED"

	//
	// A proposal line item cannot be updated from having
	// {@link RoadblockingType#CREATIVE_SET} to having a different
	// RoadblockingType, or vice versa.
	//
	ProposalLineItemError_ReasonCANNOT_UPDATE_TO_OR_FROM_CREATIVE_SET_ROADBLOCK ProposalLineItemError_Reason = "CANNOT_UPDATE_TO_OR_FROM_CREATIVE_SET_ROADBLOCK"

	//
	// Serving creatives exactly in sequential order is not allowed.
	//
	ProposalLineItemError_ReasonSEQUENTIAL_CREATIVE_ROTATION_NOT_ALLOWED ProposalLineItemError_Reason = "SEQUENTIAL_CREATIVE_ROTATION_NOT_ALLOWED"

	//
	// Proposal line item cannot update its reservation detail once start delivering.
	//
	ProposalLineItemError_ReasonUPDATE_RESERVATION_NOT_ALLOWED ProposalLineItemError_Reason = "UPDATE_RESERVATION_NOT_ALLOWED"

	//
	// The companion delivery option is not valid for the roadblocking type.
	//
	ProposalLineItemError_ReasonINVALID_COMPANION_DELIVERY_OPTION_FOR_ROADBLOCKING_TYPE ProposalLineItemError_Reason = "INVALID_COMPANION_DELIVERY_OPTION_FOR_ROADBLOCKING_TYPE"

	//
	// Roadblocking type is inconsistent with creative placeholders. If the roadblocking
	// type is creative set, creative placeholders should contain companions,
	// and vice versa.
	//
	ProposalLineItemError_ReasonINCONSISTENT_ROADBLOCK_TYPE ProposalLineItemError_Reason = "INCONSISTENT_ROADBLOCK_TYPE"

	//
	// ContractedQuantityBuffer is only applicable to standard line item with
	// {@link RateType#CPC}/{@link RateType#CPM}/{@link RateType#VCPM} type.
	//
	ProposalLineItemError_ReasonINVALID_CONTRACTED_QUANTITY_BUFFER ProposalLineItemError_Reason = "INVALID_CONTRACTED_QUANTITY_BUFFER"

	//
	// One or more values on the proposal line item are not valid for a
	// {@link LineItemType#CLICK_TRACKING} line item type.
	//
	ProposalLineItemError_ReasonINVALID_VALUES_FOR_CLICK_TRACKING_LINE_ITEM_TYPE ProposalLineItemError_Reason = "INVALID_VALUES_FOR_CLICK_TRACKING_LINE_ITEM_TYPE"

	//
	// Proposal line item cannot update its cost adjustment after first approval.
	//
	ProposalLineItemError_ReasonUPDATE_COST_ADJUSTMENT_NOT_ALLOWED ProposalLineItemError_Reason = "UPDATE_COST_ADJUSTMENT_NOT_ALLOWED"

	//
	// The currency code of the proposal line item's rate card is not supported by
	// the current network. All supported currencies can be found in the union of
	// {@link Network#currencyCode} and {@link Network#secondaryCurrencyCodes}.
	//
	ProposalLineItemError_ReasonUNSUPPORTED_RATE_CARD_CURRENCY_CODE ProposalLineItemError_Reason = "UNSUPPORTED_RATE_CARD_CURRENCY_CODE"

	//
	// The corresponding line item is paused, but the proposal line item's end date time is before
	// the last paused time.
	//
	ProposalLineItemError_ReasonEND_DATE_TIME_IS_BEFORE_LAST_PAUSED_TIME ProposalLineItemError_Reason = "END_DATE_TIME_IS_BEFORE_LAST_PAUSED_TIME"

	//
	// Video line items cannot have roadblocking options.
	//
	ProposalLineItemError_ReasonVIDEO_INVALID_ROADBLOCKING ProposalLineItemError_Reason = "VIDEO_INVALID_ROADBLOCKING"

	//
	// Time zone cannot be updated once the proposal line item has been sold.
	//
	ProposalLineItemError_ReasonUPDATE_TIME_ZONE_NOT_ALLOWED ProposalLineItemError_Reason = "UPDATE_TIME_ZONE_NOT_ALLOWED"

	//
	// Time zone must be network time zone if the proposal line item is {@link RateType#VCPM}.
	//
	ProposalLineItemError_ReasonINVALID_TIME_ZONE_FOR_RATE_TYPE ProposalLineItemError_Reason = "INVALID_TIME_ZONE_FOR_RATE_TYPE"

	//
	// Only the {@link Network#timeZone} is allowed for programmatic {@link Proposal proposals}.
	//
	ProposalLineItemError_ReasonINVALID_TIME_ZONE_FOR_DEALS ProposalLineItemError_Reason = "INVALID_TIME_ZONE_FOR_DEALS"

	//
	// The {@link ProposalLineItem#environmentType} is invalid.
	//
	ProposalLineItemError_ReasonINVALID_ENVIRONMENT_TYPE ProposalLineItemError_Reason = "INVALID_ENVIRONMENT_TYPE"

	//
	// At least one size must be specified.
	//
	ProposalLineItemError_ReasonSIZE_REQUIRED ProposalLineItemError_Reason = "SIZE_REQUIRED"

	//
	// A placeholder contains companions but the roadblocking type is not
	// {@link RoadblockingType#CREATIVE_SET} or the {@link ProductType product type} is offline.
	//
	ProposalLineItemError_ReasonCOMPANION_NOT_ALLOWED ProposalLineItemError_Reason = "COMPANION_NOT_ALLOWED"

	//
	// A placeholder does not contain companions but the roadblocking type is
	// {@link RoadblockingType#CREATIVE_SET}.
	//
	ProposalLineItemError_ReasonMISSING_COMPANION ProposalLineItemError_Reason = "MISSING_COMPANION"

	//
	// A placeholder's master size is the same as another placeholder's master size.
	//
	ProposalLineItemError_ReasonDUPLICATED_MASTER_SIZE ProposalLineItemError_Reason = "DUPLICATED_MASTER_SIZE"

	//
	// Only creative placeholders with standard {@link CreativePlaceholder#size sizes} can set
	// an expected creative count.
	//
	ProposalLineItemError_ReasonINVALID_EXPECTED_CREATIVE_COUNT ProposalLineItemError_Reason = "INVALID_EXPECTED_CREATIVE_COUNT"

	//
	// Non-native placeholders cannot have creative templates.
	//
	ProposalLineItemError_ReasonCANNOT_HAVE_CREATIVE_TEMPLATE ProposalLineItemError_Reason = "CANNOT_HAVE_CREATIVE_TEMPLATE"

	//
	// Placeholders can only have native creative templates.
	//
	ProposalLineItemError_ReasonNATIVE_CREATIVE_TEMPLATE_REQUIRED ProposalLineItemError_Reason = "NATIVE_CREATIVE_TEMPLATE_REQUIRED"

	//
	// Cannot include native placeholders without native creative templates.
	//
	ProposalLineItemError_ReasonCANNOT_INCLUDE_NATIVE_PLACEHOLDER_WITHOUT_TEMPLATE_ID ProposalLineItemError_Reason = "CANNOT_INCLUDE_NATIVE_PLACEHOLDER_WITHOUT_TEMPLATE_ID"

	//
	// One or more values are not valid for a {@link LineItemType#CLICK_TRACKING} line item type.
	//
	ProposalLineItemError_ReasonINVALID_CLICK_TRACKING_LINE_ITEM_TYPE ProposalLineItemError_Reason = "INVALID_CLICK_TRACKING_LINE_ITEM_TYPE"

	//
	// The targeting is not valid for a {@link LineItemType#CLICK_TRACKING} line item type.
	//
	ProposalLineItemError_ReasonINVALID_TARGETING_FOR_CLICK_TRACKING ProposalLineItemError_Reason = "INVALID_TARGETING_FOR_CLICK_TRACKING"

	//
	// The contractedUnitsBought of the proposal line item is invalid.
	//
	ProposalLineItemError_ReasonINVALID_CONTRACTED_UNITS_BOUGHT ProposalLineItemError_Reason = "INVALID_CONTRACTED_UNITS_BOUGHT"

	//
	// Only creative placeholders with standard {@link CreativePlaceholder#size sizes} can contain
	// labels.
	//
	ProposalLineItemError_ReasonPLACEHOLDER_CANNOT_CONTAIN_LABELS ProposalLineItemError_Reason = "PLACEHOLDER_CANNOT_CONTAIN_LABELS"

	//
	// One or more labels on a creative placeholder is invalid.
	//
	ProposalLineItemError_ReasonINVALID_LABEL_TYPE_IN_PLACEHOLDER ProposalLineItemError_Reason = "INVALID_LABEL_TYPE_IN_PLACEHOLDER"

	//
	// A placeholder cannot contain a negated label.
	//
	ProposalLineItemError_ReasonPLACEHOLDER_CANNOT_CONTAIN_NEGATED_LABELS ProposalLineItemError_Reason = "PLACEHOLDER_CANNOT_CONTAIN_NEGATED_LABELS"

	//
	// Contracted impressions of programmatic proposal line item must be greater than already
	// delivered impressions.
	//
	ProposalLineItemError_ReasonCONTRACTED_UNITS_LESS_THAN_DELIVERED ProposalLineItemError_Reason = "CONTRACTED_UNITS_LESS_THAN_DELIVERED"

	//
	// If AdExchangeEnvironment is DISPLAY, the proposal line item must have mobile apps as excluded
	// device capability targeting.
	//
	ProposalLineItemError_ReasonDISPLAY_ENVIRONMENT_MUST_HAVE_EXCLUDED_MOBILE_APPS_TARGETING ProposalLineItemError_Reason = "DISPLAY_ENVIRONMENT_MUST_HAVE_EXCLUDED_MOBILE_APPS_TARGETING"

	//
	// If AdExchangeEnvironment is MOBILE, the proposal line item must have mobile apps as included
	// device capability targeting.
	//
	ProposalLineItemError_ReasonMOBILE_ENVIRONMENT_MUST_HAVE_INCLUDED_MOBILE_APPS_TARGETING ProposalLineItemError_Reason = "MOBILE_ENVIRONMENT_MUST_HAVE_INCLUDED_MOBILE_APPS_TARGETING"

	//
	// The {@code SkippableAdType} is not allowed.
	//
	ProposalLineItemError_ReasonSKIPPABLE_AD_TYPE_NOT_ALLOWED ProposalLineItemError_Reason = "SKIPPABLE_AD_TYPE_NOT_ALLOWED"

	//
	// Cross sell targeting is unsupported for this proposal line item.
	//
	ProposalLineItemError_ReasonCROSS_SELL_TARGETING_UNSUPPORTED ProposalLineItemError_Reason = "CROSS_SELL_TARGETING_UNSUPPORTED"

	//
	// Can't set a video duration for non video deals.
	//
	ProposalLineItemError_ReasonCANNOT_SET_VIDEO_DURATION_ON_NON_VIDEO_DEAL ProposalLineItemError_Reason = "CANNOT_SET_VIDEO_DURATION_ON_NON_VIDEO_DEAL"

	//
	// Cannot update video creative skippability on a YouTube-targeted proposal line item once it
	// has been sold (pushed to an order line item).
	//
	ProposalLineItemError_ReasonUPDATE_VIDEO_CREATIVE_SKIPPABILITY_NOT_ALLOWED ProposalLineItemError_Reason = "UPDATE_VIDEO_CREATIVE_SKIPPABILITY_NOT_ALLOWED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalLineItemError_ReasonUNKNOWN ProposalLineItemError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ProposalLineItemMakegoodError_Reason string

const (

	//
	// The original proposal line item for this makegood already has a makegood.
	//
	ProposalLineItemMakegoodError_ReasonORIGINAL_ALREADY_HAS_MAKEGOOD ProposalLineItemMakegoodError_Reason = "ORIGINAL_ALREADY_HAS_MAKEGOOD"

	//
	// The original proposal line item for this makegood is itself a makegood.
	//
	ProposalLineItemMakegoodError_ReasonORIGINAL_IS_MAKEGOOD ProposalLineItemMakegoodError_Reason = "ORIGINAL_IS_MAKEGOOD"

	//
	// The original proposal line item for this makegood has not been sold.
	//
	ProposalLineItemMakegoodError_ReasonORIGINAL_NOT_YET_SOLD ProposalLineItemMakegoodError_Reason = "ORIGINAL_NOT_YET_SOLD"

	//
	// This makegood or its original is not a standard line item.
	//
	ProposalLineItemMakegoodError_ReasonLINE_ITEM_IS_NOT_STANDARD ProposalLineItemMakegoodError_Reason = "LINE_ITEM_IS_NOT_STANDARD"

	//
	// This makegood or its original is not a CPM line item.
	//
	ProposalLineItemMakegoodError_ReasonLINE_ITEM_IS_NOT_CPM ProposalLineItemMakegoodError_Reason = "LINE_ITEM_IS_NOT_CPM"

	//
	// This makegood or its original has a cost type not supported on makegoods.
	//
	ProposalLineItemMakegoodError_ReasonMAKEGOODS_NOT_SUPPORTED_FOR_COST_TYPE ProposalLineItemMakegoodError_Reason = "MAKEGOODS_NOT_SUPPORTED_FOR_COST_TYPE"

	//
	// The original proposal line item for this makegood is too far in the past.
	//
	ProposalLineItemMakegoodError_ReasonORIGINAL_TOO_FAR_IN_PAST ProposalLineItemMakegoodError_Reason = "ORIGINAL_TOO_FAR_IN_PAST"

	//
	// This makegood has a rate that's different from the original proposal line item.
	//
	ProposalLineItemMakegoodError_ReasonRATE_DIFFERENT_THAN_ORIGINAL ProposalLineItemMakegoodError_Reason = "RATE_DIFFERENT_THAN_ORIGINAL"

	//
	// This makegood has an impression goal greater than the original proposal line item.
	//
	ProposalLineItemMakegoodError_ReasonUNITS_MORE_THAN_ORIGINAL ProposalLineItemMakegoodError_Reason = "UNITS_MORE_THAN_ORIGINAL"

	//
	// Makegoods are not supported for non-DV360 buyers.
	//
	ProposalLineItemMakegoodError_ReasonMAKEGOODS_NOT_SUPPORTED_FOR_NON_DV360_BUYERS ProposalLineItemMakegoodError_Reason = "MAKEGOODS_NOT_SUPPORTED_FOR_NON_DV360_BUYERS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalLineItemMakegoodError_ReasonUNKNOWN ProposalLineItemMakegoodError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ProposalLineItemProgrammaticError_Reason string

const (

	//
	// Programmatic {@link ProposalLineItem proposal line items} only support
	// {@link ProductType#DFP}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_PRODUCT_TYPE ProposalLineItemProgrammaticError_Reason = "INVALID_PRODUCT_TYPE"

	//
	// {@link EnvironmentType#VIDEO_PLAYER} is currently not supported.
	//
	ProposalLineItemProgrammaticError_ReasonVIDEO_NOT_SUPPORTED ProposalLineItemProgrammaticError_Reason = "VIDEO_NOT_SUPPORTED"

	//
	// Programmatic {@link ProposalLineItem proposal line items} do not support
	// {@link RoadblockingType#CREATIVE_SET}.
	//
	ProposalLineItemProgrammaticError_ReasonROADBLOCKING_NOT_SUPPORTED ProposalLineItemProgrammaticError_Reason = "ROADBLOCKING_NOT_SUPPORTED"

	//
	// Programmatic {@link ProposalLineItem proposal line items} do not support
	// {@link CreativeRotationType#SEQUENTIAL}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_CREATIVE_ROTATION ProposalLineItemProgrammaticError_Reason = "INVALID_CREATIVE_ROTATION"

	//
	// Programmatic {@link ProposalLineItem proposal line items} only support
	// {@link LineItemType#STANDARD}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_PROPOSAL_LINE_ITEM_TYPE ProposalLineItemProgrammaticError_Reason = "INVALID_PROPOSAL_LINE_ITEM_TYPE"

	//
	// Programmatic {@link ProposalLineItem proposal line items} only support {@link RateType#CPM}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_RATE_TYPE ProposalLineItemProgrammaticError_Reason = "INVALID_RATE_TYPE"

	//
	// Programmatic {@link ProposalLineItem proposal line items} do not support zero for
	// {@link ProposalLineItem#netRate}.
	//
	ProposalLineItemProgrammaticError_ReasonZERO_COST_PER_UNIT_NOT_SUPPORTED ProposalLineItemProgrammaticError_Reason = "ZERO_COST_PER_UNIT_NOT_SUPPORTED"

	//
	// Only programmatic {@link ProposalLineItem proposal line items} support
	// {@link ProgrammaticCreativeSource}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_PROGRAMMATIC_CREATIVE_SOURCE ProposalLineItemProgrammaticError_Reason = "INVALID_PROGRAMMATIC_CREATIVE_SOURCE"

	//
	// Programmatic {@link ProposalLineItem proposal line item} has invalid video creative
	// duration.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_MAX_VIDEO_CREATIVE_DURATION ProposalLineItemProgrammaticError_Reason = "INVALID_MAX_VIDEO_CREATIVE_DURATION"

	//
	// Cannot update programmatic creative source if the {@link ProposalLineItem proposal line item}
	// has been sent to the buyer.
	//
	ProposalLineItemProgrammaticError_ReasonCANNOT_UPDATE_PROGRAMMATIC_CREATIVE_SOURCE ProposalLineItemProgrammaticError_Reason = "CANNOT_UPDATE_PROGRAMMATIC_CREATIVE_SOURCE"

	//
	// The {@link Goal#units} value is invalid.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_NUM_UNITS ProposalLineItemProgrammaticError_Reason = "INVALID_NUM_UNITS"

	//
	// Cannot mix guaranteed and Preferred Deal proposal line items in a programmatic proposal.
	//
	ProposalLineItemProgrammaticError_ReasonMIX_GUARANTEED_AND_PREFERRED_DEAL_NOT_ALLOWED ProposalLineItemProgrammaticError_Reason = "MIX_GUARANTEED_AND_PREFERRED_DEAL_NOT_ALLOWED"

	//
	// Cannot mix native and banner size in a programmatic proposal line item.
	//
	ProposalLineItemProgrammaticError_ReasonMIX_NATIVE_AND_BANNER_SIZE_NOT_ALLOWED ProposalLineItemProgrammaticError_Reason = "MIX_NATIVE_AND_BANNER_SIZE_NOT_ALLOWED"

	//
	// Cannot update sizes when a programmatic proposal line item with publisher creative source is
	// sent to a buyer.
	//
	ProposalLineItemProgrammaticError_ReasonCANNOT_UPDATE_SIZES ProposalLineItemProgrammaticError_Reason = "CANNOT_UPDATE_SIZES"

	//
	// The {ProposalLineItem#contractedUnitsBought} cannot be {@code null} or zero for programmatic
	// {@link RateType#CPD} {@link ProposalLineItem proposal line items}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_SPONSORSHIP_CONTRACTED_UNITS_BOUGHT ProposalLineItemProgrammaticError_Reason = "INVALID_SPONSORSHIP_CONTRACTED_UNITS_BOUGHT"

	//
	// Only {@link PricingModel#NET} is supported for programmatic
	// {@link ProposalLineItem proposal line items}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_PROGRAMMATIC_PRICING_MODEL ProposalLineItemProgrammaticError_Reason = "INVALID_PROGRAMMATIC_PRICING_MODEL"

	//
	// Buyer is currently disabled for guaranteed deals due to violation of
	// Programmatic Guaranteed service level agreement.
	//
	ProposalLineItemProgrammaticError_ReasonBUYER_DISABLED_FOR_PG_VIOLATING_SLA ProposalLineItemProgrammaticError_Reason = "BUYER_DISABLED_FOR_PG_VIOLATING_SLA"

	//
	// Deals with agencies are limited to preferred deals, private auctions, and public
	// marketplace packages.
	//
	ProposalLineItemProgrammaticError_ReasonPG_NOT_SUPPORTED_FOR_AGENCY_BUYER ProposalLineItemProgrammaticError_Reason = "PG_NOT_SUPPORTED_FOR_AGENCY_BUYER"

	//
	// Buyer not found.
	//
	ProposalLineItemProgrammaticError_ReasonBUYER_NOT_FOUND ProposalLineItemProgrammaticError_Reason = "BUYER_NOT_FOUND"

	//
	// Cannot create/update {@link ProposalLineItem proposal line items} with an invalid
	// environment and request platform pair.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_ENVIRONMENT_PLATFORM_TYPE_PAIR ProposalLineItemProgrammaticError_Reason = "INVALID_ENVIRONMENT_PLATFORM_TYPE_PAIR"

	//
	// A {@link ProposalLineItem proposal line item} must either be of video, or audio type, but not
	// both.
	//
	ProposalLineItemProgrammaticError_ReasonCANNOT_MIX_AUDIO_VIDEO_PROGRAMMATIC_LINE_ITEM ProposalLineItemProgrammaticError_Reason = "CANNOT_MIX_AUDIO_VIDEO_PROGRAMMATIC_LINE_ITEM"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalLineItemProgrammaticError_ReasonUNKNOWN ProposalLineItemProgrammaticError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PublisherQueryLanguageContextError_Reason string

const (

	//
	// Indicates that there was an error executing the PQL.
	//
	PublisherQueryLanguageContextError_ReasonUNEXECUTABLE PublisherQueryLanguageContextError_Reason = "UNEXECUTABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageContextError_ReasonUNKNOWN PublisherQueryLanguageContextError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PublisherQueryLanguageSyntaxError_Reason string

const (

	//
	// Indicates that there was a PQL syntax error.
	//
	PublisherQueryLanguageSyntaxError_ReasonUNPARSABLE PublisherQueryLanguageSyntaxError_Reason = "UNPARSABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageSyntaxError_ReasonUNKNOWN PublisherQueryLanguageSyntaxError_Reason = "UNKNOWN"
)

type QuotaError_Reason string

const (

	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>Another way to mitigate this error is to limit requests to 8 per second for Ad Manager
	// 360 accounts, or 2 per second for Ad Manager accounts. Once again
	// this does not guarantee that every request will succeed, but may help
	// reduce the number of times you receive this error.
	//
	QuotaError_ReasonEXCEEDED_QUOTA QuotaError_Reason = "EXCEEDED_QUOTA"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	QuotaError_ReasonUNKNOWN QuotaError_Reason = "UNKNOWN"

	//
	// This user has exceeded the allowed number of new report requests per hour
	// (this includes both reports run via the UI and reports
	// run via {@link ReportService#runReportJob}).
	// The recommended approach to handle this error is to wait about 10 minutes
	// and then retry the request. Note that this does not guarantee the request
	// will succeed. If it fails again, try increasing the wait time.
	// <p>Another way to mitigate this error is to limit the number of new report
	// requests to 250 per hour per user. Once again, this does not guarantee that
	// every request will succeed, but may help reduce the number of times you
	// receive this error.
	//
	QuotaError_ReasonREPORT_JOB_LIMIT QuotaError_Reason = "REPORT_JOB_LIMIT"

	//
	// This network has exceeded the allowed number of identifiers uploaded within a 24 hour period.
	// The recommended approach to handle this error is to wait 30 minutes and then retry the
	// request. Note that this does not guarantee the request will succeed. If it fails again, try
	// increasing the wait time.
	//
	QuotaError_ReasonSEGMENT_POPULATION_LIMIT QuotaError_Reason = "SEGMENT_POPULATION_LIMIT"
)

type RangeError_Reason string

const (
	RangeError_ReasonTOO_HIGH RangeError_Reason = "TOO_HIGH"

	RangeError_ReasonTOO_LOW RangeError_Reason = "TOO_LOW"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RangeError_ReasonUNKNOWN RangeError_Reason = "UNKNOWN"
)

//
// Describes the type of event the advertiser is paying for. The values here correspond to the
// values for the {@link LineItem#costType} field.
//

type RateType string

const (

	//
	// The rate applies to cost per mille (CPM) revenue.
	//
	RateTypeCPM RateType = "CPM"

	//
	// The rate applies to cost per click (CPC) revenue.
	//
	RateTypeCPC RateType = "CPC"

	//
	// The rate applies to cost per day (CPD) revenue.
	//
	RateTypeCPD RateType = "CPD"

	//
	// The rate applies to cost per unit (CPU) revenue.
	//
	RateTypeCPU RateType = "CPU"

	//
	// The rate applies to flat fee revenue.
	//
	RateTypeFLAT_FEE RateType = "FLAT_FEE"

	//
	// The rate applies to Active View viewable cost per mille (vCPM) revenue.
	//
	RateTypeVCPM RateType = "VCPM"

	//
	// The rate applies to cost per mille in-target (CPM In-Target).
	//
	RateTypeCPM_IN_TARGET RateType = "CPM_IN_TARGET"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RateTypeUNKNOWN RateType = "UNKNOWN"
)

//
// Represents the platform which requests and renders the ad.
//

type RequestPlatform string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequestPlatformUNKNOWN RequestPlatform = "UNKNOWN"

	//
	// Represents a request made from a web browser. This includes both desktop and mobile web.
	//
	RequestPlatformBROWSER RequestPlatform = "BROWSER"

	//
	// Represents a request made from a mobile application. This includes mobile app interstitial and
	// rewarded video requests.
	//
	RequestPlatformMOBILE_APP RequestPlatform = "MOBILE_APP"

	//
	// Represents a request made from a video player that is playing publisher content. This includes
	// video players embedded in web pages and mobile applications, and connected TV screens.
	//
	RequestPlatformVIDEO_PLAYER RequestPlatform = "VIDEO_PLAYER"
)

//
// {@link ApiErrorReason} enum for the request platform targeting error.
//

type RequestPlatformTargetingError_Reason string

const (

	//
	// The line item type does not support the targeted request platform type.
	//
	RequestPlatformTargetingError_ReasonREQUEST_PLATFORM_TYPE_NOT_SUPPORTED_BY_LINE_ITEM_TYPE RequestPlatformTargetingError_Reason = "REQUEST_PLATFORM_TYPE_NOT_SUPPORTED_BY_LINE_ITEM_TYPE"

	//
	// The line item environment type does not support the targeted request platform type.
	//
	RequestPlatformTargetingError_ReasonREQUEST_PLATFORM_TYPE_NOT_SUPPORTED_BY_ENVIRONMENT_TYPE RequestPlatformTargetingError_Reason = "REQUEST_PLATFORM_TYPE_NOT_SUPPORTED_BY_ENVIRONMENT_TYPE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequestPlatformTargetingError_ReasonUNKNOWN RequestPlatformTargetingError_Reason = "UNKNOWN"
)

type RequiredCollectionError_Reason string

const (

	//
	// A required collection is missing.
	//
	RequiredCollectionError_ReasonREQUIRED RequiredCollectionError_Reason = "REQUIRED"

	//
	// Collection size is too large.
	//
	RequiredCollectionError_ReasonTOO_LARGE RequiredCollectionError_Reason = "TOO_LARGE"

	//
	// Collection size is too small.
	//
	RequiredCollectionError_ReasonTOO_SMALL RequiredCollectionError_Reason = "TOO_SMALL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredCollectionError_ReasonUNKNOWN RequiredCollectionError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type RequiredError_Reason string

const (

	//
	// Missing required field.
	//
	RequiredError_ReasonREQUIRED RequiredError_Reason = "REQUIRED"
)

//
// Describes reasons for a number to be invalid.
//

type RequiredNumberError_Reason string

const (
	RequiredNumberError_ReasonREQUIRED RequiredNumberError_Reason = "REQUIRED"

	RequiredNumberError_ReasonTOO_LARGE RequiredNumberError_Reason = "TOO_LARGE"

	RequiredNumberError_ReasonTOO_SMALL RequiredNumberError_Reason = "TOO_SMALL"

	RequiredNumberError_ReasonTOO_LARGE_WITH_DETAILS RequiredNumberError_Reason = "TOO_LARGE_WITH_DETAILS"

	RequiredNumberError_ReasonTOO_SMALL_WITH_DETAILS RequiredNumberError_Reason = "TOO_SMALL_WITH_DETAILS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredNumberError_ReasonUNKNOWN RequiredNumberError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ReservationDetailsError_Reason string

const (

	//
	// There is no limit on the number of ads delivered for a line item when you
	// set {@link LineItem#duration} to be
	// {@link LineItemSummary.Duration#NONE}. This can only be set for line
	// items of type {@link LineItemType#PRICE_PRIORITY}.
	//
	ReservationDetailsError_ReasonUNLIMITED_UNITS_BOUGHT_NOT_ALLOWED ReservationDetailsError_Reason = "UNLIMITED_UNITS_BOUGHT_NOT_ALLOWED"

	//
	// {@link LineItem#unlimitedEndDateTime} can be set to true for only
	// line items of type {@link LineItemType#SPONSORSHIP},
	// {@link LineItemType#NETWORK}, {@link LineItemType#PRICE_PRIORITY} and
	// {@link LineItemType#HOUSE}.
	//
	ReservationDetailsError_ReasonUNLIMITED_END_DATE_TIME_NOT_ALLOWED ReservationDetailsError_Reason = "UNLIMITED_END_DATE_TIME_NOT_ALLOWED"

	//
	// When {@link LineItem#lineItemType} is
	// {@link LineItemType#SPONSORSHIP}, then
	// {@link LineItem#unitsBought} represents the percentage of
	// available impressions reserved. That value cannot exceed 100.
	//
	ReservationDetailsError_ReasonPERCENTAGE_UNITS_BOUGHT_TOO_HIGH ReservationDetailsError_Reason = "PERCENTAGE_UNITS_BOUGHT_TOO_HIGH"

	//
	// The line item type does not support the specified duration. See
	// {@link LineItemSummary.Duration} for allowed values.
	//
	ReservationDetailsError_ReasonDURATION_NOT_ALLOWED ReservationDetailsError_Reason = "DURATION_NOT_ALLOWED"

	//
	// The {@link LineItem#unitType} is not allowed for the given
	// {@link LineItem#lineItemType}. See {@link UnitType} for allowed
	// values.
	//
	ReservationDetailsError_ReasonUNIT_TYPE_NOT_ALLOWED ReservationDetailsError_Reason = "UNIT_TYPE_NOT_ALLOWED"

	//
	// The {@link LineItem#costType} is not allowed for the
	// {@link LineItem#lineItemType}. See {@link CostType} for allowed
	// values.
	//
	ReservationDetailsError_ReasonCOST_TYPE_NOT_ALLOWED ReservationDetailsError_Reason = "COST_TYPE_NOT_ALLOWED"

	//
	// When {@link LineItem#costType} is {@link CostType#CPM},
	// {@link LineItem#unitType} must be {@link UnitType#IMPRESSIONS}
	// and when {@link LineItem#costType} is {@link CostType#CPC},
	// {@link LineItem#unitType} must be {@link UnitType#CLICKS}.
	//
	ReservationDetailsError_ReasonCOST_TYPE_UNIT_TYPE_MISMATCH_NOT_ALLOWED ReservationDetailsError_Reason = "COST_TYPE_UNIT_TYPE_MISMATCH_NOT_ALLOWED"

	//
	// Inventory cannot be reserved for line items which are not of type
	// {@link LineItemType#SPONSORSHIP} or {@link LineItemType#STANDARD}.
	//
	ReservationDetailsError_ReasonLINE_ITEM_TYPE_NOT_ALLOWED ReservationDetailsError_Reason = "LINE_ITEM_TYPE_NOT_ALLOWED"

	//
	// Network remnant line items cannot be changed to other line item types once delivery begins.
	// This restriction does not apply to any new line items created in Ad Manager.
	//
	ReservationDetailsError_ReasonNETWORK_REMNANT_ORDER_CANNOT_UPDATE_LINEITEM_TYPE ReservationDetailsError_Reason = "NETWORK_REMNANT_ORDER_CANNOT_UPDATE_LINEITEM_TYPE"

	//
	// A dynamic allocation web property can only be set on a line item of type
	// AdSense or Ad Exchange.
	//
	ReservationDetailsError_ReasonBACKFILL_WEBPROPERTY_CODE_NOT_ALLOWED ReservationDetailsError_Reason = "BACKFILL_WEBPROPERTY_CODE_NOT_ALLOWED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ReservationDetailsError_ReasonUNKNOWN ReservationDetailsError_Reason = "UNKNOWN"
)

//
// Represents the inventory reservation status for {@link ProposalLineItem} objects.
//

type ReservationStatus string

const (

	//
	// The inventory is reserved.
	//
	ReservationStatusRESERVED ReservationStatus = "RESERVED"

	//
	// The proposal line item's inventory is never reserved.
	//
	ReservationStatusNOT_RESERVED ReservationStatus = "NOT_RESERVED"

	//
	// The inventory is once reserved and now released.
	//
	ReservationStatusRELEASED ReservationStatus = "RELEASED"

	//
	// The reservation status of the corresponding {@link LineItem} should be used
	// for this {@link ProposalLineItem}.
	//
	ReservationStatusCHECK_LINE_ITEM_RESERVATION_STATUS ReservationStatus = "CHECK_LINE_ITEM_RESERVATION_STATUS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ReservationStatusUNKNOWN ReservationStatus = "UNKNOWN"
)

//
// Describes the roadblocking types.
//

type RoadblockingType string

const (

	//
	// Only one creative from a line item can serve at a time.
	//
	RoadblockingTypeONLY_ONE RoadblockingType = "ONLY_ONE"

	//
	// Any number of creatives from a line item can serve together at a time.
	//
	RoadblockingTypeONE_OR_MORE RoadblockingType = "ONE_OR_MORE"

	//
	// As many creatives from a line item as can fit on a page will serve. This
	// could mean anywhere from one to all of a line item's creatives given the
	// size constraints of ad slots on a page.
	//
	RoadblockingTypeAS_MANY_AS_POSSIBLE RoadblockingType = "AS_MANY_AS_POSSIBLE"

	//
	// All or none of the creatives from a line item will serve. This option will only work if
	// served to a GPT tag using SRA (single request architecture mode).
	//
	RoadblockingTypeALL_ROADBLOCK RoadblockingType = "ALL_ROADBLOCK"

	//
	// A master/companion {@link CreativeSet} roadblocking type.
	// A {@link LineItem#creativePlaceholders} must be set accordingly.
	//
	RoadblockingTypeCREATIVE_SET RoadblockingType = "CREATIVE_SET"
)

//
// Reason of the given {@link AudienceSegmentError}.
//

type AudienceSegmentError_Reason string

const (

	//
	// First party audience segment is not supported.
	//
	AudienceSegmentError_ReasonFIRST_PARTY_AUDIENCE_SEGMENT_NOT_SUPPORTED AudienceSegmentError_Reason = "FIRST_PARTY_AUDIENCE_SEGMENT_NOT_SUPPORTED"

	//
	// Only rule-based first-party audience segments can be created.
	//
	AudienceSegmentError_ReasonONLY_RULE_BASED_FIRST_PARTY_AUDIENCE_SEGMENTS_CAN_BE_CREATED AudienceSegmentError_Reason = "ONLY_RULE_BASED_FIRST_PARTY_AUDIENCE_SEGMENTS_CAN_BE_CREATED"

	//
	// Audience segment for the given id is not found.
	//
	AudienceSegmentError_ReasonAUDIENCE_SEGMENT_ID_NOT_FOUND AudienceSegmentError_Reason = "AUDIENCE_SEGMENT_ID_NOT_FOUND"

	//
	// Audience segment rule is invalid.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_RULE AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_RULE"

	//
	// Audience segment rule contains too many ad units and/or custom criteria.
	//
	AudienceSegmentError_ReasonAUDIENCE_SEGMENT_RULE_TOO_LONG AudienceSegmentError_Reason = "AUDIENCE_SEGMENT_RULE_TOO_LONG"

	//
	// Audience segment name is invalid.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_NAME AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_NAME"

	//
	// Audience segment with this name already exists.
	//
	AudienceSegmentError_ReasonDUPLICATE_AUDIENCE_SEGMENT_NAME AudienceSegmentError_Reason = "DUPLICATE_AUDIENCE_SEGMENT_NAME"

	//
	// Audience segment description is invalid.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_DESCRIPTION AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_DESCRIPTION"

	//
	// Audience segment pageviews value is invalid. It must be between 1 and 12.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_PAGEVIEWS AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_PAGEVIEWS"

	//
	// Audience segment recency value is invalid. It must be between 1 and 90 if pageviews > 1.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_RECENCY AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_RECENCY"

	//
	// Audience segment membership expiration value is invalid. It must be between 1 and 180.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_MEMBERSHIP_EXPIRATION AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_MEMBERSHIP_EXPIRATION"

	//
	// The given custom key cannot be part of audience segment rule due to unsupported characters.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_CUSTOM_KEY_NAME AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_CUSTOM_KEY_NAME"

	//
	// The given custom value cannot be part of audience segment rule due to unsupported characters.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_NAME AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_NAME"

	//
	// Broad-match custom value cannot be part of audience segment rule.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_MATCH_TYPE AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_MATCH_TYPE"

	//
	// Audience segment rule cannot contain itself.
	//
	AudienceSegmentError_ReasonINVALID_NESTED_FIRST_PARTY_AUDIENCE_SEGMENT AudienceSegmentError_Reason = "INVALID_NESTED_FIRST_PARTY_AUDIENCE_SEGMENT"

	//
	// Audience segment rule cannot contain shared selling inventory unit.
	//
	AudienceSegmentError_ReasonSHARED_SELLING_PARTNER_ROOT_CANNOT_BE_INCLUDED AudienceSegmentError_Reason = "SHARED_SELLING_PARTNER_ROOT_CANNOT_BE_INCLUDED"

	//
	// Audience segment rule cannot contain a nested third-party segment.
	//
	AudienceSegmentError_ReasonINVALID_NESTED_THIRD_PARTY_AUDIENCE_SEGMENT AudienceSegmentError_Reason = "INVALID_NESTED_THIRD_PARTY_AUDIENCE_SEGMENT"

	//
	// Audience segment rule cannot contain a nested inactive segment.
	//
	AudienceSegmentError_ReasonINACTIVE_NESTED_AUDIENCE_SEGMENT AudienceSegmentError_Reason = "INACTIVE_NESTED_AUDIENCE_SEGMENT"

	//
	// An error occurred when purchasing global licenses.
	//
	AudienceSegmentError_ReasonAUDIENCE_SEGMENT_GLOBAL_LICENSE_ERROR AudienceSegmentError_Reason = "AUDIENCE_SEGMENT_GLOBAL_LICENSE_ERROR"

	//
	// Segment cannot be activated as it violates Google's Platform Policy.
	//
	AudienceSegmentError_ReasonSEGMENT_VIOLATED_POLICY AudienceSegmentError_Reason = "SEGMENT_VIOLATED_POLICY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AudienceSegmentError_ReasonUNKNOWN AudienceSegmentError_Reason = "UNKNOWN"
)

//
// Describes reasons for server errors
//

type ServerError_Reason string

const (

	//
	// Indicates that an unexpected error occured.
	//
	ServerError_ReasonSERVER_ERROR ServerError_Reason = "SERVER_ERROR"

	//
	// Indicates that the server is currently experiencing a high load. Please
	// wait and try your request again.
	//
	ServerError_ReasonSERVER_BUSY ServerError_Reason = "SERVER_BUSY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ServerError_ReasonUNKNOWN ServerError_Reason = "UNKNOWN"
)

//
// The different types of skippable ads.
//

type SkippableAdType string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	SkippableAdTypeUNKNOWN SkippableAdType = "UNKNOWN"

	//
	// Skippable ad type is disabled.
	//
	SkippableAdTypeDISABLED SkippableAdType = "DISABLED"

	//
	// Skippable ad type is enabled.
	//
	SkippableAdTypeENABLED SkippableAdType = "ENABLED"

	//
	// Skippable in-stream ad type.
	//
	SkippableAdTypeINSTREAM_SELECT SkippableAdType = "INSTREAM_SELECT"

	//
	// Any skippable or not skippable. This is only for programmatic case when the creative
	// skippability is decided by the buyside.
	//
	SkippableAdTypeANY SkippableAdType = "ANY"
)

type StatementError_Reason string

const (

	//
	// A bind variable has not been bound to a value.
	//
	StatementError_ReasonVARIABLE_NOT_BOUND_TO_VALUE StatementError_Reason = "VARIABLE_NOT_BOUND_TO_VALUE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StatementError_ReasonUNKNOWN StatementError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type StringFormatError_Reason string

const (
	StringFormatError_ReasonUNKNOWN StringFormatError_Reason = "UNKNOWN"

	//
	// The input string value contains disallowed characters.
	//
	StringFormatError_ReasonILLEGAL_CHARS StringFormatError_Reason = "ILLEGAL_CHARS"

	//
	// The input string value is invalid for the associated field.
	//
	StringFormatError_ReasonINVALID_FORMAT StringFormatError_Reason = "INVALID_FORMAT"
)

type StringLengthError_Reason string

const (
	StringLengthError_ReasonTOO_LONG StringLengthError_Reason = "TOO_LONG"

	StringLengthError_ReasonTOO_SHORT StringLengthError_Reason = "TOO_SHORT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StringLengthError_ReasonUNKNOWN StringLengthError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type TeamError_Reason string

const (

	//
	// User cannot use this entity because it is not on any of the user's teams.
	//
	TeamError_ReasonENTITY_NOT_ON_USERS_TEAMS TeamError_Reason = "ENTITY_NOT_ON_USERS_TEAMS"

	//
	// The targeted or excluded ad unit must be on the order's teams.
	//
	TeamError_ReasonAD_UNITS_NOT_ON_ORDER_TEAMS TeamError_Reason = "AD_UNITS_NOT_ON_ORDER_TEAMS"

	//
	// The targeted placement must be on the order's teams.
	//
	TeamError_ReasonPLACEMENTS_NOT_ON_ORDER_TEAMS TeamError_Reason = "PLACEMENTS_NOT_ON_ORDER_TEAMS"

	//
	// Entity cannot be created because it is not on any of the user's teams.
	//
	TeamError_ReasonMISSING_USERS_TEAM TeamError_Reason = "MISSING_USERS_TEAM"

	//
	// A team that gives access to all entities of a given type cannot be
	// associated with an entity of that type.
	//
	TeamError_ReasonALL_TEAM_ASSOCIATION_NOT_ALLOWED TeamError_Reason = "ALL_TEAM_ASSOCIATION_NOT_ALLOWED"

	//
	// The assignment of team to entities is invalid.
	//
	TeamError_ReasonINVALID_TEAM_ASSIGNMENT TeamError_Reason = "INVALID_TEAM_ASSIGNMENT"

	//
	// Cannot modify or create a team with an inactive status.
	//
	TeamError_ReasonCANNOT_UPDATE_INACTIVE_TEAM TeamError_Reason = "CANNOT_UPDATE_INACTIVE_TEAM"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TeamError_ReasonUNKNOWN TeamError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type TechnologyTargetingError_Reason string

const (

	//
	// Mobile line item cannot target web-only targeting criteria.
	//
	TechnologyTargetingError_ReasonMOBILE_LINE_ITEM_CONTAINS_WEB_TECH_CRITERIA TechnologyTargetingError_Reason = "MOBILE_LINE_ITEM_CONTAINS_WEB_TECH_CRITERIA"

	//
	// Web line item cannot target mobile-only targeting criteria.
	//
	TechnologyTargetingError_ReasonWEB_LINE_ITEM_CONTAINS_MOBILE_TECH_CRITERIA TechnologyTargetingError_Reason = "WEB_LINE_ITEM_CONTAINS_MOBILE_TECH_CRITERIA"

	//
	// The mobile carrier targeting feature is not enabled.
	//
	TechnologyTargetingError_ReasonMOBILE_CARRIER_TARGETING_FEATURE_NOT_ENABLED TechnologyTargetingError_Reason = "MOBILE_CARRIER_TARGETING_FEATURE_NOT_ENABLED"

	//
	// The device capability targeting feature is not enabled.
	//
	TechnologyTargetingError_ReasonDEVICE_CAPABILITY_TARGETING_FEATURE_NOT_ENABLED TechnologyTargetingError_Reason = "DEVICE_CAPABILITY_TARGETING_FEATURE_NOT_ENABLED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TechnologyTargetingError_ReasonUNKNOWN TechnologyTargetingError_Reason = "UNKNOWN"
)

//
// Possible options for third-party brand lift integration.
//

type ThirdPartyBrandLiftIntegrationPartner string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ThirdPartyBrandLiftIntegrationPartnerUNKNOWN ThirdPartyBrandLiftIntegrationPartner = "UNKNOWN"

	//
	// Indicates there's no third-party brand lift integration partner.
	//
	ThirdPartyBrandLiftIntegrationPartnerNONE ThirdPartyBrandLiftIntegrationPartner = "NONE"

	//
	// Indicates third-party brand lift integration partner Kantar.
	//
	ThirdPartyBrandLiftIntegrationPartnerKANTAR_MILLWARD_BROWN ThirdPartyBrandLiftIntegrationPartner = "KANTAR_MILLWARD_BROWN"

	//
	// Indicates third-party brand lift integration partner Dynata.
	//
	ThirdPartyBrandLiftIntegrationPartnerDYNATA ThirdPartyBrandLiftIntegrationPartner = "DYNATA"

	//
	// Indicates third-party brand lift integration partner Intage.
	//
	ThirdPartyBrandLiftIntegrationPartnerINTAGE ThirdPartyBrandLiftIntegrationPartner = "INTAGE"

	//
	// Indicates third-party brand lift integration partner Macromill.
	//
	ThirdPartyBrandLiftIntegrationPartnerMACROMILL ThirdPartyBrandLiftIntegrationPartner = "MACROMILL"
)

//
// Possible options for third-party reach integration.
//

type ThirdPartyReachIntegrationPartner string

const (

	//
	// Indicates there's no third-party reach integration partner.
	//
	ThirdPartyReachIntegrationPartnerNONE ThirdPartyReachIntegrationPartner = "NONE"

	//
	// Indicates third-party reach integration partner Comscore.
	//
	ThirdPartyReachIntegrationPartnerCOMSCORE ThirdPartyReachIntegrationPartner = "COMSCORE"

	//
	// Indicates third-party reach integration partner Nielsen.
	//
	ThirdPartyReachIntegrationPartnerNIELSEN ThirdPartyReachIntegrationPartner = "NIELSEN"

	//
	// Indicates third-party reach integration partner Kantar.
	//
	ThirdPartyReachIntegrationPartnerKANTAR_MILLWARD_BROWN ThirdPartyReachIntegrationPartner = "KANTAR_MILLWARD_BROWN"

	//
	// Indicates third-party reach integration partner Video Research.
	//
	ThirdPartyReachIntegrationPartnerVIDEO_RESEARCH ThirdPartyReachIntegrationPartner = "VIDEO_RESEARCH"

	//
	// Indicates third-party reach integration partner Gemius.
	//
	ThirdPartyReachIntegrationPartnerGEMIUS ThirdPartyReachIntegrationPartner = "GEMIUS"

	//
	// Indicates third-party reach integration partner VideoAmp
	//
	ThirdPartyReachIntegrationPartnerVIDEO_AMP ThirdPartyReachIntegrationPartner = "VIDEO_AMP"

	//
	// Indicates third-party reach integration partner iSpot.TV
	//
	ThirdPartyReachIntegrationPartnerISPOT_TV ThirdPartyReachIntegrationPartner = "ISPOT_TV"

	//
	// Indicates third-party reach integration partner Audience Project
	//
	ThirdPartyReachIntegrationPartnerAUDIENCE_PROJECT ThirdPartyReachIntegrationPartner = "AUDIENCE_PROJECT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ThirdPartyReachIntegrationPartnerUNKNOWN ThirdPartyReachIntegrationPartner = "UNKNOWN"
)

//
// Possible options for third-party viewabitility integration.
//

type ThirdPartyViewabilityIntegrationPartner string

const (

	//
	// Indicates there's no third-party viewability integration partner.
	//
	ThirdPartyViewabilityIntegrationPartnerNONE ThirdPartyViewabilityIntegrationPartner = "NONE"

	//
	// Indicates third-party viewability integration partner Oracle Moat.
	//
	ThirdPartyViewabilityIntegrationPartnerMOAT ThirdPartyViewabilityIntegrationPartner = "MOAT"

	//
	// Indicates third-party viewability integration partner Double Verify.
	//
	ThirdPartyViewabilityIntegrationPartnerDOUBLE_VERIFY ThirdPartyViewabilityIntegrationPartner = "DOUBLE_VERIFY"

	//
	// Indicates third-party viewability integration partner Integral Ad Science.
	//
	ThirdPartyViewabilityIntegrationPartnerINTEGRAL_AD_SCIENCE ThirdPartyViewabilityIntegrationPartner = "INTEGRAL_AD_SCIENCE"

	//
	// Indicates third-party viewability integration partner Comscore.
	//
	ThirdPartyViewabilityIntegrationPartnerCOMSCORE ThirdPartyViewabilityIntegrationPartner = "COMSCORE"

	//
	// Indicates third-party viewability integration partner Telemetry.
	//
	ThirdPartyViewabilityIntegrationPartnerTELEMETRY ThirdPartyViewabilityIntegrationPartner = "TELEMETRY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ThirdPartyViewabilityIntegrationPartnerUNKNOWN ThirdPartyViewabilityIntegrationPartner = "UNKNOWN"
)

//
// Represent the possible time units for frequency capping.
//

type TimeUnit string

const (
	TimeUnitMINUTE TimeUnit = "MINUTE"

	TimeUnitHOUR TimeUnit = "HOUR"

	TimeUnitDAY TimeUnit = "DAY"

	TimeUnitWEEK TimeUnit = "WEEK"

	TimeUnitMONTH TimeUnit = "MONTH"

	TimeUnitLIFETIME TimeUnit = "LIFETIME"

	//
	// Per pod of ads in a video stream. Only valid for entities in a
	// {@link EnvironmentType#VIDEO_PLAYER} environment.
	//
	TimeUnitPOD TimeUnit = "POD"

	//
	// Per video stream. Only valid for entities in a
	// {@link EnvironmentType#VIDEO_PLAYER} environment.
	//
	TimeUnitSTREAM TimeUnit = "STREAM"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TimeUnitUNKNOWN TimeUnit = "UNKNOWN"
)

//
// Describes reasons for invalid timezone.
//

type TimeZoneError_Reason string

const (

	//
	// Indicates that the timezone ID provided is not supported.
	//
	TimeZoneError_ReasonINVALID_TIMEZONE_ID TimeZoneError_Reason = "INVALID_TIMEZONE_ID"

	//
	// Indicates that the timezone ID provided is in the wrong format.
	// The timezone ID must be in tz database format (e.g. "America/Los_Angeles").
	//
	TimeZoneError_ReasonTIMEZONE_ID_IN_WRONG_FORMAT TimeZoneError_Reason = "TIMEZONE_ID_IN_WRONG_FORMAT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TimeZoneError_ReasonUNKNOWN TimeZoneError_Reason = "UNKNOWN"
)

//
// Indicates the type of unit used for defining a reservation. The
// {@link CostType} can differ from the {@link UnitType} - an
// ad can have an impression goal, but be billed by its click. Usually
// {@link CostType} and {@link UnitType} will refer to the
// same unit.
//

type UnitType string

const (

	//
	// The number of impressions served by creatives associated with the line
	// item. Line items of all {@link LineItemType} support this {@code UnitType}.
	//
	UnitTypeIMPRESSIONS UnitType = "IMPRESSIONS"

	//
	// The number of clicks reported by creatives associated with the line item.
	// The {@link LineItem#lineItemType} must be
	// {@link LineItemType#STANDARD}, {@link LineItemType#BULK} or
	// {@link LineItemType#PRICE_PRIORITY}.
	//
	UnitTypeCLICKS UnitType = "CLICKS"

	//
	// The number of click-through Cost-Per-Action (CPA) conversions from creatives
	// associated with the line item. This is only supported as secondary goal and the
	// {@link LineItem#costType} must be {@link CostType#CPA}.
	//
	UnitTypeCLICK_THROUGH_CPA_CONVERSIONS UnitType = "CLICK_THROUGH_CPA_CONVERSIONS"

	//
	// The number of view-through Cost-Per-Action (CPA) conversions from creatives
	// associated with the line item. This is only supported as secondary goal and the
	// {@link LineItem#costType} must be {@link CostType#CPA}.
	//
	UnitTypeVIEW_THROUGH_CPA_CONVERSIONS UnitType = "VIEW_THROUGH_CPA_CONVERSIONS"

	//
	// The number of total Cost-Per-Action (CPA) conversions from creatives
	// associated with the line item. This is only supported as secondary goal and the
	// {@link LineItem#costType} must be {@link CostType#CPA}.
	//
	UnitTypeTOTAL_CPA_CONVERSIONS UnitType = "TOTAL_CPA_CONVERSIONS"

	//
	// The number of viewable impressions reported by creatives associated with the line item.
	// The {@link LineItem#lineItemType} must be {@link LineItemType#STANDARD}.
	//
	UnitTypeVIEWABLE_IMPRESSIONS UnitType = "VIEWABLE_IMPRESSIONS"

	//
	// The number of in-target impressions reported by third party measurements.
	// The {@link LineItem#lineItemType} must be {@link LineItemType#STANDARD}.
	//
	UnitTypeIN_TARGET_IMPRESSIONS UnitType = "IN_TARGET_IMPRESSIONS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	UnitTypeUNKNOWN UnitType = "UNKNOWN"
)

//
// {@link ApiErrorReason} enum for user domain targeting error.
//

type UserDomainTargetingError_Reason string

const (

	//
	// Invalid domain names. Domain names must be at most 67 characters long.
	// And must contain only alphanumeric characters and hyphens.
	//
	UserDomainTargetingError_ReasonINVALID_DOMAIN_NAMES UserDomainTargetingError_Reason = "INVALID_DOMAIN_NAMES"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	UserDomainTargetingError_ReasonUNKNOWN UserDomainTargetingError_Reason = "UNKNOWN"
)

//
// Represents the options for targetable bumper positions, surrounding an ad
// pod, within a video stream. This includes before and after the supported ad
// pod positions, {@link VideoPositionType#PREROLL},
// {@link VideoPositionType#MIDROLL}, and {@link VideoPositionType#POSTROLL}.
//

type VideoBumperType string

const (

	//
	// Represents the bumper position before the ad pod.
	//
	VideoBumperTypeBEFORE VideoBumperType = "BEFORE"

	//
	// Represents the bumper position after the ad pod.
	//
	VideoBumperTypeAFTER VideoBumperType = "AFTER"
)

//
// Represents a targetable position within a video.
//

type VideoPosition_Type string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	VideoPosition_TypeUNKNOWN VideoPosition_Type = "UNKNOWN"

	//
	// This position targets all of the above video positions.
	//
	VideoPosition_TypeALL VideoPosition_Type = "ALL"

	//
	// The position defined as showing before the video starts playing.
	//
	VideoPosition_TypePREROLL VideoPosition_Type = "PREROLL"

	//
	// The position defined as showing within the middle of the playing video.
	//
	VideoPosition_TypeMIDROLL VideoPosition_Type = "MIDROLL"

	//
	// The position defined as showing after the video is completed.
	//
	VideoPosition_TypePOSTROLL VideoPosition_Type = "POSTROLL"
)

//
// The reasons for the video position targeting error.
//

type VideoPositionTargetingError_Reason string

const (

	//
	// Video position targeting cannot contain both bumper and non-bumper targeting values.
	//
	VideoPositionTargetingError_ReasonCANNOT_MIX_BUMPER_AND_NON_BUMPER_TARGETING VideoPositionTargetingError_Reason = "CANNOT_MIX_BUMPER_AND_NON_BUMPER_TARGETING"

	//
	// The bumper video position targeting is invalid.
	//
	VideoPositionTargetingError_ReasonINVALID_BUMPER_TARGETING VideoPositionTargetingError_Reason = "INVALID_BUMPER_TARGETING"

	//
	// Only custom spot {@link AdSpot} objects can be targeted.
	//
	VideoPositionTargetingError_ReasonCAN_ONLY_TARGET_CUSTOM_AD_SPOTS VideoPositionTargetingError_Reason = "CAN_ONLY_TARGET_CUSTOM_AD_SPOTS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	VideoPositionTargetingError_ReasonUNKNOWN VideoPositionTargetingError_Reason = "UNKNOWN"
)

type CreateMakegoods struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createMakegoods"`

	MakegoodInfos []*ProposalLineItemMakegoodInfo `xml:"makegoodInfos,omitempty" json:"makegoodInfos,omitempty"`
}

type CreateMakegoodsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createMakegoodsResponse"`

	Rval []*ProposalLineItem `xml:"rval,omitempty" json:"rval,omitempty"`
}

type ApiExceptionFault ApiException

type CreateProposalLineItems struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createProposalLineItems"`

	ProposalLineItems []*ProposalLineItem `xml:"proposalLineItems,omitempty" json:"proposalLineItems,omitempty"`
}

type CreateProposalLineItemsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createProposalLineItemsResponse"`

	Rval []*ProposalLineItem `xml:"rval,omitempty" json:"rval,omitempty"`
}

type GetProposalLineItemsByStatement struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getProposalLineItemsByStatement"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type GetProposalLineItemsByStatementResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getProposalLineItemsByStatementResponse"`

	Rval *ProposalLineItemPage `xml:"rval,omitempty" json:"rval,omitempty"`
}

type PerformProposalLineItemAction struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 performProposalLineItemAction"`

	ProposalLineItemAction *ProposalLineItemAction `xml:"proposalLineItemAction,omitempty" json:"proposalLineItemAction,omitempty"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type PerformProposalLineItemActionResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 performProposalLineItemActionResponse"`

	Rval *UpdateResult `xml:"rval,omitempty" json:"rval,omitempty"`
}

type UpdateProposalLineItems struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateProposalLineItems"`

	ProposalLineItems []*ProposalLineItem `xml:"proposalLineItems,omitempty" json:"proposalLineItems,omitempty"`
}

type UpdateProposalLineItemsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateProposalLineItemsResponse"`

	Rval []*ProposalLineItem `xml:"rval,omitempty" json:"rval,omitempty"`
}

type RequestHeader SoapRequestHeader

type ResponseHeader SoapResponseHeader

type ObjectValue struct {
	*_Value
}

type AdUnitTargeting struct {

	//
	// Included or excluded ad unit id.
	//
	AdUnitId string `xml:"adUnitId,omitempty" json:"adUnitId,omitempty"`

	//
	// Whether or not all descendants are included (or excluded) as part of including (or excluding)
	// this ad unit. By default, the value is {@code true} which means targeting this ad unit will
	// target all of its descendants.
	//
	IncludeDescendants bool `xml:"includeDescendants,omitempty" json:"includeDescendants,omitempty"`
}

type ApiError struct {

	//
	// The OGNL field path to identify cause of error.
	//
	FieldPath string `xml:"fieldPath,omitempty" json:"fieldPath,omitempty"`

	//
	// A parsed copy of the field path. For example, the field path "operations[1].operand"
	// corresponds to this list: {FieldPathElement(field = "operations", index = 1),
	// FieldPathElement(field = "operand", index = null)}.
	//
	FieldPathElements []*FieldPathElement `xml:"fieldPathElements,omitempty" json:"fieldPathElements,omitempty"`

	//
	// The data that caused the error.
	//
	Trigger string `xml:"trigger,omitempty" json:"trigger,omitempty"`

	//
	// A simple string representation of the error and reason.
	//
	ErrorString string `xml:"errorString,omitempty" json:"errorString,omitempty"`
}

type ApiException struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 ApiExceptionFault"`

	*ApplicationException

	//
	// List of errors.
	//
	Errors []*ApiError `xml:"errors,omitempty" json:"errors,omitempty"`
}

type TechnologyTargeting struct {

	//
	// The bandwidth groups being targeted by the {@link LineItem}.
	//
	BandwidthGroupTargeting *BandwidthGroupTargeting `xml:"bandwidthGroupTargeting,omitempty" json:"bandwidthGroupTargeting,omitempty"`

	//
	// The browsers being targeted by the {@link LineItem}.
	//
	BrowserTargeting *BrowserTargeting `xml:"browserTargeting,omitempty" json:"browserTargeting,omitempty"`

	//
	// The languages of browsers being targeted by the {@link LineItem}.
	//
	BrowserLanguageTargeting *BrowserLanguageTargeting `xml:"browserLanguageTargeting,omitempty" json:"browserLanguageTargeting,omitempty"`

	//
	// The device capabilities being targeted by the {@link LineItem}.
	//
	DeviceCapabilityTargeting *DeviceCapabilityTargeting `xml:"deviceCapabilityTargeting,omitempty" json:"deviceCapabilityTargeting,omitempty"`

	//
	// The device categories being targeted by the {@link LineItem}.
	//
	DeviceCategoryTargeting *DeviceCategoryTargeting `xml:"deviceCategoryTargeting,omitempty" json:"deviceCategoryTargeting,omitempty"`

	//
	// The device manufacturers being targeted by the {@link LineItem}.
	//
	DeviceManufacturerTargeting *DeviceManufacturerTargeting `xml:"deviceManufacturerTargeting,omitempty" json:"deviceManufacturerTargeting,omitempty"`

	//
	// The mobile carriers being targeted by the {@link LineItem}.
	//
	MobileCarrierTargeting *MobileCarrierTargeting `xml:"mobileCarrierTargeting,omitempty" json:"mobileCarrierTargeting,omitempty"`

	//
	// The mobile devices being targeted by the {@link LineItem}.
	//
	MobileDeviceTargeting *MobileDeviceTargeting `xml:"mobileDeviceTargeting,omitempty" json:"mobileDeviceTargeting,omitempty"`

	//
	// The mobile device submodels being targeted by the {@link LineItem}.
	//
	MobileDeviceSubmodelTargeting *MobileDeviceSubmodelTargeting `xml:"mobileDeviceSubmodelTargeting,omitempty" json:"mobileDeviceSubmodelTargeting,omitempty"`

	//
	// The operating systems being targeted by the {@link LineItem}.
	//
	OperatingSystemTargeting *OperatingSystemTargeting `xml:"operatingSystemTargeting,omitempty" json:"operatingSystemTargeting,omitempty"`

	//
	// The operating system versions being targeted by the {@link LineItem}.
	//
	OperatingSystemVersionTargeting *OperatingSystemVersionTargeting `xml:"operatingSystemVersionTargeting,omitempty" json:"operatingSystemVersionTargeting,omitempty"`
}

type ApiVersionError struct {
	*ApiError

	Reason *ApiVersionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ApplicationException struct {

	//
	// Error message.
	//
	Message string `xml:"message,omitempty" json:"message,omitempty"`
}

type AppliedLabel struct {

	//
	// The ID of a created {@link Label}.
	//
	LabelId int64 `xml:"labelId,omitempty" json:"labelId,omitempty"`

	//
	// {@code isNegated} should be set to {@code true} to negate the effects of {@code labelId}.
	//
	IsNegated bool `xml:"isNegated,omitempty" json:"isNegated,omitempty"`
}

type ArchiveProposalLineItems struct {
	*ProposalLineItemAction
}

type AuthenticationError struct {
	*ApiError

	Reason *AuthenticationError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type BandwidthGroup struct {
	*Technology
}

type BandwidthGroupTargeting struct {

	//
	// Indicates whether bandwidth groups should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// The bandwidth groups that are being targeted or excluded by the {@link LineItem}.
	//
	BandwidthGroups []*Technology `xml:"bandwidthGroups,omitempty" json:"bandwidthGroups,omitempty"`
}

type BaseCustomFieldValue struct {

	//
	// Id of the {@code CustomField} to which this value belongs. This attribute is required.
	//
	CustomFieldId int64 `xml:"customFieldId,omitempty" json:"customFieldId,omitempty"`
}

type BillingError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *BillingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type BooleanValue struct {
	*_Value

	//
	// The boolean value.
	//
	Value bool `xml:"value,omitempty" json:"value,omitempty"`
}

type Browser struct {
	*Technology

	//
	// Browser major version.
	//
	MajorVersion string `xml:"majorVersion,omitempty" json:"majorVersion,omitempty"`

	//
	// Browser minor version.
	//
	MinorVersion string `xml:"minorVersion,omitempty" json:"minorVersion,omitempty"`
}

type BrowserLanguage struct {
	*Technology
}

type BrowserLanguageTargeting struct {

	//
	// Indicates whether browsers languages should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Browser languages that are being targeted or excluded by the {@link LineItem}.
	//
	BrowserLanguages []*Technology `xml:"browserLanguages,omitempty" json:"browserLanguages,omitempty"`
}

type BrowserTargeting struct {

	//
	// Indicates whether browsers should be targeted or excluded. This attribute is optional and
	// defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Browsers that are being targeted or excluded by the {@link LineItem}.
	//
	Browsers []*Technology `xml:"browsers,omitempty" json:"browsers,omitempty"`
}

type BuyerUserListTargeting struct {

	//
	// Whether the programmatic {@code LineItem} or {@code ProposalLineItem} object has buyer user
	// list targeting.
	//
	HasBuyerUserListTargeting bool `xml:"hasBuyerUserListTargeting,omitempty" json:"hasBuyerUserListTargeting,omitempty"`
}

type CollectionSizeError struct {
	*ApiError

	Reason *CollectionSizeError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CommonError struct {
	*ApiError

	Reason *CommonError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ContentTargeting struct {

	//
	// The IDs of content being targeted by the {@code LineItem}.
	//
	TargetedContentIds []int64 `xml:"targetedContentIds,omitempty" json:"targetedContentIds,omitempty"`

	//
	// The IDs of content being excluded by the {@code LineItem}.
	//
	ExcludedContentIds []int64 `xml:"excludedContentIds,omitempty" json:"excludedContentIds,omitempty"`

	//
	// A list of video content bundles, represented by {@link ContentBundle} IDs, that are being
	// targeted by the {@code LineItem}.
	//
	TargetedVideoContentBundleIds []int64 `xml:"targetedVideoContentBundleIds,omitempty" json:"targetedVideoContentBundleIds,omitempty"`

	//
	// A list of video content bundles, represented by {@link ContentBundle} IDs, that are being
	// excluded by the {@code LineItem}.
	//
	ExcludedVideoContentBundleIds []int64 `xml:"excludedVideoContentBundleIds,omitempty" json:"excludedVideoContentBundleIds,omitempty"`
}

type CreativePlaceholder struct {

	//
	// The dimensions that the creative is expected to have. This attribute is required.
	//
	Size *Size `xml:"size,omitempty" json:"size,omitempty"`

	//
	// The native creative template ID.
	//
	// <p>This value is only required if {@link #creativeSizeType} is {@link CreativeSizeType#NATIVE}.
	//
	CreativeTemplateId int64 `xml:"creativeTemplateId,omitempty" json:"creativeTemplateId,omitempty"`

	//
	// The companions that the creative is expected to have. This attribute can only be set if the
	// line item it belongs to has a {@link LineItem#environmentType} of {@link
	// EnvironmentType#VIDEO_PLAYER} or {@link LineItem#roadblockingType} of {@link
	// RoadblockingType#CREATIVE_SET}.
	//
	Companions []*CreativePlaceholder `xml:"companions,omitempty" json:"companions,omitempty"`

	//
	// The set of label frequency caps applied directly to this creative placeholder.
	//
	AppliedLabels []*AppliedLabel `xml:"appliedLabels,omitempty" json:"appliedLabels,omitempty"`

	//
	// Contains the set of labels applied directly to this creative placeholder as well as those
	// inherited from the creative template from which this creative placeholder was instantiated.
	// This field is readonly and is assigned by Google.
	//
	EffectiveAppliedLabels []*AppliedLabel `xml:"effectiveAppliedLabels,omitempty" json:"effectiveAppliedLabels,omitempty"`

	//
	// Expected number of creatives that will be uploaded corresponding to this creative placeholder.
	// This estimate is used to improve the accuracy of forecasting; for example, if label frequency
	// capping limits the number of times a creative may be served.
	//
	ExpectedCreativeCount int32 `xml:"expectedCreativeCount,omitempty" json:"expectedCreativeCount,omitempty"`

	//
	// Describes the types of sizes a creative can be. By default, the creative's size is {@link
	// CreativeSizeType#PIXEL}, which is a dimension based size (width-height pair).
	//
	CreativeSizeType *CreativeSizeType `xml:"creativeSizeType,omitempty" json:"creativeSizeType,omitempty"`

	//
	// The name of the {@link CreativeTargeting} for creatives this placeholder represents.
	//
	// <p>This attribute is optional. Specifying creative targeting here is for forecasting purposes
	// only and has no effect on serving. The same creative targeting should be specified on a {@link
	// LineItemCreativeAssociation} when associating a {@link Creative} with the {@link LineItem}.
	//
	TargetingName string `xml:"targetingName,omitempty" json:"targetingName,omitempty"`

	//
	// Indicate if the expected creative of this placeholder has an AMP only variant.
	//
	// <p>This attribute is optional. It is for forecasting purposes only and has no effect on
	// serving.
	//
	IsAmpOnly bool `xml:"isAmpOnly,omitempty" json:"isAmpOnly,omitempty"`
}

type CurrencyCodeError struct {
	*ApiError

	Reason *CurrencyCodeError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CustomCriteria struct {
	*CustomCriteriaLeaf

	//
	// The {@link CustomTargetingKey#id} of the {@link CustomTargetingKey} object that was created
	// using {@link CustomTargetingService}. This attribute is required.
	//
	KeyId int64 `xml:"keyId,omitempty" json:"keyId,omitempty"`

	//
	// The ids of {@link CustomTargetingValue} objects to target the custom targeting key with id
	// {@link CustomCriteria#keyId}. This attribute is required.
	//
	ValueIds []int64 `xml:"valueIds,omitempty" json:"valueIds,omitempty"`

	//
	// The comparison operator. This attribute is required.
	//
	Operator *CustomCriteria_ComparisonOperator `xml:"operator,omitempty" json:"operator,omitempty"`
}

type CustomCriteriaSet struct {
	*CustomCriteriaNode

	//
	// The logical operator to be applied to {@link CustomCriteriaSet#children}. This attribute is
	// required.
	// <span class="constraint Required">This attribute is required.</span>
	//
	LogicalOperator *CustomCriteriaSet_LogicalOperator `xml:"logicalOperator,omitempty" json:"logicalOperator,omitempty"`

	//
	// The custom criteria. This attribute is required.
	//
	Children []*CustomCriteriaNode `xml:"children,omitempty" json:"children,omitempty"`
}

type CustomFieldValue struct {
	*BaseCustomFieldValue

	//
	// The value for this field. The appropriate type of {@code Value} is determined by the {@link
	// CustomField#dataType} of the {@code CustomField} that this conforms to.
	//
	// <table>
	// <tr><th>{@link CustomFieldDataType}</th><th>{@link Value} type</th></tr>
	// <tr><td>{@link CustomFieldDataType#STRING STRING}</td><td>{@link TextValue}</td></tr>
	// <tr><td>{@link CustomFieldDataType#NUMBER NUMBER}</td><td>{@link NumberValue}</td></tr>
	// <tr><td>{@link CustomFieldDataType#TOGGLE TOGGLE}</td><td>{@link BooleanValue}</td></tr>
	// </table>
	//
	Value *_Value `xml:"value,omitempty" json:"value,omitempty"`
}

type CustomFieldValueError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *CustomFieldValueError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CmsMetadataCriteria struct {
	*CustomCriteriaLeaf

	//
	// The comparison operator. This attribute is required.
	//
	Operator *CmsMetadataCriteria_ComparisonOperator `xml:"operator,omitempty" json:"operator,omitempty"`

	//
	// The ids of {@link CmsMetadataValue} objects used to target CMS metadata. This attribute is
	// required.
	//
	CmsMetadataValueIds []int64 `xml:"cmsMetadataValueIds,omitempty" json:"cmsMetadataValueIds,omitempty"`
}

type CustomTargetingError struct {
	*ApiError

	Reason *CustomTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CustomCriteriaLeaf struct {
	*CustomCriteriaNode
}

type CustomCriteriaNode struct {
}

type AudienceSegmentCriteria struct {
	*CustomCriteriaLeaf

	//
	// The comparison operator. This attribute is required.
	//
	Operator *AudienceSegmentCriteria_ComparisonOperator `xml:"operator,omitempty" json:"operator,omitempty"`

	//
	// The ids of {@link AudienceSegment} objects used to target audience segments. This attribute is
	// required.
	//
	AudienceSegmentIds []int64 `xml:"audienceSegmentIds,omitempty" json:"audienceSegmentIds,omitempty"`
}

type Date struct {

	//
	// Year (e.g., 2009)
	//
	Year int32 `xml:"year,omitempty" json:"year,omitempty"`

	//
	// Month (1..12)
	//
	Month int32 `xml:"month,omitempty" json:"month,omitempty"`

	//
	// Day (1..31)
	//
	Day int32 `xml:"day,omitempty" json:"day,omitempty"`
}

type DateTime struct {
	Date soap.XSDDate `xml:"date,omitempty" json:"date,omitempty"`

	Hour int32 `xml:"hour,omitempty" json:"hour,omitempty"`

	Minute int32 `xml:"minute,omitempty" json:"minute,omitempty"`

	Second int32 `xml:"second,omitempty" json:"second,omitempty"`

	TimeZoneId string `xml:"timeZoneId,omitempty" json:"timeZoneId,omitempty"`
}

type DateTimeRange struct {

	//
	// The start date time of this range. This field is optional and if it is not set then there is no
	// lower bound on the date time range. If this field is not set then {@code endDateTime} must be
	// specified.
	//
	StartDateTime soap.XSDDateTime `xml:"startDateTime,omitempty" json:"startDateTime,omitempty"`

	//
	// The end date time of this range. This field is optional and if it is not set then there is no
	// upper bound on the date time range. If this field is not set then {@code startDateTime} must be
	// specified.
	//
	EndDateTime soap.XSDDateTime `xml:"endDateTime,omitempty" json:"endDateTime,omitempty"`
}

type DateTimeRangeTargeting struct {
	TargetedDateTimeRanges []*DateTimeRange `xml:"targetedDateTimeRanges,omitempty" json:"targetedDateTimeRanges,omitempty"`
}

type DateTimeRangeTargetingError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *DateTimeRangeTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type DateTimeValue struct {
	*_Value

	//
	// The {@code DateTime} value.
	//
	Value soap.XSDDateTime `xml:"value,omitempty" json:"value,omitempty"`
}

type DateValue struct {
	*_Value

	//
	// The {@code Date} value.
	//
	Value soap.XSDDate `xml:"value,omitempty" json:"value,omitempty"`
}

type DayPart struct {

	//
	// Day of the week the target applies to. This field is required.
	//
	DayOfWeek *DayOfWeek `xml:"dayOfWeek,omitempty" json:"dayOfWeek,omitempty"`

	//
	// Represents the start time of the targeted period (inclusive).
	//
	StartTime *TimeOfDay `xml:"startTime,omitempty" json:"startTime,omitempty"`

	//
	// Represents the end time of the targeted period (exclusive).
	//
	EndTime *TimeOfDay `xml:"endTime,omitempty" json:"endTime,omitempty"`
}

type DayPartTargeting struct {

	//
	// Specifies days of the week and times at which a {@code LineItem} will be delivered.
	//
	// <p>If targeting all days and times, this value will be ignored.
	//
	DayParts []*DayPart `xml:"dayParts,omitempty" json:"dayParts,omitempty"`

	//
	// Specifies the time zone to be used for delivering {@link LineItem} objects. This attribute is
	// optional and defaults to {@link DeliveryTimeZone#BROWSER}.
	//
	// <p>Setting this has no effect if targeting all days and times.
	//
	TimeZone *DeliveryTimeZone `xml:"timeZone,omitempty" json:"timeZone,omitempty"`
}

type DayPartTargetingError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *DayPartTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type DealError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *DealError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type DeliveryData struct {

	//
	// Clicks or impressions delivered for the last 7 days.
	//
	Units []int64 `xml:"units,omitempty" json:"units,omitempty"`
}

type DeliveryIndicator struct {

	//
	// How much the {@code LineItem} was expected to deliver as a percentage of
	// {@link LineItem#primaryGoal}.
	//
	ExpectedDeliveryPercentage float64 `xml:"expectedDeliveryPercentage,omitempty" json:"expectedDeliveryPercentage,omitempty"`

	//
	// How much the line item actually delivered as a percentage of
	// {@link LineItem#primaryGoal}.
	//
	ActualDeliveryPercentage float64 `xml:"actualDeliveryPercentage,omitempty" json:"actualDeliveryPercentage,omitempty"`
}

type DeviceCapability struct {
	*Technology
}

type DeviceCapabilityTargeting struct {

	//
	// Device capabilities that are being targeted by the {@link LineItem}.
	//
	TargetedDeviceCapabilities []*Technology `xml:"targetedDeviceCapabilities,omitempty" json:"targetedDeviceCapabilities,omitempty"`

	//
	// Device capabilities that are being excluded by the {@link LineItem}.
	//
	ExcludedDeviceCapabilities []*Technology `xml:"excludedDeviceCapabilities,omitempty" json:"excludedDeviceCapabilities,omitempty"`
}

type DeviceCategory struct {
	*Technology
}

type DeviceCategoryTargeting struct {

	//
	// Device categories that are being targeted by the {@link LineItem}.
	//
	TargetedDeviceCategories []*Technology `xml:"targetedDeviceCategories,omitempty" json:"targetedDeviceCategories,omitempty"`

	//
	// Device categories that are being excluded by the {@link LineItem}.
	//
	ExcludedDeviceCategories []*Technology `xml:"excludedDeviceCategories,omitempty" json:"excludedDeviceCategories,omitempty"`
}

type DeviceManufacturer struct {
	*Technology
}

type DeviceManufacturerTargeting struct {

	//
	// Indicates whether device manufacturers should be targeted or excluded. This attribute is
	// optional and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Device manufacturers that are being targeted or excluded by the {@link LineItem}.
	//
	DeviceManufacturers []*Technology `xml:"deviceManufacturers,omitempty" json:"deviceManufacturers,omitempty"`
}

type DropDownCustomFieldValue struct {
	*BaseCustomFieldValue

	//
	// The {@link CustomFieldOption#id ID} of the {@link CustomFieldOption} for this value.
	//
	CustomFieldOptionId int64 `xml:"customFieldOptionId,omitempty" json:"customFieldOptionId,omitempty"`
}

type EntityChildrenLimitReachedError struct {
	*ApiError

	Reason *EntityChildrenLimitReachedError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type EntityLimitReachedError struct {
	*ApiError

	Reason *EntityLimitReachedError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ExchangeRateError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ExchangeRateError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FeatureError struct {
	*ApiError

	Reason *FeatureError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FieldPathElement struct {

	//
	// The name of a field in lower camelcase. (e.g. "biddingStrategy")
	//
	Field string `xml:"field,omitempty" json:"field,omitempty"`

	//
	// For list fields, this is a 0-indexed position in the list. Null for non-list fields.
	//
	Index int32 `xml:"index,omitempty" json:"index,omitempty"`
}

type ForecastError struct {
	*ApiError

	//
	// The reason for the forecast error.
	//
	Reason *ForecastError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FrequencyCap struct {

	//
	// The maximum number of impressions than can be served to a user within a specified time period.
	//
	MaxImpressions int32 `xml:"maxImpressions,omitempty" json:"maxImpressions,omitempty"`

	//
	// The number of {@code FrequencyCap#timeUnit} to represent the total time period.
	//
	NumTimeUnits int32 `xml:"numTimeUnits,omitempty" json:"numTimeUnits,omitempty"`

	//
	// The unit of time for specifying the time period.
	//
	TimeUnit *TimeUnit `xml:"timeUnit,omitempty" json:"timeUnit,omitempty"`
}

type FrequencyCapError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *FrequencyCapError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type GenericTargetingError struct {
	*ApiError

	Reason *GenericTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type GeoTargeting struct {

	//
	// The geographical locations being targeted by the {@link LineItem}.
	//
	TargetedLocations []*Location `xml:"targetedLocations,omitempty" json:"targetedLocations,omitempty"`

	//
	// The geographical locations being excluded by the {@link LineItem}.
	//
	ExcludedLocations []*Location `xml:"excludedLocations,omitempty" json:"excludedLocations,omitempty"`
}

type GeoTargetingError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *GeoTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type Goal struct {

	//
	// The type of the goal for the {@code LineItem}. It defines the period over which the goal for
	// {@code LineItem} should be reached.
	//
	GoalType *GoalType `xml:"goalType,omitempty" json:"goalType,omitempty"`

	//
	// The type of the goal unit for the {@code LineItem}.
	//
	UnitType *UnitType `xml:"unitType,omitempty" json:"unitType,omitempty"`

	//
	// If this is a primary goal, it represents the number or percentage of impressions or clicks that
	// will be reserved for the {@code LineItem}. If the line item is of type {@link
	// LineItemType#SPONSORSHIP}, it represents the percentage of available impressions reserved. If
	// the line item is of type {@link LineItemType#BULK} or {@link LineItemType#PRICE_PRIORITY}, it
	// represents the number of remaining impressions reserved. If the line item is of type {@link
	// LineItemType#NETWORK} or {@link LineItemType#HOUSE}, it represents the percentage of remaining
	// impressions reserved.
	//
	// <p>If this is a secondary goal, it represents the number of impressions or conversions that the
	// line item will stop serving at if reached. For valid line item types, see {@link
	// LineItem#secondaryGoals}.
	//
	Units int64 `xml:"units,omitempty" json:"units,omitempty"`
}

type GrpSettings struct {

	//
	// Specifies the minimum target age (in years) of the {@link LineItem}. This field is only
	// applicable if {@link #provider} is not null.
	//
	MinTargetAge int64 `xml:"minTargetAge,omitempty" json:"minTargetAge,omitempty"`

	//
	// Specifies the maximum target age (in years) of the {@link LineItem}. This field is only
	// applicable if {@link #provider} is not null.
	//
	MaxTargetAge int64 `xml:"maxTargetAge,omitempty" json:"maxTargetAge,omitempty"`

	//
	// Specifies the target gender of the {@link LineItem}. This field is only applicable if {@link
	// #provider} is not null.
	//
	TargetGender *GrpTargetGender `xml:"targetGender,omitempty" json:"targetGender,omitempty"`

	//
	// Specifies the GRP provider of the {@link LineItem}.
	//
	Provider *GrpProvider `xml:"provider,omitempty" json:"provider,omitempty"`

	//
	// Specifies the impression goal for the given target demographic. This field is only applicable
	// if {@link #provider} is not null and demographics-based goal is selected by the user. If this
	// field is set, {@link LineItem#primaryGoal} will have its {@link Goal#units} value set by Google
	// to represent the estimated total quantity.
	//
	TargetImpressionGoal int64 `xml:"targetImpressionGoal,omitempty" json:"targetImpressionGoal,omitempty"`

	//
	// Estimate for the in-target ratio given the line item's audience targeting. This field is only
	// applicable if {@link #provider} is Nielsen, {@link LineItem#primaryGoal#unitType} is in-target
	// impressions, and {@link LineItem#CostType} is in-target CPM. This field determines the
	// in-target ratio to use for pacing Nielsen line items before Nielsen reporting data is
	// available. Represented as a milli percent, so 55.7% becomes 55700.
	//
	InTargetRatioEstimateMilliPercent int64 `xml:"inTargetRatioEstimateMilliPercent,omitempty" json:"inTargetRatioEstimateMilliPercent,omitempty"`

	//
	// Specifies which pacing computation to apply in pacing to impressions from connected devices.
	// This field is required if {@code enableNielsenCoViewingSupport} is true.
	//
	NielsenCtvPacingType *NielsenCtvPacingType `xml:"nielsenCtvPacingType,omitempty" json:"nielsenCtvPacingType,omitempty"`

	//
	// Specifies whether to use Google or Nielsen device breakdown in Nielsen Line Item auto pacing.
	//
	PacingDeviceCategorizationType *PacingDeviceCategorizationType `xml:"pacingDeviceCategorizationType,omitempty" json:"pacingDeviceCategorizationType,omitempty"`

	ApplyTrueCoview bool `xml:"applyTrueCoview,omitempty" json:"applyTrueCoview,omitempty"`
}

type GrpSettingsError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *GrpSettingsError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InternalApiError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *InternalApiError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InventorySizeTargeting struct {

	//
	// Whether the inventory sizes should be targeted or excluded.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// A list of {@link TargetedSizeDto}s.
	//
	TargetedSizes []*TargetedSize `xml:"targetedSizes,omitempty" json:"targetedSizes,omitempty"`
}

type InventoryTargeting struct {

	//
	// A list of targeted {@link AdUnitTargeting}.
	//
	TargetedAdUnits []*AdUnitTargeting `xml:"targetedAdUnits,omitempty" json:"targetedAdUnits,omitempty"`

	//
	// A list of excluded {@link AdUnitTargeting}.
	//
	ExcludedAdUnits []*AdUnitTargeting `xml:"excludedAdUnits,omitempty" json:"excludedAdUnits,omitempty"`

	//
	// A list of targeted {@link Placement} ids.
	//
	TargetedPlacementIds []int64 `xml:"targetedPlacementIds,omitempty" json:"targetedPlacementIds,omitempty"`
}

type InventoryTargetingError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *InventoryTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InventoryUrl struct {
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`
}

type InventoryUrlTargeting struct {
	TargetedUrls []*InventoryUrl `xml:"targetedUrls,omitempty" json:"targetedUrls,omitempty"`

	ExcludedUrls []*InventoryUrl `xml:"excludedUrls,omitempty" json:"excludedUrls,omitempty"`
}

type LabelEntityAssociationError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *LabelEntityAssociationError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LineItemError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *LineItemError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LineItemFlightDateError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *LineItemFlightDateError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LineItemOperationError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *LineItemOperationError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type Location struct {

	//
	// Uniquely identifies each {@code Location}.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// The location type for this geographical entity (ex. "COUNTRY", "CITY", "STATE", "COUNTY", etc.)
	//
	Type_ string `xml:"type,omitempty" json:"type,omitempty"`

	//
	// The nearest location parent's ID for this geographical entity.
	//
	CanonicalParentId int32 `xml:"canonicalParentId,omitempty" json:"canonicalParentId,omitempty"`

	//
	// The localized name of the geographical entity.
	//
	DisplayName string `xml:"displayName,omitempty" json:"displayName,omitempty"`
}

type MobileApplicationTargeting struct {

	//
	// The {@link MobileApplication#applicationId IDs} that are being targeted or excluded by the
	// {@link LineItem}.
	//
	MobileApplicationIds []int64 `xml:"mobileApplicationIds,omitempty" json:"mobileApplicationIds,omitempty"`

	//
	// Indicates whether mobile apps should be targeted or excluded. This attribute is optional and
	// defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`
}

type MobileApplicationTargetingError struct {
	*ApiError

	Reason *MobileApplicationTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type MobileCarrier struct {
	*Technology
}

type MobileCarrierTargeting struct {

	//
	// Indicates whether mobile carriers should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Mobile carriers that are being targeted or excluded by the {@link LineItem}.
	//
	MobileCarriers []*Technology `xml:"mobileCarriers,omitempty" json:"mobileCarriers,omitempty"`
}

type MobileDevice struct {
	*Technology

	//
	// Manufacturer Id.
	//
	ManufacturerCriterionId int64 `xml:"manufacturerCriterionId,omitempty" json:"manufacturerCriterionId,omitempty"`
}

type MobileDeviceSubmodel struct {
	*Technology

	//
	// The mobile device id.
	//
	MobileDeviceCriterionId int64 `xml:"mobileDeviceCriterionId,omitempty" json:"mobileDeviceCriterionId,omitempty"`

	//
	// The device manufacturer id.
	//
	DeviceManufacturerCriterionId int64 `xml:"deviceManufacturerCriterionId,omitempty" json:"deviceManufacturerCriterionId,omitempty"`
}

type MobileDeviceSubmodelTargeting struct {

	//
	// Mobile device submodels that are being targeted by the {@link LineItem}.
	//
	TargetedMobileDeviceSubmodels []*Technology `xml:"targetedMobileDeviceSubmodels,omitempty" json:"targetedMobileDeviceSubmodels,omitempty"`

	//
	// Mobile device submodels that are being excluded by the {@link LineItem}.
	//
	ExcludedMobileDeviceSubmodels []*Technology `xml:"excludedMobileDeviceSubmodels,omitempty" json:"excludedMobileDeviceSubmodels,omitempty"`
}

type MobileDeviceTargeting struct {

	//
	// Mobile devices that are being targeted by the {@link LineItem}.
	//
	TargetedMobileDevices []*Technology `xml:"targetedMobileDevices,omitempty" json:"targetedMobileDevices,omitempty"`

	//
	// Mobile devices that are being excluded by the {@link LineItem}.
	//
	ExcludedMobileDevices []*Technology `xml:"excludedMobileDevices,omitempty" json:"excludedMobileDevices,omitempty"`
}

type Money struct {

	//
	// Three letter currency code in string format.
	//
	CurrencyCode string `xml:"currencyCode,omitempty" json:"currencyCode,omitempty"`

	//
	// Money values are always specified in terms of micros which are a millionth
	// of the fundamental currency unit. For US dollars, $1 is 1,000,000 micros.
	//
	MicroAmount int64 `xml:"microAmount,omitempty" json:"microAmount,omitempty"`
}

type NotNullError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *NotNullError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type NumberValue struct {
	*_Value

	//
	// The numeric value represented as a string.
	//
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

type OperatingSystem struct {
	*Technology
}

type OperatingSystemTargeting struct {

	//
	// Indicates whether operating systems should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Operating systems that are being targeted or excluded by the {@link LineItem}.
	//
	OperatingSystems []*Technology `xml:"operatingSystems,omitempty" json:"operatingSystems,omitempty"`
}

type OperatingSystemVersion struct {
	*Technology

	//
	// The operating system major version.
	//
	MajorVersion int32 `xml:"majorVersion,omitempty" json:"majorVersion,omitempty"`

	//
	// The operating system minor version.
	//
	MinorVersion int32 `xml:"minorVersion,omitempty" json:"minorVersion,omitempty"`

	//
	// The operating system micro version.
	//
	MicroVersion int32 `xml:"microVersion,omitempty" json:"microVersion,omitempty"`
}

type OperatingSystemVersionTargeting struct {

	//
	// Operating system versions that are being targeted by the {@link LineItem}.
	//
	TargetedOperatingSystemVersions []*Technology `xml:"targetedOperatingSystemVersions,omitempty" json:"targetedOperatingSystemVersions,omitempty"`

	//
	// Operating system versions that are being excluded by the {@link LineItem}.
	//
	ExcludedOperatingSystemVersions []*Technology `xml:"excludedOperatingSystemVersions,omitempty" json:"excludedOperatingSystemVersions,omitempty"`
}

type ParseError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ParseError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PauseProposalLineItems struct {
	*ProposalLineItemAction

	//
	// Reason to describe why the {@link ProposalLineItem} is being paused.
	//
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PermissionError struct {
	*ApiError

	Reason *PermissionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PrecisionError struct {
	*ApiError

	Reason *PrecisionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PreferredDealError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PreferredDealError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProgrammaticError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProgrammaticError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalActionError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProposalActionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProposalError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalLineItemAction struct {
}

type ProposalLineItemActionError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProposalLineItemActionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalLineItem struct {

	//
	// The unique ID of the {@code ProposalLineItem}.
	// This attribute is read-only.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// The unique ID of the {@link Proposal}, to which the {@code ProposalLineItem} belongs. This
	// attribute is required for creation and then is readonly.
	// <span class="constraint Required">This attribute is required.</span>
	//
	ProposalId int64 `xml:"proposalId,omitempty" json:"proposalId,omitempty"`

	//
	// The name of the {@code ProposalLineItem} which should be unique under the same {@link
	// Proposal}. This attribute has a maximum length of 255 characters. This attribute can be
	// configured as editable after the proposal has been submitted. Please check with your network
	// administrator for editable fields configuration.
	// <span class="constraint Required">This attribute is required.</span>
	//
	Name string `xml:"name,omitempty" json:"name,omitempty"`

	//
	// The date and time at which the line item associated with the {@code ProposalLineItem} is
	// enabled to begin serving. This attribute is optional during creation, but required and must be
	// in the future when it turns into a line item. The {@link DateTime#timeZoneID} is required if
	// start date time is not {@code null}. This attribute becomes readonly once the {@code
	// ProposalLineItem} has started delivering.
	//
	StartDateTime soap.XSDDateTime `xml:"startDateTime,omitempty" json:"startDateTime,omitempty"`

	//
	// The date and time at which the line item associated with the {@code ProposalLineItem} stops
	// beening served. This attribute is optional during creation, but required and must be after the
	// {@link #startDateTime}. The {@link DateTime#timeZoneID} is required if end date time is not
	// {@code null}.
	//
	EndDateTime soap.XSDDateTime `xml:"endDateTime,omitempty" json:"endDateTime,omitempty"`

	//
	// The time zone ID in tz database format (e.g. "America/Los_Angeles") for this {@code
	// ProposalLineItem}. The number of serving days is calculated in this time zone. So if {@link
	// #rateType} is {@link RateType#CPD}, it will affect the cost calculation. The {@link
	// #startDateTime} and {@link #endDateTime} will be returned in this time zone. This attribute is
	// optional and defaults to the network's time zone.
	// This attribute is read-only.
	//
	TimeZoneId string `xml:"timeZoneId,omitempty" json:"timeZoneId,omitempty"`

	//
	// Provides any additional notes that may annotate the {@code ProposalLineItem}. This attribute is
	// optional and has a maximum length of 65,535 characters. This attribute can be configured as
	// editable after the proposal has been submitted. Please check with your network administrator
	// for editable fields configuration.
	//
	InternalNotes string `xml:"internalNotes,omitempty" json:"internalNotes,omitempty"`

	//
	// The archival status of the {@code ProposalLineItem}.
	// This attribute is read-only.
	//
	IsArchived bool `xml:"isArchived,omitempty" json:"isArchived,omitempty"`

	//
	// The goal(i.e. contracted quantity, quantity or limit) that this {@code ProposalLineItem} is
	// associated with, which is used in its pacing and budgeting. {@link Goal#units} must be greater
	// than 0 when the proposal line item turns into a line item, {@link Goal#goalType} and {@link
	// Goal#unitType} are readonly. For a Preferred deal {@code ProposalLineItem}, the goal type can
	// only be {@link GoalType#NONE}.
	// <span class="constraint Required">This attribute is required.</span>
	//
	Goal *Goal `xml:"goal,omitempty" json:"goal,omitempty"`

	//
	// The secondary goals that this {@code ProposalLineItem} is associated with. For a programmatic
	// line item with the properties {@link RateType#CPM} and {@link LineItemType#SPONSORSHIP}, this
	// field will have one goal which describes the impressions cap. For other cases, this field is an
	// empty list.
	//
	SecondaryGoals []*Goal `xml:"secondaryGoals,omitempty" json:"secondaryGoals,omitempty"`

	//
	// The contracted number of daily minimum impressions used for {@link LineItemType#SPONSORSHIP}
	// {@code ProposalLineItem} deals with a rate type of {@link RateType#CPD}.
	//
	// <p>This attribute is required for percentage-based-goal {@link ProposalLineItem proposal line
	// items}. It does not impact ad-serving and is for reporting purposes only.
	//
	ContractedUnitsBought int64 `xml:"contractedUnitsBought,omitempty" json:"contractedUnitsBought,omitempty"`

	//
	// The strategy for delivering ads over the course of the {@code ProposalLineItem}'s duration.
	// This attribute is required. For a Preferred deal {@code ProposalLineItem}, the value can only
	// be {@link DeliveryRateType#FRONTLOADED}.
	//
	DeliveryRateType *DeliveryRateType `xml:"deliveryRateType,omitempty" json:"deliveryRateType,omitempty"`

	//
	// The strategy for serving roadblocked creatives, i.e. instances where multiple creatives must be
	// served together on a single web page. This attribute is optional during creation and defaults
	// to the {@link Product#roadblockingType product's roadblocking type}, or {@link
	// RoadblockingType#ONE_OR_MORE} if not specified by the product.
	//
	RoadblockingType *RoadblockingType `xml:"roadblockingType,omitempty" json:"roadblockingType,omitempty"`

	//
	// The delivery option for companions. This is only valid if the roadblocking type is {@link
	// RoadblockingType#CREATIVE_SET}. The default value for roadblocking creatives is {@link
	// CompanionDeliveryOption#OPTIONAL}. The default value in other cases is {@link
	// CompanionDeliveryOption#UNKNOWN}. Providing something other than {@link
	// CompanionDeliveryOption#UNKNOWN} will cause an error.
	//
	CompanionDeliveryOption *CompanionDeliveryOption `xml:"companionDeliveryOption,omitempty" json:"companionDeliveryOption,omitempty"`

	//
	// The max duration of a video creative associated with this {@code ProposalLineItem} in
	// milliseconds. This attribute is optional, defaults to the {@link Product#videoMaxDuration} on
	// the {@link Product} it was created with, and only meaningful if this is a video proposal line
	// item.
	//
	VideoMaxDuration int64 `xml:"videoMaxDuration,omitempty" json:"videoMaxDuration,omitempty"`

	//
	// The proposal line item's creatives' skippability. This attribute is optional, only applicable
	// for video proposal line items, and defaults to {@link SkippableAdType#NOT_SKIPPABLE}.
	//
	VideoCreativeSkippableAdType *SkippableAdType `xml:"videoCreativeSkippableAdType,omitempty" json:"videoCreativeSkippableAdType,omitempty"`

	//
	// The set of frequency capping units for this {@code ProposalLineItem}. This attribute is
	// optional during creation and defaults to the {@link Product#frequencyCaps product's frequency
	// caps} if {@link Product#allowFrequencyCapsCustomization} is {@code false}.
	//
	FrequencyCaps []*FrequencyCap `xml:"frequencyCaps,omitempty" json:"frequencyCaps,omitempty"`

	//
	// The unique ID of corresponding {@link LineItem}. This will be {@code null} if the {@link
	// Proposal} has not been pushed to Ad Manager.
	// This attribute is read-only.
	//
	DfpLineItemId int64 `xml:"dfpLineItemId,omitempty" json:"dfpLineItemId,omitempty"`

	//
	// The corresponding {@link LineItemType} of the {@code ProposalLineItem}. For a programmatic
	// {@code ProposalLineItem}, the value can only be one of:
	//
	// <ul>
	// <li>{@link LineItemType#SPONSORSHIP}
	// <li>{@link LineItemType#STANDARD}
	// <li>{@link LineItemType#PREFERRED_DEAL}
	// </ul>
	// <span class="constraint Required">This attribute is required.</span>
	//
	LineItemType *LineItemType `xml:"lineItemType,omitempty" json:"lineItemType,omitempty"`

	//
	// The priority for the corresponding {@link LineItem} of the {@code ProposalLineItem}. This
	// attribute is optional during creation and defaults to the default priority of the {@link
	// #lineItemType}. For forecasting, this attribute is optional and has a default value assigned by
	// Google. See {@link LineItem#priority} for more information.
	//
	LineItemPriority int32 `xml:"lineItemPriority,omitempty" json:"lineItemPriority,omitempty"`

	//
	// The method used for billing the {@code ProposalLineItem}.
	// This attribute is read-only.
	// <span class="constraint Required">This attribute is required.</span>
	//
	RateType *RateType `xml:"rateType,omitempty" json:"rateType,omitempty"`

	//
	// Details about the creatives that are expected to serve through the {@code ProposalLineItem}.
	// This attribute is optional during creation and defaults to the {@link
	// Product#creativePlaceholders product's creative placeholders}.
	// <span class="constraint Required">This attribute is required.</span>
	//
	CreativePlaceholders []*CreativePlaceholder `xml:"creativePlaceholders,omitempty" json:"creativePlaceholders,omitempty"`

	//
	// Contains the targeting criteria for the {@code ProposalLineItem}.
	// <span class="constraint Required">This attribute is required.</span>
	//
	Targeting *Targeting `xml:"targeting,omitempty" json:"targeting,omitempty"`

	//
	// The values of the custom fields associated with the {@code ProposalLineItem}. This attribute is
	// optional. This attribute can be configured as editable after the proposal has been submitted.
	// Please check with your network administrator for editable fields configuration.
	//
	CustomFieldValues []*BaseCustomFieldValue `xml:"customFieldValues,omitempty" json:"customFieldValues,omitempty"`

	//
	// The set of labels applied directly to the {@code ProposalLineItem}. This attribute is optional.
	//
	AppliedLabels []*AppliedLabel `xml:"appliedLabels,omitempty" json:"appliedLabels,omitempty"`

	//
	// Contains the set of labels applied directly to the proposal as well as those inherited ones. If
	// a label has been negated, only the negated label is returned.
	// This attribute is read-only.
	//
	EffectiveAppliedLabels []*AppliedLabel `xml:"effectiveAppliedLabels,omitempty" json:"effectiveAppliedLabels,omitempty"`

	//
	// If a line item has a series of competitive exclusions on it, it could be blocked from serving
	// with line items from the same advertiser. Setting this to {@code true} will allow line items
	// from the same advertiser to serve regardless of the other competitive exclusion labels being
	// applied.
	//
	// <p>This attribute is optional and defaults to false.
	//
	DisableSameAdvertiserCompetitiveExclusion bool `xml:"disableSameAdvertiserCompetitiveExclusion,omitempty" json:"disableSameAdvertiserCompetitiveExclusion,omitempty"`

	//
	// Indicates whether this {@code ProposalLineItem} has been sold.
	// This attribute is read-only.
	//
	IsSold bool `xml:"isSold,omitempty" json:"isSold,omitempty"`

	//
	// The amount of money to spend per impression or click in proposal currency. It supports
	// precision of 4 decimal places in terms of the fundamental currency unit, so the {@link
	// Money#getAmountInMicros} must be multiples of 100. It doesn't include agency commission.
	//
	// <p>For example, if {@link Proposal#currencyCode} is 'USD', then $123.4567 could be represented
	// as 123456700, but further precision is not supported.
	//
	// <p>At least one of the two fields {@link ProposalLineItem#netRate},and {@link
	// ProposalLineItem#netCost} is required.
	//
	NetRate *Money `xml:"netRate,omitempty" json:"netRate,omitempty"`

	//
	// The cost of the {@code ProposalLineItem} in proposal currency. It supports precision of 2
	// decimal places in terms of the fundamental currency unit, so the {@link
	// Money#getAmountInMicros} must be multiples of 10000. It doesn't include agency commission.
	//
	// <p>For example, if {@link Proposal#currencyCode} is 'USD', then $123.45 could be represented as
	// 123450000, but further precision is not supported.
	//
	// <p>At least one of the two fields {@link ProposalLineItem#netRate} and {@link
	// ProposalLineItem#netCost} is required.
	//
	NetCost *Money `xml:"netCost,omitempty" json:"netCost,omitempty"`

	//
	// Indicates how well the line item generated from this proposal line item has been performing.
	// This will be {@code null} if the delivery indicator information is not available due to one of
	// the following reasons:
	//
	// <ol>
	// <li>The proposal line item has not pushed to Ad Manager.
	// <li>The line item is not delivering.
	// <li>The line item has an unlimited goal or cap.
	// <li>The line item has a percentage based goal or cap.
	// </ol>
	// This attribute is read-only.
	//
	DeliveryIndicator *DeliveryIndicator `xml:"deliveryIndicator,omitempty" json:"deliveryIndicator,omitempty"`

	//
	// Delivery data provides the number of clicks or impressions delivered for the {@link LineItem}
	// generated from this proposal line item in the last 7 days. This will be {@code null} if the
	// delivery data cannot be computed due to one of the following reasons:
	//
	// <ol>
	// <li>The proposal line item has not pushed to Ad Manager.
	// <li>The line item is not deliverable.
	// <li>The line item has completed delivering more than 7 days ago.
	// <li>The line item has an absolute-based goal. {@link ProposalLineItem#deliveryIndicator}
	// should be used to track its progress in this case.
	// This attribute is read-only.
	//
	DeliveryData *DeliveryData `xml:"deliveryData,omitempty" json:"deliveryData,omitempty"`

	//
	// The status of the {@link LineItem} generated from this proposal line item. This will be {@code
	// null} if the proposal line item has not pushed to Ad Manager.
	// This attribute is read-only.
	//
	ComputedStatus *ComputedStatus `xml:"computedStatus,omitempty" json:"computedStatus,omitempty"`

	//
	// The date and time this {@code ProposalLineItem} was last modified.
	//
	// <p>This attribute is assigned by Google when a {@code ProposalLineItem} is updated.
	// This attribute is read-only.
	//
	LastModifiedDateTime soap.XSDDateTime `xml:"lastModifiedDateTime,omitempty" json:"lastModifiedDateTime,omitempty"`

	//
	// The reservation status of the {@link ProposalLineItem}.
	// This attribute is read-only.
	//
	ReservationStatus *ReservationStatus `xml:"reservationStatus,omitempty" json:"reservationStatus,omitempty"`

	//
	// The last {@link DateTime} when the {@link ProposalLineItem} reserved inventory.
	// This attribute is read-only.
	//
	LastReservationDateTime soap.XSDDateTime `xml:"lastReservationDateTime,omitempty" json:"lastReservationDateTime,omitempty"`

	//
	// The environment that the {@code ProposalLineItem} is targeting. The default value is {@link
	// EnvironmentType#BROWSER}. If this value is {@link EnvironmentType#VIDEO_PLAYER}, then this
	// {@code ProposalLineItem} can only target {@link AdUnit ad units} that have {@link AdUnitSize
	// sizes} whose {@link AdUnitSize#environmentType} is also {@link EnvironmentType#VIDEO_PLAYER}.
	//
	// <p>This field is read-only and set to {@link Product#environmentType} of the product this
	// proposal line item was created from.
	//
	EnvironmentType *EnvironmentType `xml:"environmentType,omitempty" json:"environmentType,omitempty"`

	//
	// The set of {@link AllowedFormats} that this proposal line item can have. If the set is empty,
	// this proposal line item allows all formats.
	//
	AllowedFormats []*AllowedFormats `xml:"allowedFormats,omitempty" json:"allowedFormats,omitempty"`

	//
	// Whether or not the {@link Proposal} for this {@code ProposalLineItem} is a programmatic deal.
	// This attribute is populated from {@link Proposal#isProgrammatic}.
	// This attribute is read-only.
	//
	IsProgrammatic bool `xml:"isProgrammatic,omitempty" json:"isProgrammatic,omitempty"`

	//
	// Additional terms shown to the buyer in Marketplace.
	//
	AdditionalTerms string `xml:"additionalTerms,omitempty" json:"additionalTerms,omitempty"`

	//
	// Indicates the {@link ProgrammaticCreativeSource} of the programmatic line item.
	//
	ProgrammaticCreativeSource *ProgrammaticCreativeSource `xml:"programmaticCreativeSource,omitempty" json:"programmaticCreativeSource,omitempty"`

	//
	// Contains the information for a proposal line item which has a target GRP demographic.
	//
	GrpSettings *GrpSettings `xml:"grpSettings,omitempty" json:"grpSettings,omitempty"`

	//
	// The estimated minimum impressions that should be delivered for a proposal line item.
	//
	EstimatedMinimumImpressions int64 `xml:"estimatedMinimumImpressions,omitempty" json:"estimatedMinimumImpressions,omitempty"`

	//
	// Contains third party measurement settings for cross-sell Partners
	//
	ThirdPartyMeasurementSettings *ThirdPartyMeasurementSettings `xml:"thirdPartyMeasurementSettings,omitempty" json:"thirdPartyMeasurementSettings,omitempty"`

	//
	// Makegood info for this proposal line item. Immutable once created.
	//
	// <p>Null if this proposal line item is not a makegood.
	//
	MakegoodInfo *ProposalLineItemMakegoodInfo `xml:"makegoodInfo,omitempty" json:"makegoodInfo,omitempty"`

	//
	// Whether this proposal line item has an associated makegood.
	// This attribute is read-only.
	//
	HasMakegood bool `xml:"hasMakegood,omitempty" json:"hasMakegood,omitempty"`

	//
	// Whether a new makegood associated with this line item can be created.
	// This attribute is read-only.
	//
	CanCreateMakegood bool `xml:"canCreateMakegood,omitempty" json:"canCreateMakegood,omitempty"`

	//
	// The {@link NegotiationRole} that paused the proposal line item, i.e. {@link
	// NegotiationRole#seller} or {@link NegotiationRole#buyer}, or {@code null} when the proposal is
	// not paused.
	// This attribute is read-only.
	//
	PauseRole *NegotiationRole `xml:"pauseRole,omitempty" json:"pauseRole,omitempty"`

	//
	// The reason for pausing the {@link ProposalLineItem}, provided by the {@link pauseRole}. It is
	// {@code null} when the {@link ProposalLineItem} is not paused.
	// This attribute is read-only.
	//
	PauseReason string `xml:"pauseReason,omitempty" json:"pauseReason,omitempty"`
}

type ProposalLineItemError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProposalLineItemError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalLineItemMakegoodError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProposalLineItemMakegoodError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalLineItemMakegoodInfo struct {

	//
	// The ID of the original proposal line item on which this makegood is based.
	// This attribute is read-only.
	//
	OriginalProposalLineItemId int64 `xml:"originalProposalLineItemId,omitempty" json:"originalProposalLineItemId,omitempty"`

	//
	// The publisher-provided reason why this makegood was initiated. This is free form text.
	//
	// <p>The following predefined values can be used to render predefined options in the UI.
	//
	// <p>UNDERDELIVERY: 'Impression underdelivery', SECONDARY_DELIVERY_TERMS: 'Did not meet secondary
	// delivery terms ', PERFORMANCE: 'Performance issues',
	//
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalLineItemPage struct {

	//
	// The collection of proposal line items contained within this page.
	//
	Results []*ProposalLineItem `xml:"results,omitempty" json:"results,omitempty"`

	//
	// The absolute index in the total result set on which this page begins.
	//
	StartIndex int32 `xml:"startIndex,omitempty" json:"startIndex,omitempty"`

	//
	// The size of the total result set to which this page belongs.
	//
	TotalResultSetSize int32 `xml:"totalResultSetSize,omitempty" json:"totalResultSetSize,omitempty"`
}

type ProposalLineItemProgrammaticError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProposalLineItemProgrammaticError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PublisherQueryLanguageContextError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PublisherQueryLanguageContextError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PublisherQueryLanguageSyntaxError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PublisherQueryLanguageSyntaxError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type QuotaError struct {
	*ApiError

	Reason *QuotaError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RangeError struct {
	*ApiError

	Reason *RangeError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ReleaseProposalLineItems struct {
	*ProposalLineItemAction
}

type RequestPlatformTargeting struct {
	TargetedRequestPlatforms []*RequestPlatform `xml:"targetedRequestPlatforms,omitempty" json:"targetedRequestPlatforms,omitempty"`
}

type RequestPlatformTargetingError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *RequestPlatformTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequiredCollectionError struct {
	*ApiError

	Reason *RequiredCollectionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequiredError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *RequiredError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequiredNumberError struct {
	*ApiError

	Reason *RequiredNumberError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ReservationDetailsError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ReservationDetailsError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ReserveProposalLineItems struct {
	*ProposalLineItemAction

	AllowOverbook bool `xml:"allowOverbook,omitempty" json:"allowOverbook,omitempty"`
}

type ResumeProposalLineItems struct {
	*ProposalLineItemAction
}

type AudienceSegmentError struct {
	*ApiError

	Reason *AudienceSegmentError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ServerError struct {
	*ApiError

	Reason *ServerError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type SetValue struct {
	*_Value

	//
	// The values. They must all be the same type of {@code Value} and not contain duplicates.
	//
	Values []*_Value `xml:"values,omitempty" json:"values,omitempty"`
}

type Size struct {

	//
	// The width of the {@link AdUnit}, {@link LineItem} or {@link Creative}.
	//
	Width int32 `xml:"width,omitempty" json:"width,omitempty"`

	//
	// The height of the {@link AdUnit}, {@link LineItem} or {@link Creative}.
	//
	Height int32 `xml:"height,omitempty" json:"height,omitempty"`

	//
	// Whether this size represents an aspect ratio.
	//
	IsAspectRatio bool `xml:"isAspectRatio,omitempty" json:"isAspectRatio,omitempty"`
}

type SoapRequestHeader struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 RequestHeader"`

	//
	// The network code to use in the context of a request.
	//
	NetworkCode string `xml:"networkCode,omitempty" json:"networkCode,omitempty"`

	//
	// The name of client library application.
	//
	ApplicationName string `xml:"applicationName,omitempty" json:"applicationName,omitempty"`
}

type SoapResponseHeader struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 ResponseHeader"`

	RequestId string `xml:"requestId,omitempty" json:"requestId,omitempty"`

	ResponseTime int64 `xml:"responseTime,omitempty" json:"responseTime,omitempty"`
}

type Statement struct {

	//
	// Holds the query in PQL syntax. The syntax is:<br>
	// <code>[WHERE <condition> {[AND | OR] <condition> ...}]</code><br>
	// <code>[ORDER BY <property> [ASC | DESC]]</code><br>
	// <code>[LIMIT {[<offset>,] <count>} | {<count> OFFSET <offset>}]</code><br>
	// <p>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <value></code><br>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <bind variable></code><br>
	// <code><condition> := <property> IN <list></code><br>
	// <code><condition> := <property> IS NULL</code><br>
	// <code><condition> := <property> LIKE <wildcard%match></code><br>
	// <code><bind variable> := :<name></code><br>
	// </p>
	//
	Query string `xml:"query,omitempty" json:"query,omitempty"`

	//
	// Holds keys and values for bind variables and their values. The key is the
	// name of the bind variable. The value is the literal value of the variable.
	// <p>
	// In the example {@code "WHERE status = :bindStatus ORDER BY id LIMIT 30"},
	// the bind variable, represented by {@code :bindStatus} is named {@code
	// bindStatus}, which would also be the parameter map key. The bind variable's
	// value would be represented by a parameter map value of type
	// {@link TextValue}. The final result, for example, would be an entry of
	// {@code "bindStatus" => StringParam("ACTIVE")}.
	// </p>
	//
	Values []*String_ValueMapEntry `xml:"values,omitempty" json:"values,omitempty"`
}

type StatementError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *StatementError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type StringFormatError struct {
	*ApiError

	Reason *StringFormatError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type StringLengthError struct {
	*ApiError

	Reason *StringLengthError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type String_ValueMapEntry struct {
	Key string `xml:"key,omitempty" json:"key,omitempty"`

	Value *_Value `xml:"value,omitempty" json:"value,omitempty"`
}

type TargetedSize struct {
	Size *Size `xml:"size,omitempty" json:"size,omitempty"`
}

type Targeting struct {

	//
	// Specifies what geographical locations are targeted by the {@link LineItem}. This attribute is
	// optional.
	//
	GeoTargeting *GeoTargeting `xml:"geoTargeting,omitempty" json:"geoTargeting,omitempty"`

	//
	// Specifies what inventory is targeted by the {@link LineItem}. This attribute is required. The
	// line item must target at least one ad unit or placement.
	//
	InventoryTargeting *InventoryTargeting `xml:"inventoryTargeting,omitempty" json:"inventoryTargeting,omitempty"`

	//
	// Specifies the days of the week and times that are targeted by the {@link LineItem}. This
	// attribute is optional.
	//
	DayPartTargeting *DayPartTargeting `xml:"dayPartTargeting,omitempty" json:"dayPartTargeting,omitempty"`

	//
	// Specifies the dates and time ranges that are targeted by the {@link LineItem}. This attribute
	// is optional.
	//
	DateTimeRangeTargeting *DateTimeRangeTargeting `xml:"dateTimeRangeTargeting,omitempty" json:"dateTimeRangeTargeting,omitempty"`

	//
	// Specifies the browsing technologies that are targeted by the {@link LineItem}. This attribute
	// is optional.
	//
	TechnologyTargeting *TechnologyTargeting `xml:"technologyTargeting,omitempty" json:"technologyTargeting,omitempty"`

	//
	// Specifies the collection of custom criteria that is targeted by the {@link LineItem}.
	//
	// <p>Once the {@link LineItem} is updated or modified with custom targeting, the server may
	// return a normalized, but equivalent representation of the custom targeting expression.
	//
	// <p>{@code customTargeting} will have up to three levels of expressions including itself.
	//
	// <p>The top level {@code CustomCriteriaSet} i.e. the {@code customTargeting} object can only
	// contain a {@link CustomCriteriaSet.LogicalOperator#OR} of all its children.
	//
	// <p>The second level of {@code CustomCriteriaSet} objects can only contain {@link
	// CustomCriteriaSet.LogicalOperator#AND} of all their children. If a {@link CustomCriteria} is
	// placed on this level, the server will wrap it in a {@link CustomCriteriaSet}.
	//
	// <p>The third level can only comprise of {@link CustomCriteria} objects.
	//
	// <p>The resulting custom targeting tree would be of the form: <br>
	// <img
	// src="https://chart.apis.google.com/chart?cht=gv&chl=digraph{customTargeting_LogicalOperator_OR-%3ECustomCriteriaSet_LogicalOperator_AND_1-%3ECustomCriteria_1;CustomCriteriaSet_LogicalOperator_AND_1-%3Eellipsis1;customTargeting_LogicalOperator_OR-%3Eellipsis2;ellipsis1[label=%22...%22,shape=none,fontsize=32];ellipsis2[label=%22...%22,shape=none,fontsize=32]}&chs=450x200"/>
	//
	CustomTargeting *CustomCriteriaSet `xml:"customTargeting,omitempty" json:"customTargeting,omitempty"`

	//
	// Specifies the domains or subdomains that are targeted or excluded by the {@link LineItem}.
	// Users visiting from an IP address associated with those domains will be targeted or excluded.
	// This attribute is optional.
	//
	UserDomainTargeting *UserDomainTargeting `xml:"userDomainTargeting,omitempty" json:"userDomainTargeting,omitempty"`

	//
	// Specifies the video categories and individual videos targeted by the {@link LineItem}.
	//
	ContentTargeting *ContentTargeting `xml:"contentTargeting,omitempty" json:"contentTargeting,omitempty"`

	//
	// Specifies targeting against video position types.
	//
	VideoPositionTargeting *VideoPositionTargeting `xml:"videoPositionTargeting,omitempty" json:"videoPositionTargeting,omitempty"`

	//
	// Specifies targeting against mobile applications.
	//
	MobileApplicationTargeting *MobileApplicationTargeting `xml:"mobileApplicationTargeting,omitempty" json:"mobileApplicationTargeting,omitempty"`

	//
	// Specifies whether buyer user lists are targeted on a programmatic {@link LineItem} or {@link
	// ProposalLineItem}. This attribute is readonly and is populated by Google.
	//
	BuyerUserListTargeting *BuyerUserListTargeting `xml:"buyerUserListTargeting,omitempty" json:"buyerUserListTargeting,omitempty"`

	//
	// Specifies the URLs that are targeted by the entity. This is currently only supported by {@link
	// YieldGroup}.
	//
	InventoryUrlTargeting *InventoryUrlTargeting `xml:"inventoryUrlTargeting,omitempty" json:"inventoryUrlTargeting,omitempty"`

	//
	// Specifies the request platforms that are targeted by the {@link LineItem}. This attribute is
	// required for video line items and for {@link ProposalLineItem}.
	//
	// <p>This value is modifiable for video line items, but read-only for non-video line items.
	//
	// <p>This value is read-only for video line items generated from proposal line items.
	//
	RequestPlatformTargeting *RequestPlatformTargeting `xml:"requestPlatformTargeting,omitempty" json:"requestPlatformTargeting,omitempty"`

	//
	// Specifies the sizes that are targeted by the entity. This is currently only supported on {@link
	// YieldGroup} and {@link TrafficDataRequest}.
	//
	InventorySizeTargeting *InventorySizeTargeting `xml:"inventorySizeTargeting,omitempty" json:"inventorySizeTargeting,omitempty"`
}

type TeamError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *TeamError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type Technology struct {

	//
	// The unique ID of the {@code Technology}. This value is required for all forms of {@code
	// TechnologyTargeting}.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// The name of the technology being targeting. This value is read-only and is assigned by Google.
	//
	Name string `xml:"name,omitempty" json:"name,omitempty"`
}

type TechnologyTargetingError struct {
	*ApiError

	Reason *TechnologyTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type TextValue struct {
	*_Value

	//
	// The string value.
	//
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

type ThirdPartyMeasurementSettings struct {

	//
	// A field to determine the type of ThirdPartyViewabilityIntegrationPartner. This field default is
	// NONE.
	//
	ViewabilityPartner *ThirdPartyViewabilityIntegrationPartner `xml:"viewabilityPartner,omitempty" json:"viewabilityPartner,omitempty"`

	//
	// The third party partner id for YouTube viewability verification.
	//
	ViewabilityClientId string `xml:"viewabilityClientId,omitempty" json:"viewabilityClientId,omitempty"`

	//
	// The reporting id that maps viewability partner data with a campaign (or a group of related
	// campaigns) specific data.
	//
	ViewabilityReportingId string `xml:"viewabilityReportingId,omitempty" json:"viewabilityReportingId,omitempty"`

	//
	// A field to determine the type of publisher's viewability partner. This field default is NONE.
	//
	PublisherViewabilityPartner *ThirdPartyViewabilityIntegrationPartner `xml:"publisherViewabilityPartner,omitempty" json:"publisherViewabilityPartner,omitempty"`

	//
	// The third party partner id for YouTube viewability verification for publisher.
	//
	PublisherViewabilityClientId string `xml:"publisherViewabilityClientId,omitempty" json:"publisherViewabilityClientId,omitempty"`

	//
	// The reporting id that maps viewability partner data with a campaign (or a group of related
	// campaigns) specific data for publisher.
	//
	PublisherViewabilityReportingId string `xml:"publisherViewabilityReportingId,omitempty" json:"publisherViewabilityReportingId,omitempty"`

	//
	// A field to determine the type of ThirdPartyBrandLiftIntegrationPartner. This field default is
	// NONE.
	//
	BrandLiftPartner *ThirdPartyBrandLiftIntegrationPartner `xml:"brandLiftPartner,omitempty" json:"brandLiftPartner,omitempty"`

	//
	// The third party partner id for YouTube brand lift verification.
	//
	BrandLiftClientId string `xml:"brandLiftClientId,omitempty" json:"brandLiftClientId,omitempty"`

	//
	// The reporting id that maps brand lift partner data with a campaign (or a group of related
	// campaigns) specific data.
	//
	BrandLiftReportingId string `xml:"brandLiftReportingId,omitempty" json:"brandLiftReportingId,omitempty"`

	//
	// A field to determine the type of advertiser's ThirdPartyReachIntegrationPartner. This field
	// default is UNKNOWN.
	//
	ReachPartner *ThirdPartyReachIntegrationPartner `xml:"reachPartner,omitempty" json:"reachPartner,omitempty"`

	//
	// The third party partner id for YouTube reach verification for advertiser.
	//
	ReachClientId string `xml:"reachClientId,omitempty" json:"reachClientId,omitempty"`

	//
	// The reporting id that maps reach partner data with a campaign (or a group of related campaigns)
	// specific data for advertiser.
	//
	ReachReportingId string `xml:"reachReportingId,omitempty" json:"reachReportingId,omitempty"`

	//
	// A field to determine the type of publisher's ThirdPartyReachIntegrationPartner. This field
	// default is UNKNOWN.
	//
	PublisherReachPartner *ThirdPartyReachIntegrationPartner `xml:"publisherReachPartner,omitempty" json:"publisherReachPartner,omitempty"`

	//
	// The third party partner id for YouTube reach verification for publisher.
	//
	PublisherReachClientId string `xml:"publisherReachClientId,omitempty" json:"publisherReachClientId,omitempty"`

	//
	// The reporting id that maps reach partner data with a campaign (or a group of related campaigns)
	// specific data for publisher.
	//
	PublisherReachReportingId string `xml:"publisherReachReportingId,omitempty" json:"publisherReachReportingId,omitempty"`
}

type TimeOfDay struct {

	//
	// Hour in 24 hour time (0..24). This field must be between 0 and 24,
	// inclusive. This field is required.
	//
	Hour int32 `xml:"hour,omitempty" json:"hour,omitempty"`

	//
	// Minutes in an hour. Currently, only 0, 15, 30, and 45 are supported. This
	// field is required.
	//
	Minute *MinuteOfHour `xml:"minute,omitempty" json:"minute,omitempty"`
}

type TimeZoneError struct {
	*ApiError

	Reason *TimeZoneError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type TypeError struct {
	*ApiError
}

type UnarchiveProposalLineItems struct {
	*ProposalLineItemAction
}

type UniqueError struct {
	*ApiError
}

type UpdateResult struct {

	//
	// The number of objects that were changed as a result of performing the
	// action.
	//
	NumChanges int32 `xml:"numChanges,omitempty" json:"numChanges,omitempty"`
}

type UserDomainTargeting struct {

	//
	// The domains or subdomains that are being targeted or excluded by the {@link LineItem}. This
	// attribute is required and the maximum length of each domain is 67 characters.
	//
	Domains []string `xml:"domains,omitempty" json:"domains,omitempty"`

	//
	// Indicates whether domains should be targeted or excluded. This attribute is optional and
	// defaults to {@code true}.
	//
	Targeted bool `xml:"targeted,omitempty" json:"targeted,omitempty"`
}

type UserDomainTargetingError struct {
	*ApiError

	Reason *UserDomainTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type _Value struct {
}

type VideoPosition struct {

	//
	// The type of video position (pre-roll, mid-roll, or post-roll).
	//
	PositionType *VideoPosition_Type `xml:"positionType,omitempty" json:"positionType,omitempty"`

	//
	// The index of the mid-roll to target.  Only valid if the {@link positionType} is
	// {@link VideoPositionType#MIDROLL}, otherwise this field will be ignored.
	//
	MidrollIndex int32 `xml:"midrollIndex,omitempty" json:"midrollIndex,omitempty"`
}

type VideoPositionTargeting struct {

	//
	// The {@link VideoTargetingPosition} objects being targeted by the video {@link LineItem}.
	//
	TargetedPositions []*VideoPositionTarget `xml:"targetedPositions,omitempty" json:"targetedPositions,omitempty"`
}

type VideoPositionTargetingError struct {
	*ApiError

	Reason *VideoPositionTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type VideoPositionWithinPod struct {

	//
	// The specific index of the pod. The index is defined as:
	// <ul><li>1 = first</li>
	// <li>2 = second</li>
	// <li>3 = third</li>
	// <li>....</li>
	// <li>100 = last</li></ul>
	// 100 will always be the last position. For example, for a pod with 5 positions, 100 would
	// target position 5. Multiple targets against the index 100 can exist.<br>
	// Positions over 100 are not supported.
	//
	Index int32 `xml:"index,omitempty" json:"index,omitempty"`
}

type VideoPositionTarget struct {

	//
	// The video position to target.  This attribute is required.
	//
	VideoPosition *VideoPosition `xml:"videoPosition,omitempty" json:"videoPosition,omitempty"`

	//
	// The video bumper type to target. To target a video position or a pod position, this value must
	// be null. To target a bumper position this value must be populated and the line item must have a
	// bumper type. To target a custom ad spot, this value must be null.
	//
	VideoBumperType *VideoBumperType `xml:"videoBumperType,omitempty" json:"videoBumperType,omitempty"`

	//
	// The video position within a pod to target. To target a video position or a bumper position,
	// this value must be null. To target a position within a pod this value must be populated. To
	// target a custom ad spot, this value must be null.
	//
	VideoPositionWithinPod *VideoPositionWithinPod `xml:"videoPositionWithinPod,omitempty" json:"videoPositionWithinPod,omitempty"`

	//
	// A custom spot {@link AdSpot} to target. To target a video position, a bumper type or a video
	// position within a pod this value must be null.
	//
	AdSpotId int64 `xml:"adSpotId,omitempty" json:"adSpotId,omitempty"`
}

type ProposalLineItemServiceInterface interface {

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Creates makegood proposal line items given the specifications provided.
	*/
	CreateMakegoods(request *CreateMakegoods) (*CreateMakegoodsResponse, error)

	CreateMakegoodsContext(ctx context.Context, request *CreateMakegoods) (*CreateMakegoodsResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Creates new {@link ProposalLineItem} objects.
	*/
	CreateProposalLineItems(request *CreateProposalLineItems) (*CreateProposalLineItemsResponse, error)

	CreateProposalLineItemsContext(ctx context.Context, request *CreateProposalLineItems) (*CreateProposalLineItemsResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Gets a {@link ProposalLineItemPage} of {@link ProposalLineItem} objects that satisfy the given
	   {@link Statement#query}. The following fields are supported for filtering:

	   <table>
	   <tr>
	   <th scope="col">PQL Property</th> <th scope="col">Object Property</th>
	   </tr>
	   <tr>
	   <td>{@code id}</td>
	   <td>{@link ProposalLineItem#id}</td>
	   </tr>
	   <tr>
	   <td>{@code name}</td>
	   <td>{@link ProposalLineItem#name}</td>
	   </tr>
	   <tr>
	   <td>{@code proposalId}</td>
	   <td>{@link ProposalLineItem#proposalId}</td>
	   </tr>
	   <tr>
	   <td>{@code startDateTime}</td>
	   <td>{@link ProposalLineItem#startDateTime}</td>
	   </tr>
	   <tr>
	   <td>{@code endDateTime}</td>
	   <td>{@link ProposalLineItem#endDateTime}</td>
	   </tr>
	   <tr>
	   <td>{@code isArchived}</td>
	   <td>{@link ProposalLineItem#isArchived}</td>
	   </tr>
	   <tr>
	   <td>{@code lastModifiedDateTime}</td>
	   <td>{@link ProposalLineItem#lastModifiedDateTime}</td>
	   </tr>
	   <tr>
	   <td>{@code isProgrammatic}</td>
	   <td>{@link ProposalLineItem#isProgrammatic}</td>
	   </tr>
	   </table>
	*/
	GetProposalLineItemsByStatement(request *GetProposalLineItemsByStatement) (*GetProposalLineItemsByStatementResponse, error)

	GetProposalLineItemsByStatementContext(ctx context.Context, request *GetProposalLineItemsByStatement) (*GetProposalLineItemsByStatementResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Performs actions on {@link ProposalLineItem} objects that match the given {@link
	   Statement#query}.
	*/
	PerformProposalLineItemAction(request *PerformProposalLineItemAction) (*PerformProposalLineItemActionResponse, error)

	PerformProposalLineItemActionContext(ctx context.Context, request *PerformProposalLineItemAction) (*PerformProposalLineItemActionResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Updates the specified {@link ProposalLineItem} objects.
	*/
	UpdateProposalLineItems(request *UpdateProposalLineItems) (*UpdateProposalLineItemsResponse, error)

	UpdateProposalLineItemsContext(ctx context.Context, request *UpdateProposalLineItems) (*UpdateProposalLineItemsResponse, error)
}

type proposalLineItemServiceInterface struct {
	client *soap.Client
}

func NewProposalLineItemServiceInterface(client *soap.Client) ProposalLineItemServiceInterface {
	return &proposalLineItemServiceInterface{
		client: client,
	}
}

func (service *proposalLineItemServiceInterface) CreateMakegoodsContext(ctx context.Context, request *CreateMakegoods) (*CreateMakegoodsResponse, error) {
	response := new(CreateMakegoodsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *proposalLineItemServiceInterface) CreateMakegoods(request *CreateMakegoods) (*CreateMakegoodsResponse, error) {
	return service.CreateMakegoodsContext(
		context.Background(),
		request,
	)
}

func (service *proposalLineItemServiceInterface) CreateProposalLineItemsContext(ctx context.Context, request *CreateProposalLineItems) (*CreateProposalLineItemsResponse, error) {
	response := new(CreateProposalLineItemsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *proposalLineItemServiceInterface) CreateProposalLineItems(request *CreateProposalLineItems) (*CreateProposalLineItemsResponse, error) {
	return service.CreateProposalLineItemsContext(
		context.Background(),
		request,
	)
}

func (service *proposalLineItemServiceInterface) GetProposalLineItemsByStatementContext(ctx context.Context, request *GetProposalLineItemsByStatement) (*GetProposalLineItemsByStatementResponse, error) {
	response := new(GetProposalLineItemsByStatementResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *proposalLineItemServiceInterface) GetProposalLineItemsByStatement(request *GetProposalLineItemsByStatement) (*GetProposalLineItemsByStatementResponse, error) {
	return service.GetProposalLineItemsByStatementContext(
		context.Background(),
		request,
	)
}

func (service *proposalLineItemServiceInterface) PerformProposalLineItemActionContext(ctx context.Context, request *PerformProposalLineItemAction) (*PerformProposalLineItemActionResponse, error) {
	response := new(PerformProposalLineItemActionResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *proposalLineItemServiceInterface) PerformProposalLineItemAction(request *PerformProposalLineItemAction) (*PerformProposalLineItemActionResponse, error) {
	return service.PerformProposalLineItemActionContext(
		context.Background(),
		request,
	)
}

func (service *proposalLineItemServiceInterface) UpdateProposalLineItemsContext(ctx context.Context, request *UpdateProposalLineItems) (*UpdateProposalLineItemsResponse, error) {
	response := new(UpdateProposalLineItemsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *proposalLineItemServiceInterface) UpdateProposalLineItems(request *UpdateProposalLineItems) (*UpdateProposalLineItemsResponse, error) {
	return service.UpdateProposalLineItemsContext(
		context.Background(),
		request,
	)
}
