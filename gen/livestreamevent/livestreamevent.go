// Code generated by gowsdl DO NOT EDIT.

package livestreamevent

import (
	"context"
	"encoding/xml"
	"github.com/hooklift/gowsdl/soap"
	"time"
)

// against "unused imports"
var _ time.Time
var _ xml.Name

type AnyType struct {
	InnerXML string `xml:",innerxml"`
}

type AnyURI string

type NCName string

//
// Describes what should be used to fill an empty or underfilled ad break during a live stream.
//

type AdBreakFillType string

const (

	//
	// Ad break should be filled with slate.
	//
	AdBreakFillTypeSLATE AdBreakFillType = "SLATE"

	//
	// Ad break should be filled with underlying content.
	//
	AdBreakFillTypeUNDERLYING_CONTENT AdBreakFillType = "UNDERLYING_CONTENT"

	//
	// Ad break should be filled with mostly underlying content. When ad content can't be aligned with
	// underlying content during transition, the gap will be bridged with slate to maintain the
	// timeline.
	//
	AdBreakFillTypeMINIMIZE_SLATE AdBreakFillType = "MINIMIZE_SLATE"

	//
	// The value returned if the actual value is not exposed by the requested API
	// version.
	//
	AdBreakFillTypeUNKNOWN AdBreakFillType = "UNKNOWN"
)

//
// The reasons for the target error.
//

type AdBreakMarkupError_Reason string

const (

	//
	// The ad break markups provided are not valid for the Streaming Format
	//
	AdBreakMarkupError_ReasonINVALID_AD_BREAK_MARKUPS_FOR_STREAMING_FORMAT AdBreakMarkupError_Reason = "INVALID_AD_BREAK_MARKUPS_FOR_STREAMING_FORMAT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AdBreakMarkupError_ReasonUNKNOWN AdBreakMarkupError_Reason = "UNKNOWN"
)

//
// Describes the SCTE ad break markups for a {@link LiveStreamEvent}.
//

type AdBreakMarkupType string

const (

	//
	// The CUE-OUT/CUE-IN ad break marker type. This mark up type is only applicable for HLS live
	// streams.
	//
	AdBreakMarkupTypeAD_BREAK_MARKUP_HLS_EXT_CUE AdBreakMarkupType = "AD_BREAK_MARKUP_HLS_EXT_CUE"

	//
	// The CUE (Adobe/Azure Prime Time) ad break marker type. This mark up type is only applicable for
	// HLS live streams.
	//
	AdBreakMarkupTypeAD_BREAK_MARKUP_HLS_PRIMETIME_SPLICE AdBreakMarkupType = "AD_BREAK_MARKUP_HLS_PRIMETIME_SPLICE"

	//
	// The DATERANGE (Anvato) ad break marker type. This mark up type is only applicable for HLS live
	// streams.
	//
	AdBreakMarkupTypeAD_BREAK_MARKUP_HLS_DATERANGE_SPLICE AdBreakMarkupType = "AD_BREAK_MARKUP_HLS_DATERANGE_SPLICE"

	//
	// The SCTE35 XML Splice In/Out ad break marker type. This markup type is only applicable for DASH
	// live streams.
	//
	AdBreakMarkupTypeAD_BREAK_MARKUP_SCTE35_XML_SPLICE_INSERT AdBreakMarkupType = "AD_BREAK_MARKUP_SCTE35_XML_SPLICE_INSERT"

	//
	// The SCTE35 Binary Splice Insert ad break marker type. This mark up type is only applicable for
	// HLS and DASH live streams.
	//
	AdBreakMarkupTypeAD_BREAK_MARKUP_SCTE35_BINARY_SPLICE_INSERT AdBreakMarkupType = "AD_BREAK_MARKUP_SCTE35_BINARY_SPLICE_INSERT"

	//
	// The SCTE35 Binary Time Signal: Provider Ad Start/End ad break marker type. This mark up type is
	// only applicable for HLS and DASH live streams.
	//
	AdBreakMarkupTypeAD_BREAK_MARKUP_SCTE35_BINARY_PROVIDER_AD_START_END AdBreakMarkupType = "AD_BREAK_MARKUP_SCTE35_BINARY_PROVIDER_AD_START_END"

	//
	// The SCTE35 Binary Time Signal: Provider Placement Opportunity Start/End ad break marker type.
	// This mark up type is only applicable for HLS and DASH live streams.
	//
	AdBreakMarkupTypeAD_BREAK_MARKUP_SCTE35_BINARY_PROVIDER_PLACEMENT_OP_START_END AdBreakMarkupType = "AD_BREAK_MARKUP_SCTE35_BINARY_PROVIDER_PLACEMENT_OP_START_END"

	//
	// The SCTE35 Binary Time Signal: Break Start/End ad break marker type. This mark up type is only
	// applicable for HLS and DASH live streams.
	//
	AdBreakMarkupTypeAD_BREAK_MARKUP_SCTE35_BINARY_BREAK_START_END AdBreakMarkupType = "AD_BREAK_MARKUP_SCTE35_BINARY_BREAK_START_END"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AdBreakMarkupTypeUNKNOWN AdBreakMarkupType = "UNKNOWN"
)

//
// Indicates how the ads of the live stream should be served.
//

type AdServingFormat string

const (

	//
	// The ads are served through Google Ad Manager DAI.
	//
	AdServingFormatAD_MANAGER_DAI AdServingFormat = "AD_MANAGER_DAI"

	//
	// The ads are served through Google Ad Manager Ad Serving.
	//
	AdServingFormatDIRECT AdServingFormat = "DIRECT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AdServingFormatUNKNOWN AdServingFormat = "UNKNOWN"
)

type ApiVersionError_Reason string

const (

	//
	// Indicates that the operation is not allowed in the version the request
	// was made in.
	//
	ApiVersionError_ReasonUPDATE_TO_NEWER_VERSION ApiVersionError_Reason = "UPDATE_TO_NEWER_VERSION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ApiVersionError_ReasonUNKNOWN ApiVersionError_Reason = "UNKNOWN"
)

type AuthenticationError_Reason string

const (

	//
	// The SOAP message contains a request header with an ambiguous definition of the authentication
	// header fields. This means either the {@code authToken} and {@code oAuthToken} fields were
	// both null or both were specified. Exactly one value should be specified with each request.
	//
	AuthenticationError_ReasonAMBIGUOUS_SOAP_REQUEST_HEADER AuthenticationError_Reason = "AMBIGUOUS_SOAP_REQUEST_HEADER"

	//
	// The login provided is invalid.
	//
	AuthenticationError_ReasonINVALID_EMAIL AuthenticationError_Reason = "INVALID_EMAIL"

	//
	// Tried to authenticate with provided information, but failed.
	//
	AuthenticationError_ReasonAUTHENTICATION_FAILED AuthenticationError_Reason = "AUTHENTICATION_FAILED"

	//
	// The OAuth provided is invalid.
	//
	AuthenticationError_ReasonINVALID_OAUTH_SIGNATURE AuthenticationError_Reason = "INVALID_OAUTH_SIGNATURE"

	//
	// The specified service to use was not recognized.
	//
	AuthenticationError_ReasonINVALID_SERVICE AuthenticationError_Reason = "INVALID_SERVICE"

	//
	// The SOAP message is missing a request header with an {@code authToken} and optional {@code
	// networkCode}.
	//
	AuthenticationError_ReasonMISSING_SOAP_REQUEST_HEADER AuthenticationError_Reason = "MISSING_SOAP_REQUEST_HEADER"

	//
	// The HTTP request is missing a request header with an {@code authToken}
	//
	AuthenticationError_ReasonMISSING_AUTHENTICATION_HTTP_HEADER AuthenticationError_Reason = "MISSING_AUTHENTICATION_HTTP_HEADER"

	//
	// The request is missing an {@code authToken}
	//
	AuthenticationError_ReasonMISSING_AUTHENTICATION AuthenticationError_Reason = "MISSING_AUTHENTICATION"

	//
	// The network does not have API access enabled.
	//
	AuthenticationError_ReasonNETWORK_API_ACCESS_DISABLED AuthenticationError_Reason = "NETWORK_API_ACCESS_DISABLED"

	//
	// The user is not associated with any network.
	//
	AuthenticationError_ReasonNO_NETWORKS_TO_ACCESS AuthenticationError_Reason = "NO_NETWORKS_TO_ACCESS"

	//
	// No network for the given {@code networkCode} was found.
	//
	AuthenticationError_ReasonNETWORK_NOT_FOUND AuthenticationError_Reason = "NETWORK_NOT_FOUND"

	//
	// The user has access to more than one network, but did not provide a {@code networkCode}.
	//
	AuthenticationError_ReasonNETWORK_CODE_REQUIRED AuthenticationError_Reason = "NETWORK_CODE_REQUIRED"

	//
	// An error happened on the server side during connection to authentication service.
	//
	AuthenticationError_ReasonCONNECTION_ERROR AuthenticationError_Reason = "CONNECTION_ERROR"

	//
	// The user tried to create a test network using an account that already is associated with a
	// network.
	//
	AuthenticationError_ReasonGOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK AuthenticationError_Reason = "GOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK"

	//
	// The account is blocked and under investigation by the collections team. Please contact Google
	// for more information.
	//
	AuthenticationError_ReasonUNDER_INVESTIGATION AuthenticationError_Reason = "UNDER_INVESTIGATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AuthenticationError_ReasonUNKNOWN AuthenticationError_Reason = "UNKNOWN"
)

type CollectionSizeError_Reason string

const (
	CollectionSizeError_ReasonTOO_LARGE CollectionSizeError_Reason = "TOO_LARGE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CollectionSizeError_ReasonUNKNOWN CollectionSizeError_Reason = "UNKNOWN"
)

//
// Describes reasons for common errors
//

type CommonError_Reason string

const (

	//
	// Indicates that an attempt was made to retrieve an entity that does not
	// exist.
	//
	CommonError_ReasonNOT_FOUND CommonError_Reason = "NOT_FOUND"

	//
	// Indicates that an attempt was made to create an entity that already
	// exists.
	//
	CommonError_ReasonALREADY_EXISTS CommonError_Reason = "ALREADY_EXISTS"

	//
	// Indicates that a value is not applicable for given use case.
	//
	CommonError_ReasonNOT_APPLICABLE CommonError_Reason = "NOT_APPLICABLE"

	//
	// Indicates that two elements in the collection were identical.
	//
	CommonError_ReasonDUPLICATE_OBJECT CommonError_Reason = "DUPLICATE_OBJECT"

	//
	// Indicates that an attempt was made to change an immutable field.
	//
	CommonError_ReasonCANNOT_UPDATE CommonError_Reason = "CANNOT_UPDATE"

	//
	// Indicates that the requested operation is not supported.
	//
	CommonError_ReasonUNSUPPORTED_OPERATION CommonError_Reason = "UNSUPPORTED_OPERATION"

	//
	// Indicates that another request attempted to update the same data in the same network
	// at about the same time. Please wait and try the request again.
	//
	CommonError_ReasonCONCURRENT_MODIFICATION CommonError_Reason = "CONCURRENT_MODIFICATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CommonError_ReasonUNKNOWN CommonError_Reason = "UNKNOWN"
)

//
// Describes how the live stream will have ads dynamically inserted into playlists.
//

type DynamicAdInsertionType string

const (

	//
	// Content manifest is served by Google DAI. Content and ads are stitched together into a unique
	// video manifest per user.
	//
	DynamicAdInsertionTypeLINEAR DynamicAdInsertionType = "LINEAR"

	//
	// Content manifest is served by the partner, embedding Google DAI ad segment URLs which redirect
	// to unique Google DAI ad segments per user.
	//
	DynamicAdInsertionTypePOD_SERVING_REDIRECT DynamicAdInsertionType = "POD_SERVING_REDIRECT"

	//
	// Ads manifest is served by Google DAI, containing unique ad pod segments for the video player
	// to switch to from the content stream, or for the partner to stitch directly into the user
	// content manifest.
	//
	DynamicAdInsertionTypePOD_SERVING_MANIFEST DynamicAdInsertionType = "POD_SERVING_MANIFEST"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DynamicAdInsertionTypeUNKNOWN DynamicAdInsertionType = "UNKNOWN"
)

//
// The reasons for the entity limit reached error.
//

type EntityLimitReachedError_Reason string

const (

	//
	// The number of custom targeting values exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonCUSTOM_TARGETING_VALUES_LIMIT_REACHED EntityLimitReachedError_Reason = "CUSTOM_TARGETING_VALUES_LIMIT_REACHED"

	//
	// The number of ad exclusion rules exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonAD_EXCLUSION_RULES_LIMIT_REACHED EntityLimitReachedError_Reason = "AD_EXCLUSION_RULES_LIMIT_REACHED"

	//
	// The number of first party audience segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonFIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "FIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED"

	//
	// The number of active placements exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonPLACEMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "PLACEMENTS_LIMIT_REACHED"

	//
	// The number of line items excceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonLINE_ITEMS_LIMIT_REACHED EntityLimitReachedError_Reason = "LINE_ITEMS_LIMIT_REACHED"

	//
	// The number of active line items exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonACTIVE_LINE_ITEMS_LIMIT_REACHED EntityLimitReachedError_Reason = "ACTIVE_LINE_ITEMS_LIMIT_REACHED"

	//
	// The number of not-archived encoding profiles exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonDAI_ENCODING_PROFILES_LIMIT_REACHED EntityLimitReachedError_Reason = "DAI_ENCODING_PROFILES_LIMIT_REACHED"

	//
	// The number of traffic forecast segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonTRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "TRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED"

	//
	// The number of forecast adjustments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonFORECAST_ADJUSTMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "FORECAST_ADJUSTMENTS_LIMIT_REACHED"

	//
	// The number of active experiments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonACTIVE_EXPERIMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "ACTIVE_EXPERIMENTS_LIMIT_REACHED"

	//
	// The number of sites exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonSITES_LIMIT_REACHED EntityLimitReachedError_Reason = "SITES_LIMIT_REACHED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityLimitReachedError_ReasonUNKNOWN EntityLimitReachedError_Reason = "UNKNOWN"
)

type FeatureError_Reason string

const (

	//
	// A feature is being used that is not enabled on the current network.
	//
	FeatureError_ReasonMISSING_FEATURE FeatureError_Reason = "MISSING_FEATURE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FeatureError_ReasonUNKNOWN FeatureError_Reason = "UNKNOWN"
)

//
// The single reason for the internal API error.
//

type InternalApiError_Reason string

const (

	//
	// API encountered an unexpected internal error.
	//
	InternalApiError_ReasonUNEXPECTED_INTERNAL_API_ERROR InternalApiError_Reason = "UNEXPECTED_INTERNAL_API_ERROR"

	//
	// A temporary error occurred during the request. Please retry.
	//
	InternalApiError_ReasonTRANSIENT_ERROR InternalApiError_Reason = "TRANSIENT_ERROR"

	//
	// The cause of the error is not known or only defined in newer versions.
	//
	InternalApiError_ReasonUNKNOWN InternalApiError_Reason = "UNKNOWN"

	//
	// The API is currently unavailable for a planned downtime.
	//
	InternalApiError_ReasonDOWNTIME InternalApiError_Reason = "DOWNTIME"

	//
	// Mutate succeeded but server was unable to build response. Client should not retry mutate.
	//
	InternalApiError_ReasonERROR_GENERATING_RESPONSE InternalApiError_Reason = "ERROR_GENERATING_RESPONSE"
)

type InvalidUrlError_Reason string

const (

	//
	// The URL contains invalid characters.
	//
	InvalidUrlError_ReasonILLEGAL_CHARACTERS InvalidUrlError_Reason = "ILLEGAL_CHARACTERS"

	//
	// The format of the URL is not allowed. This could occur for a number of
	// reasons. For example, if an invalid scheme is specified (like "ftp://")
	// or if a port is specified when not required, or if a query was specified
	// when not required.
	//
	InvalidUrlError_ReasonINVALID_FORMAT InvalidUrlError_Reason = "INVALID_FORMAT"

	//
	// URL contains insecure scheme.
	//
	InvalidUrlError_ReasonINSECURE_SCHEME InvalidUrlError_Reason = "INSECURE_SCHEME"

	//
	// The URL does not contain a scheme.
	//
	InvalidUrlError_ReasonNO_SCHEME InvalidUrlError_Reason = "NO_SCHEME"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InvalidUrlError_ReasonUNKNOWN InvalidUrlError_Reason = "UNKNOWN"
)

//
// Describes reasons for {@code LiveStreamEventActionError}.
//

type LiveStreamEventActionError_Reason string

const (

	//
	// The operation is not applicable to the current status.
	//
	LiveStreamEventActionError_ReasonINVALID_STATUS_TRANSITION LiveStreamEventActionError_Reason = "INVALID_STATUS_TRANSITION"

	//
	// The operation cannot be applied because the live stream event is
	// archived.
	//
	LiveStreamEventActionError_ReasonIS_ARCHIVED LiveStreamEventActionError_Reason = "IS_ARCHIVED"

	//
	// Both the live stream event slate and the network default slate are not set.
	//
	LiveStreamEventActionError_ReasonINVALID_SLATE_SETTING LiveStreamEventActionError_Reason = "INVALID_SLATE_SETTING"

	//
	// The slate creative has not been transcoded.
	//
	LiveStreamEventActionError_ReasonSLATE_CREATIVE_NOT_TRANSCODED LiveStreamEventActionError_Reason = "SLATE_CREATIVE_NOT_TRANSCODED"

	//
	// Unable to activate live stream event that has an associated archived slate.
	//
	LiveStreamEventActionError_ReasonSLATE_CREATIVE_ARCHIVED LiveStreamEventActionError_Reason = "SLATE_CREATIVE_ARCHIVED"

	//
	// A live stream cannot be activated if it is using inactive DAI authentication keys.
	//
	LiveStreamEventActionError_ReasonCANNOT_ACTIVATE_IF_USING_INACTIVE_DAI_AUTHENTICATION_KEYS LiveStreamEventActionError_Reason = "CANNOT_ACTIVATE_IF_USING_INACTIVE_DAI_AUTHENTICATION_KEYS"

	//
	// The value returned if the actual value is not exposed by the requested
	// API version.
	//
	LiveStreamEventActionError_ReasonUNKNOWN LiveStreamEventActionError_Reason = "UNKNOWN"
)

//
// Describes reasons for {@code LiveStreamEventCdnSettingsError}.
//

type LiveStreamEventCdnSettingsError_Reason string

const (

	//
	// CDN configurations in a single {@link LiveStreamEvent} cannot have duplicate URL prefixes.
	//
	LiveStreamEventCdnSettingsError_ReasonCDN_CONFIGURATIONS_MUST_HAVE_UNIQUE_CDN_URL_PREFIXES LiveStreamEventCdnSettingsError_Reason = "CDN_CONFIGURATIONS_MUST_HAVE_UNIQUE_CDN_URL_PREFIXES"

	//
	// Only CDN configurations of type {@code VodConfigurationType.LINEAR_SOURCE_CONTENT} can be
	// listed in {@link LiveStreamEvent#sourceContentConfigurations}.
	//
	LiveStreamEventCdnSettingsError_ReasonMUST_BE_LIVE_CDN_CONFIGURATION LiveStreamEventCdnSettingsError_Reason = "MUST_BE_LIVE_CDN_CONFIGURATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LiveStreamEventCdnSettingsError_ReasonUNKNOWN LiveStreamEventCdnSettingsError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type LiveStreamEventConditioningError_Reason string

const (

	//
	// DASH bridge conditioning cannot be applied.
	//
	LiveStreamEventConditioningError_ReasonCANNOT_APPLY_DASH_BRIDGE LiveStreamEventConditioningError_Reason = "CANNOT_APPLY_DASH_BRIDGE"

	//
	// DASH bridge conditioning cannot be modified after start time.
	//
	LiveStreamEventConditioningError_ReasonCANNOT_UPDATE_DASH_BRIDGE_AFTER_START_TIME LiveStreamEventConditioningError_Reason = "CANNOT_UPDATE_DASH_BRIDGE_AFTER_START_TIME"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LiveStreamEventConditioningError_ReasonUNKNOWN LiveStreamEventConditioningError_Reason = "UNKNOWN"
)

//
// Describes reasons for {@code LiveStreamEventCustomAssetKeyError}.
//

type LiveStreamEventCustomAssetKeyError_Reason string

const (

	//
	// Custom asset key contains invalid characters.
	//
	LiveStreamEventCustomAssetKeyError_ReasonCONTAINS_INVALID_CHARACTERS LiveStreamEventCustomAssetKeyError_Reason = "CONTAINS_INVALID_CHARACTERS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LiveStreamEventCustomAssetKeyError_ReasonUNKNOWN LiveStreamEventCustomAssetKeyError_Reason = "UNKNOWN"
)

//
// Describes reasons for {@code LiveStreamEventDateTimeError}.
//

type LiveStreamEventDateTimeError_Reason string

const (

	//
	// Cannot create a new live stream event with a start date in the past.
	//
	LiveStreamEventDateTimeError_ReasonSTART_DATE_TIME_IS_IN_PAST LiveStreamEventDateTimeError_Reason = "START_DATE_TIME_IS_IN_PAST"

	//
	// End date must be after the start date.
	//
	LiveStreamEventDateTimeError_ReasonEND_DATE_TIME_NOT_AFTER_START_DATE_TIME LiveStreamEventDateTimeError_Reason = "END_DATE_TIME_NOT_AFTER_START_DATE_TIME"

	//
	// {@code DateTime}s after 1 January 2037 are not supported.
	//
	LiveStreamEventDateTimeError_ReasonEND_DATE_TIME_TOO_LATE LiveStreamEventDateTimeError_Reason = "END_DATE_TIME_TOO_LATE"

	//
	// The value returned if the actual value is not exposed by the requested
	// API version.
	//
	LiveStreamEventDateTimeError_ReasonUNKNOWN LiveStreamEventDateTimeError_Reason = "UNKNOWN"
)

//
// Describes reasons for {@code LiveStreamEventDvrWindowError}.
//

type LiveStreamEventDvrWindowError_Reason string

const (

	//
	// The DVR window cannot be higher than the value allowed for this network.
	//
	LiveStreamEventDvrWindowError_ReasonDVR_WINDOW_TOO_HIGH LiveStreamEventDvrWindowError_Reason = "DVR_WINDOW_TOO_HIGH"

	//
	// The DVR window cannot be lower than the minimum value allowed.
	//
	LiveStreamEventDvrWindowError_ReasonDVR_WINDOW_TOO_LOW LiveStreamEventDvrWindowError_Reason = "DVR_WINDOW_TOO_LOW"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LiveStreamEventDvrWindowError_ReasonUNKNOWN LiveStreamEventDvrWindowError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type LiveStreamEventPrerollSettingsError_Reason string

const (

	//
	// Preroll settings are only supported for livestream events of dynamic ad insertion type
	// linear.
	//
	LiveStreamEventPrerollSettingsError_ReasonINVALID_PREROLL_SETTINGS LiveStreamEventPrerollSettingsError_Reason = "INVALID_PREROLL_SETTINGS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LiveStreamEventPrerollSettingsError_ReasonUNKNOWN LiveStreamEventPrerollSettingsError_Reason = "UNKNOWN"
)

//
// Describes reasons for {@code LiveStreamEventSlateError}.
//

type LiveStreamEventSlateError_Reason string

const (

	//
	// The slate creative ID does not correspond to a slate creative.
	//
	LiveStreamEventSlateError_ReasonINVALID_SLATE_CREATIVE_ID LiveStreamEventSlateError_Reason = "INVALID_SLATE_CREATIVE_ID"

	//
	// The required field live stream event slate is not set.
	//
	// <p>There must either be a slate creative ID assigned to the live stream event or
	// a valid network level slate selected.
	//
	LiveStreamEventSlateError_ReasonLIVE_STREAM_EVENT_SLATE_CREATIVE_ID_REQUIRED LiveStreamEventSlateError_Reason = "LIVE_STREAM_EVENT_SLATE_CREATIVE_ID_REQUIRED"

	//
	// The slate does not have a videoSourceUrl or assetSourcePath.
	//
	LiveStreamEventSlateError_ReasonMISSING_SOURCE_FOR_SLATE LiveStreamEventSlateError_Reason = "MISSING_SOURCE_FOR_SLATE"

	//
	// The slate is of an invalid type.
	//
	LiveStreamEventSlateError_ReasonINVALID_SLATE_TYPE LiveStreamEventSlateError_Reason = "INVALID_SLATE_TYPE"

	//
	// The slate video source url cannot change.
	//
	LiveStreamEventSlateError_ReasonCANNOT_CHANGE_SLATE_VIDEO_SOURCE_URL LiveStreamEventSlateError_Reason = "CANNOT_CHANGE_SLATE_VIDEO_SOURCE_URL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LiveStreamEventSlateError_ReasonUNKNOWN LiveStreamEventSlateError_Reason = "UNKNOWN"
)

//
// Describes the status of a {@link LiveStreamEvent} object.
//

type LiveStreamEventStatus string

const (

	//
	// Indicates the {@link LiveStreamEvent} has been created and is eligible
	// for streaming.
	//
	LiveStreamEventStatusACTIVE LiveStreamEventStatus = "ACTIVE"

	//
	// Indicates the {@link LiveStreamEvent} has been archived.
	//
	LiveStreamEventStatusARCHIVED LiveStreamEventStatus = "ARCHIVED"

	//
	// Indicates the {@link LiveStreamEvent} has been paused. This
	// can be made {@link #ACTIVE} at later time.
	//
	LiveStreamEventStatusPAUSED LiveStreamEventStatus = "PAUSED"

	//
	// Indicates that the stream is still being served, but ad insertion should be paused
	// temporarily.
	//
	LiveStreamEventStatusADS_PAUSED LiveStreamEventStatus = "ADS_PAUSED"

	//
	// The value returned if the actual value is not exposed by the requested API
	// version.
	//
	LiveStreamEventStatusUNKNOWN LiveStreamEventStatus = "UNKNOWN"
)

//
// The reasons for the target error.
//

type NotNullError_Reason string

const (

	//
	// Assuming that a method will not have more than 3 arguments, if it does,
	// return NULL
	//
	NotNullError_ReasonARG1_NULL NotNullError_Reason = "ARG1_NULL"

	NotNullError_ReasonARG2_NULL NotNullError_Reason = "ARG2_NULL"

	NotNullError_ReasonARG3_NULL NotNullError_Reason = "ARG3_NULL"

	NotNullError_ReasonNULL NotNullError_Reason = "NULL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NotNullError_ReasonUNKNOWN NotNullError_Reason = "UNKNOWN"
)

//
// The reasons for the validation error.
//

type NullError_Reason string

const (

	//
	// Specified list/container must not contain any null elements
	//
	NullError_ReasonNULL_CONTENT NullError_Reason = "NULL_CONTENT"
)

//
// The reasons for the target error.
//

type ParseError_Reason string

const (

	//
	// Indicates an error in parsing an attribute.
	//
	ParseError_ReasonUNPARSABLE ParseError_Reason = "UNPARSABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ParseError_ReasonUNKNOWN ParseError_Reason = "UNKNOWN"
)

//
// Describes reasons for permission errors.
//

type PermissionError_Reason string

const (

	//
	// User does not have the required permission for the request.
	//
	PermissionError_ReasonPERMISSION_DENIED PermissionError_Reason = "PERMISSION_DENIED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PermissionError_ReasonUNKNOWN PermissionError_Reason = "UNKNOWN"
)

//
// Describes the type of the playlist associated with this live stream. This is analagous to the
// EXT-X-PLAYLIST-TYPE HLS tag. Use {@link PlaylistType.EVENT} for streams with the value
// "#EXT-X-PLAYLIST-TYPE:EVENT" and use {@link PlaylistType.LIVE} for streams without the tag.
//

type PlaylistType string

const (

	//
	// The playlist is an event, which means that media segments can only be added to the end of the
	// playlist. This allows viewers to scrub back to the beginning of the playlist.
	//
	PlaylistTypeEVENT PlaylistType = "EVENT"

	//
	// The playlist is a live stream and there are no restrictions on whether media segments can be
	// removed from the beginning of the playlist.
	//
	PlaylistTypeLIVE PlaylistType = "LIVE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PlaylistTypeUNKNOWN PlaylistType = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PublisherQueryLanguageContextError_Reason string

const (

	//
	// Indicates that there was an error executing the PQL.
	//
	PublisherQueryLanguageContextError_ReasonUNEXECUTABLE PublisherQueryLanguageContextError_Reason = "UNEXECUTABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageContextError_ReasonUNKNOWN PublisherQueryLanguageContextError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PublisherQueryLanguageSyntaxError_Reason string

const (

	//
	// Indicates that there was a PQL syntax error.
	//
	PublisherQueryLanguageSyntaxError_ReasonUNPARSABLE PublisherQueryLanguageSyntaxError_Reason = "UNPARSABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageSyntaxError_ReasonUNKNOWN PublisherQueryLanguageSyntaxError_Reason = "UNKNOWN"
)

type QuotaError_Reason string

const (

	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>Another way to mitigate this error is to limit requests to 8 per second for Ad Manager
	// 360 accounts, or 2 per second for Ad Manager accounts. Once again
	// this does not guarantee that every request will succeed, but may help
	// reduce the number of times you receive this error.
	//
	QuotaError_ReasonEXCEEDED_QUOTA QuotaError_Reason = "EXCEEDED_QUOTA"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	QuotaError_ReasonUNKNOWN QuotaError_Reason = "UNKNOWN"

	//
	// This user has exceeded the allowed number of new report requests per hour
	// (this includes both reports run via the UI and reports
	// run via {@link ReportService#runReportJob}).
	// The recommended approach to handle this error is to wait about 10 minutes
	// and then retry the request. Note that this does not guarantee the request
	// will succeed. If it fails again, try increasing the wait time.
	// <p>Another way to mitigate this error is to limit the number of new report
	// requests to 250 per hour per user. Once again, this does not guarantee that
	// every request will succeed, but may help reduce the number of times you
	// receive this error.
	//
	QuotaError_ReasonREPORT_JOB_LIMIT QuotaError_Reason = "REPORT_JOB_LIMIT"

	//
	// This network has exceeded the allowed number of identifiers uploaded within a 24 hour period.
	// The recommended approach to handle this error is to wait 30 minutes and then retry the
	// request. Note that this does not guarantee the request will succeed. If it fails again, try
	// increasing the wait time.
	//
	QuotaError_ReasonSEGMENT_POPULATION_LIMIT QuotaError_Reason = "SEGMENT_POPULATION_LIMIT"
)

type RangeError_Reason string

const (
	RangeError_ReasonTOO_HIGH RangeError_Reason = "TOO_HIGH"

	RangeError_ReasonTOO_LOW RangeError_Reason = "TOO_LOW"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RangeError_ReasonUNKNOWN RangeError_Reason = "UNKNOWN"
)

//
// Enumerates the different ways an HLS master playlist on a live stream will can be refreshed.
//

type RefreshType string

const (

	//
	// The master playlist will automatically be refreshed.
	//
	RefreshTypeAUTOMATIC RefreshType = "AUTOMATIC"

	//
	// The master playlist will only be refreshed when requested.
	//
	RefreshTypeMANUAL RefreshType = "MANUAL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RefreshTypeUNKNOWN RefreshType = "UNKNOWN"
)

type RequiredCollectionError_Reason string

const (

	//
	// A required collection is missing.
	//
	RequiredCollectionError_ReasonREQUIRED RequiredCollectionError_Reason = "REQUIRED"

	//
	// Collection size is too large.
	//
	RequiredCollectionError_ReasonTOO_LARGE RequiredCollectionError_Reason = "TOO_LARGE"

	//
	// Collection size is too small.
	//
	RequiredCollectionError_ReasonTOO_SMALL RequiredCollectionError_Reason = "TOO_SMALL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredCollectionError_ReasonUNKNOWN RequiredCollectionError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type RequiredError_Reason string

const (

	//
	// Missing required field.
	//
	RequiredError_ReasonREQUIRED RequiredError_Reason = "REQUIRED"
)

//
// Describes reasons for a number to be invalid.
//

type RequiredNumberError_Reason string

const (
	RequiredNumberError_ReasonREQUIRED RequiredNumberError_Reason = "REQUIRED"

	RequiredNumberError_ReasonTOO_LARGE RequiredNumberError_Reason = "TOO_LARGE"

	RequiredNumberError_ReasonTOO_SMALL RequiredNumberError_Reason = "TOO_SMALL"

	RequiredNumberError_ReasonTOO_LARGE_WITH_DETAILS RequiredNumberError_Reason = "TOO_LARGE_WITH_DETAILS"

	RequiredNumberError_ReasonTOO_SMALL_WITH_DETAILS RequiredNumberError_Reason = "TOO_SMALL_WITH_DETAILS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredNumberError_ReasonUNKNOWN RequiredNumberError_Reason = "UNKNOWN"
)

//
// Describes reasons for server errors
//

type ServerError_Reason string

const (

	//
	// Indicates that an unexpected error occured.
	//
	ServerError_ReasonSERVER_ERROR ServerError_Reason = "SERVER_ERROR"

	//
	// Indicates that the server is currently experiencing a high load. Please
	// wait and try your request again.
	//
	ServerError_ReasonSERVER_BUSY ServerError_Reason = "SERVER_BUSY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ServerError_ReasonUNKNOWN ServerError_Reason = "UNKNOWN"
)

//
// Describes the status of a {@link Slate} object.
//

type SlateStatus string

const (

	//
	// Indicates the {@link Slate} has been created and is eligible for streaming.
	//
	SlateStatusACTIVE SlateStatus = "ACTIVE"

	//
	// Indicates the {@link Slate} has been archived.
	//
	SlateStatusARCHIVED SlateStatus = "ARCHIVED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	SlateStatusUNKNOWN SlateStatus = "UNKNOWN"
)

//
// Specifies the start type to use for an entity with a start date time field.
// For example, a {@link LineItem} or {@link LineItemCreativeAssociation}.
//

type StartDateTimeType string

const (

	//
	// Use the value in {@link #startDateTime}.
	//
	StartDateTimeTypeUSE_START_DATE_TIME StartDateTimeType = "USE_START_DATE_TIME"

	//
	// The entity will start serving immediately. {@link #startDateTime} in the
	// request is ignored and will be set to the current time. Additionally,
	// {@link #startDateTimeType} will be set to
	// {@link StartDateTimeType#USE_START_DATE_TIME}.
	//
	StartDateTimeTypeIMMEDIATELY StartDateTimeType = "IMMEDIATELY"

	//
	// The entity will start serving one hour from now. {@link #startDateTime}
	// in the request is ignored and will be set to one hour from the current
	// time. Additionally, {@link #startDateTimeType} will be set to
	// {@link StartDateTimeType#USE_START_DATE_TIME}.
	//
	StartDateTimeTypeONE_HOUR_FROM_NOW StartDateTimeType = "ONE_HOUR_FROM_NOW"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StartDateTimeTypeUNKNOWN StartDateTimeType = "UNKNOWN"
)

type StatementError_Reason string

const (

	//
	// A bind variable has not been bound to a value.
	//
	StatementError_ReasonVARIABLE_NOT_BOUND_TO_VALUE StatementError_Reason = "VARIABLE_NOT_BOUND_TO_VALUE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StatementError_ReasonUNKNOWN StatementError_Reason = "UNKNOWN"
)

//
// The {@link LiveStreamEvent} streaming format.
//

type StreamingFormat string

const (

	//
	// The format of the live stream media is HTTP Live Streaming.
	//
	StreamingFormatHLS StreamingFormat = "HLS"

	//
	// The format of the live stream media is MPEG-DASH.
	//
	StreamingFormatDASH StreamingFormat = "DASH"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StreamingFormatUNKNOWN StreamingFormat = "UNKNOWN"
)

//
// The reasons for the target error.
//

type StringFormatError_Reason string

const (
	StringFormatError_ReasonUNKNOWN StringFormatError_Reason = "UNKNOWN"

	//
	// The input string value contains disallowed characters.
	//
	StringFormatError_ReasonILLEGAL_CHARS StringFormatError_Reason = "ILLEGAL_CHARS"

	//
	// The input string value is invalid for the associated field.
	//
	StringFormatError_ReasonINVALID_FORMAT StringFormatError_Reason = "INVALID_FORMAT"
)

type StringLengthError_Reason string

const (
	StringLengthError_ReasonTOO_LONG StringLengthError_Reason = "TOO_LONG"

	StringLengthError_ReasonTOO_SHORT StringLengthError_Reason = "TOO_SHORT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StringLengthError_ReasonUNKNOWN StringLengthError_Reason = "UNKNOWN"
)

//
// Possible server side transcoding states.
//

type TranscodeStatus string

const (
	TranscodeStatusUNKNOWN TranscodeStatus = "UNKNOWN"

	TranscodeStatusNOT_READY TranscodeStatus = "NOT_READY"

	TranscodeStatusCOMPLETED TranscodeStatus = "COMPLETED"

	TranscodeStatusFAILED TranscodeStatus = "FAILED"

	TranscodeStatusNEEDS_TRANSCODE TranscodeStatus = "NEEDS_TRANSCODE"

	TranscodeStatusIN_PROGRESS TranscodeStatus = "IN_PROGRESS"
)

//
// Describes reasons for {@code VideoAdTagError}.
//

type VideoAdTagError_Reason string

const (

	//
	// One or more required fields are not specified in the ad tag.
	//
	VideoAdTagError_ReasonMISSING_REQUIRED_FIELDS VideoAdTagError_Reason = "MISSING_REQUIRED_FIELDS"

	//
	// Ad tag URL is not a live traffic URL. Url should start with:
	// https://pubads.g.doubleclick.net/gampad/live/ads,
	// not https://pubads.g.doubleclick.net/gampad/ads
	//
	VideoAdTagError_ReasonNO_LIVE_TRAFFIC VideoAdTagError_Reason = "NO_LIVE_TRAFFIC"

	//
	// Ad tag URL is not a VOD traffic URL. Url should start with:
	// https://pubads.g.doubleclick.net/gampad/ads , not
	// https://pubads.g.doubleclick.net/gampad/live/ads
	//
	VideoAdTagError_ReasonNO_VOD_TRAFFIC VideoAdTagError_Reason = "NO_VOD_TRAFFIC"

	//
	// URL hostname is not a valid Google Publisher Tag or Freewheel Tag host name.
	//
	VideoAdTagError_ReasonINVALID_AD_TAG_HOST VideoAdTagError_Reason = "INVALID_AD_TAG_HOST"

	//
	// Only HTTPS is supported.
	//
	VideoAdTagError_ReasonINVALID_SCHEME VideoAdTagError_Reason = "INVALID_SCHEME"

	//
	// Invalid ad output format. Settings for VAST and VMAP must be aligned.
	//
	VideoAdTagError_ReasonINVALID_AD_OUTPUT_FORMAT VideoAdTagError_Reason = "INVALID_AD_OUTPUT_FORMAT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	VideoAdTagError_ReasonUNKNOWN VideoAdTagError_Reason = "UNKNOWN"
)

type CreateLiveStreamEvents struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createLiveStreamEvents"`

	LiveStreamEvents []*LiveStreamEvent `xml:"liveStreamEvents,omitempty" json:"liveStreamEvents,omitempty"`
}

type CreateLiveStreamEventsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createLiveStreamEventsResponse"`

	Rval []*LiveStreamEvent `xml:"rval,omitempty" json:"rval,omitempty"`
}

type ApiExceptionFault ApiException

type CreateSlates struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createSlates"`

	Slates []*Slate `xml:"slates,omitempty" json:"slates,omitempty"`
}

type CreateSlatesResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createSlatesResponse"`

	Rval []*Slate `xml:"rval,omitempty" json:"rval,omitempty"`
}

type GetLiveStreamEventsByStatement struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getLiveStreamEventsByStatement"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type GetLiveStreamEventsByStatementResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getLiveStreamEventsByStatementResponse"`

	Rval *LiveStreamEventPage `xml:"rval,omitempty" json:"rval,omitempty"`
}

type GetSlatesByStatement struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getSlatesByStatement"`

	Statement *Statement `xml:"statement,omitempty" json:"statement,omitempty"`
}

type GetSlatesByStatementResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getSlatesByStatementResponse"`

	Rval *SlatePage `xml:"rval,omitempty" json:"rval,omitempty"`
}

type PerformLiveStreamEventAction struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 performLiveStreamEventAction"`

	LiveStreamEventAction *LiveStreamEventAction `xml:"liveStreamEventAction,omitempty" json:"liveStreamEventAction,omitempty"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type PerformLiveStreamEventActionResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 performLiveStreamEventActionResponse"`

	Rval *UpdateResult `xml:"rval,omitempty" json:"rval,omitempty"`
}

type PerformSlateAction struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 performSlateAction"`

	SlateAction *SlateAction `xml:"slateAction,omitempty" json:"slateAction,omitempty"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type PerformSlateActionResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 performSlateActionResponse"`

	Rval *UpdateResult `xml:"rval,omitempty" json:"rval,omitempty"`
}

type UpdateLiveStreamEvents struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateLiveStreamEvents"`

	LiveStreamEvents []*LiveStreamEvent `xml:"liveStreamEvents,omitempty" json:"liveStreamEvents,omitempty"`
}

type UpdateLiveStreamEventsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateLiveStreamEventsResponse"`

	Rval []*LiveStreamEvent `xml:"rval,omitempty" json:"rval,omitempty"`
}

type UpdateSlates struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateSlates"`

	Slates []*Slate `xml:"slates,omitempty" json:"slates,omitempty"`
}

type UpdateSlatesResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateSlatesResponse"`

	Rval []*Slate `xml:"rval,omitempty" json:"rval,omitempty"`
}

type RequestHeader SoapRequestHeader

type ResponseHeader SoapResponseHeader

type ObjectValue struct {
	*_Value
}

type ActivateLiveStreamEvents struct {
	*LiveStreamEventAction
}

type AdBreakMarkupError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *AdBreakMarkupError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ApiError struct {

	//
	// The OGNL field path to identify cause of error.
	//
	FieldPath string `xml:"fieldPath,omitempty" json:"fieldPath,omitempty"`

	//
	// A parsed copy of the field path. For example, the field path "operations[1].operand"
	// corresponds to this list: {FieldPathElement(field = "operations", index = 1),
	// FieldPathElement(field = "operand", index = null)}.
	//
	FieldPathElements []*FieldPathElement `xml:"fieldPathElements,omitempty" json:"fieldPathElements,omitempty"`

	//
	// The data that caused the error.
	//
	Trigger string `xml:"trigger,omitempty" json:"trigger,omitempty"`

	//
	// A simple string representation of the error and reason.
	//
	ErrorString string `xml:"errorString,omitempty" json:"errorString,omitempty"`
}

type ApiException struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 ApiExceptionFault"`

	*ApplicationException

	//
	// List of errors.
	//
	Errors []*ApiError `xml:"errors,omitempty" json:"errors,omitempty"`
}

type ApiVersionError struct {
	*ApiError

	Reason *ApiVersionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ApplicationException struct {

	//
	// Error message.
	//
	Message string `xml:"message,omitempty" json:"message,omitempty"`
}

type ArchiveLiveStreamEvents struct {
	*LiveStreamEventAction
}

type ArchiveSlates struct {
	*SlateAction
}

type AuthenticationError struct {
	*ApiError

	Reason *AuthenticationError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type BooleanValue struct {
	*_Value

	//
	// The boolean value.
	//
	Value bool `xml:"value,omitempty" json:"value,omitempty"`
}

type CollectionSizeError struct {
	*ApiError

	Reason *CollectionSizeError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CommonError struct {
	*ApiError

	Reason *CommonError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type DashBridge struct {

	//
	// Specifies whether to apply DASH Bridge single-period to multi-period MPD conditioning.
	//
	Enabled bool `xml:"enabled,omitempty" json:"enabled,omitempty"`
}

type Date struct {

	//
	// Year (e.g., 2009)
	//
	Year int32 `xml:"year,omitempty" json:"year,omitempty"`

	//
	// Month (1..12)
	//
	Month int32 `xml:"month,omitempty" json:"month,omitempty"`

	//
	// Day (1..31)
	//
	Day int32 `xml:"day,omitempty" json:"day,omitempty"`
}

type DateTime struct {
	Date soap.XSDDate `xml:"date,omitempty" json:"date,omitempty"`

	Hour int32 `xml:"hour,omitempty" json:"hour,omitempty"`

	Minute int32 `xml:"minute,omitempty" json:"minute,omitempty"`

	Second int32 `xml:"second,omitempty" json:"second,omitempty"`

	TimeZoneId string `xml:"timeZoneId,omitempty" json:"timeZoneId,omitempty"`
}

type DateTimeValue struct {
	*_Value

	//
	// The {@code DateTime} value.
	//
	Value soap.XSDDateTime `xml:"value,omitempty" json:"value,omitempty"`
}

type DateValue struct {
	*_Value

	//
	// The {@code Date} value.
	//
	Value soap.XSDDate `xml:"value,omitempty" json:"value,omitempty"`
}

type EntityLimitReachedError struct {
	*ApiError

	Reason *EntityLimitReachedError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FeatureError struct {
	*ApiError

	Reason *FeatureError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FieldPathElement struct {

	//
	// The name of a field in lower camelcase. (e.g. "biddingStrategy")
	//
	Field string `xml:"field,omitempty" json:"field,omitempty"`

	//
	// For list fields, this is a 0-indexed position in the list. Null for non-list fields.
	//
	Index int32 `xml:"index,omitempty" json:"index,omitempty"`
}

type HlsSettings struct {

	//
	// Indicates the type of the playlist associated with this live stream. The playlist type is
	// analogous to the EXT-X-PLAYLIST-TYPE HLS tag. This field is optional and will default to {@link
	// PlaylistType#LIVE}. This field cannot be modified after live stream creation.
	//
	PlaylistType *PlaylistType `xml:"playlistType,omitempty" json:"playlistType,omitempty"`

	//
	// The settings for the master playlist. This field is optional and if it is not set will default
	// to a {@link MasterPlaylistSettings} with a refresh type of {@link RefreshType#AUTOMATIC}.
	//
	MasterPlaylistSettings *MasterPlaylistSettings `xml:"masterPlaylistSettings,omitempty" json:"masterPlaylistSettings,omitempty"`
}

type InternalApiError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *InternalApiError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InvalidUrlError struct {
	*ApiError

	Reason *InvalidUrlError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LiveStreamConditioning struct {

	//
	// Specifies DASH Bridge single-period to multi-period MPD conditioning.
	//
	DashBridge *DashBridge `xml:"dashBridge,omitempty" json:"dashBridge,omitempty"`
}

type LiveStreamEventAction struct {
}

type LiveStreamEventActionError struct {
	*ApiError

	Reason *LiveStreamEventActionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LiveStreamEventCdnSettingsError struct {
	*ApiError

	Reason *LiveStreamEventCdnSettingsError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LiveStreamEventConditioningError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *LiveStreamEventConditioningError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LiveStreamEventCustomAssetKeyError struct {
	*ApiError

	Reason *LiveStreamEventCustomAssetKeyError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LiveStreamEventDateTimeError struct {
	*ApiError

	Reason *LiveStreamEventDateTimeError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LiveStreamEvent struct {

	//
	// The unique ID of the {@code LiveStreamEvent}. This value is read-only and is assigned by
	// Google.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// The name of the {@code LiveStreamEvent}. This value is required to create a live stream event
	// and has a maximum length of 255 characters.
	//
	Name string `xml:"name,omitempty" json:"name,omitempty"`

	//
	// The status of this {@code LiveStreamEvent}. This attribute is read-only and is assigned by
	// Google. Live stream events are created in the {@link LiveStreamEventStatus#PAUSED} state.
	//
	Status *LiveStreamEventStatus `xml:"status,omitempty" json:"status,omitempty"`

	//
	// The date and time this {@code LiveStreamEvent} was created. This attribute is read-only.
	//
	CreationDateTime soap.XSDDateTime `xml:"creationDateTime,omitempty" json:"creationDateTime,omitempty"`

	//
	// The date and time this {@code LiveStreamEvent} was last modified. This attribute is read-only.
	//
	LastModifiedDateTime soap.XSDDateTime `xml:"lastModifiedDateTime,omitempty" json:"lastModifiedDateTime,omitempty"`

	//
	// The start date and time of this {@code LiveStreamEvent}. This attribute is required if the
	// {@link LiveStreamEvent#startDateTimeType} is {@link StartDateTimeType#USE_START_DATE_TIME} and
	// is ignored for all other values of {@link StartDateTimeType}. Modifying this attribute for an
	// active live stream can impact traffic.
	//
	StartDateTime soap.XSDDateTime `xml:"startDateTime,omitempty" json:"startDateTime,omitempty"`

	//
	// Specifies whether to start the {@link LiveStreamEvent} right away, in an hour, etc. This
	// attribute is optional and defaults to {@link StartDateTimeType#USE_START_DATE_TIME}.
	//
	StartDateTimeType *StartDateTimeType `xml:"startDateTimeType,omitempty" json:"startDateTimeType,omitempty"`

	//
	// The scheduled end date and time of this {@code LiveStreamEvent}. This attribute is required if
	// {@code unlimitedEndDateTime} is false and ignored if {@code unlimitedEndDateTime} is true.
	// Modifying this attribute for an active live stream can impact traffic.
	//
	EndDateTime soap.XSDDateTime `xml:"endDateTime,omitempty" json:"endDateTime,omitempty"`

	//
	// Whether the {@link LiveStreamEvent} has an end time. This attribute is optional and defaults to
	// false. If this field is true, {@code endDateTime} is ignored.
	//
	UnlimitedEndDateTime bool `xml:"unlimitedEndDateTime,omitempty" json:"unlimitedEndDateTime,omitempty"`

	//
	// The total number of concurrent users expected to watch this live stream across all regions.
	// This attribute is optional and default value is 0.
	//
	TotalEstimatedConcurrentUsers int64 `xml:"totalEstimatedConcurrentUsers,omitempty" json:"totalEstimatedConcurrentUsers,omitempty"`

	//
	// The list of URLs pointing to the live stream content in Content Delivery Network. This
	// attribute is required and can be modified when the live stream is in a {@link
	// LiveStreamEventStatus#PAUSED} state.
	//
	ContentUrls []string `xml:"contentUrls,omitempty" json:"contentUrls,omitempty"`

	//
	// The list of Ad Manager ad tag URLs generated by the Ad Manager trafficking workflow that are
	// associated with this live stream event. Currently, the list includes only one element: the
	// master ad tag. This attribute is required.
	//
	AdTags []string `xml:"adTags,omitempty" json:"adTags,omitempty"`

	//
	// This code is used in constructing a live stream event master playlist URL. This attribute is
	// read-only and is assigned by Google. {@code liveStreamEventCode} was renamed {@code assetKey}
	// in v201911.
	//
	AssetKey string `xml:"assetKey,omitempty" json:"assetKey,omitempty"`

	//
	// ID corresponding to the slate for this live event. If not set, network default value will be
	// used.
	//
	SlateCreativeId int64 `xml:"slateCreativeId,omitempty" json:"slateCreativeId,omitempty"`

	//
	// Length of the DVR window in seconds. This value is optional. If unset the default window as
	// provided by the input encoder will be used. Modifying this value for an active live stream can
	// impact traffic.
	//
	DvrWindowSeconds int32 `xml:"dvrWindowSeconds,omitempty" json:"dvrWindowSeconds,omitempty"`

	//
	// Whether the live stream's requests to the IMA SDK API will be authenticated using the DAI
	// authentication keys.
	//
	EnableDaiAuthenticationKeys bool `xml:"enableDaiAuthenticationKeys,omitempty" json:"enableDaiAuthenticationKeys,omitempty"`

	//
	// The type of content that should be used to fill an empty ad break. This value is optional and
	// defaults to {@link AdBreakFillType#SLATE}.
	//
	AdBreakFillType *AdBreakFillType `xml:"adBreakFillType,omitempty" json:"adBreakFillType,omitempty"`

	//
	// The type of content that should be used to fill the time remaining in the ad break when there
	// are not enough ads to fill the entire break. This value is optional and defaults to {@link
	// AdBreakFillType#SLATE}. To set this field a network needs to have the "Live stream ad break
	// underfill type" feature enabled.
	//
	UnderfillAdBreakFillType *AdBreakFillType `xml:"underfillAdBreakFillType,omitempty" json:"underfillAdBreakFillType,omitempty"`

	//
	// The duration (in seconds), starting from the time the user enters the DAI stream, for which
	// mid-roll decisioning will be skipped. This field is only applicable when an ad holiday is
	// requested in the stream create request. This value is optional and defaults to 0.
	//
	AdHolidayDuration int64 `xml:"adHolidayDuration,omitempty" json:"adHolidayDuration,omitempty"`

	//
	// Whether there will be max filler duration in this live stream. If true, {@code
	// maxFillerDuration} should be specified. This field is optional and defaults to false.
	//
	EnableMaxFillerDuration bool `xml:"enableMaxFillerDuration,omitempty" json:"enableMaxFillerDuration,omitempty"`

	//
	// The maximum number of seconds that can be used to fill this ad pod, either with a slate or
	// underlying content, depending on your settings. If more time needs to be filled, the ad pod
	// will instead be dropped and the underlying content will be served.
	//
	MaxFillerDuration int64 `xml:"maxFillerDuration,omitempty" json:"maxFillerDuration,omitempty"`

	//
	// Whether there will be durationless ad breaks in this live stream. If true, {@code
	// defaultAdBreakDuration} should be specified. This field is optional and defaults to false;
	//
	EnableDurationlessAdBreaks bool `xml:"enableDurationlessAdBreaks,omitempty" json:"enableDurationlessAdBreaks,omitempty"`

	//
	// The default ad pod duration (in seconds) that will be requested when an ad break cue-out does
	// not specify a duration. This field is optional and defaults to 0;
	//
	DefaultAdBreakDuration int64 `xml:"defaultAdBreakDuration,omitempty" json:"defaultAdBreakDuration,omitempty"`

	//
	// The list of {@link DaiAuthenticationKey} IDs used to authenticate stream create requests for
	// this live stream. Modifying keys for an active live stream may break the stream for some users.
	// Exercise caution.
	//
	StreamCreateDaiAuthenticationKeyIds []int64 `xml:"streamCreateDaiAuthenticationKeyIds,omitempty" json:"streamCreateDaiAuthenticationKeyIds,omitempty"`

	//
	// The list of {@link CdnConfiguration} IDs that provide settings for ingesting and delivering the
	// videos associated with this source. Modifying settings for an active live stream may break the
	// stream for some users. Exercise caution.
	//
	SourceContentConfigurationIds []int64 `xml:"sourceContentConfigurationIds,omitempty" json:"sourceContentConfigurationIds,omitempty"`

	//
	// The settings specific to Preroll ad breaks. This field is optional. If null, this livestream
	// does not have prerolls enabled.
	//
	PrerollSettings *PrerollSettings `xml:"prerollSettings,omitempty" json:"prerollSettings,omitempty"`

	//
	// The settings that are specific to HTTPS live streaming (HLS) protocol. This field is optional
	// and if it is not set will use the default HLS settings.
	//
	HlsSettings *HlsSettings `xml:"hlsSettings,omitempty" json:"hlsSettings,omitempty"`

	//
	// Whether specific allowlisted IP addresses should be used to access this live stream. This field
	// is optional and will default to false. To set this field a network needs to have the "Video
	// live allowlisted IPS enabled" feature enabled. Modifying this field for an active live stream
	// can impact traffic.
	//
	EnableAllowlistedIps bool `xml:"enableAllowlistedIps,omitempty" json:"enableAllowlistedIps,omitempty"`

	//
	// The method of dynamic ad insertion that is used to insert ads into this live stream. This
	// attribute is optional and defaults to {@link DynamicAdInsertionType.LINEAR}. This field cannot
	// be modified after live stream creation.
	//
	DynamicAdInsertionType *DynamicAdInsertionType `xml:"dynamicAdInsertionType,omitempty" json:"dynamicAdInsertionType,omitempty"`

	//
	// Whether the served playlists can include relative URLs. This field is optional and defaults to
	// false. To set this field a network needs to have the "Video live stream relative playlist URLs"
	// feature enabled. This field can be modified when the live stream is in a {@link
	// LiveStreamEventStatus#PAUSED} state.
	//
	EnableRelativePlaylistDelivery bool `xml:"enableRelativePlaylistDelivery,omitempty" json:"enableRelativePlaylistDelivery,omitempty"`

	//
	// The streaming format of the {@link LiveStreamEvent} media. This field cannot be modified after
	// live stream creation.
	//
	StreamingFormat *StreamingFormat `xml:"streamingFormat,omitempty" json:"streamingFormat,omitempty"`

	//
	// Indicates whether the option to prefetch ad requests is enabled.
	//
	PrefetchEnabled bool `xml:"prefetchEnabled,omitempty" json:"prefetchEnabled,omitempty"`

	//
	// The information needed to prefetch ad requests for an ad break.
	//
	PrefetchSettings *PrefetchSettings `xml:"prefetchSettings,omitempty" json:"prefetchSettings,omitempty"`

	//
	// Whether live stream placement opportunities without #EXT-CUE-IN markers should be force closed.
	// This field is optional and defaults to false. To set this field a network needs to have the
	// "Video live stream forced cue in" feature enabled.
	//
	EnableForceCloseAdBreaks bool `xml:"enableForceCloseAdBreaks,omitempty" json:"enableForceCloseAdBreaks,omitempty"`

	//
	// Whether segments shorter than 1 second at the end of an ad pod should be dropped. This field is
	// optional and defaults to false. To set this field a network needs to have the "Video live
	// stream short segment dropping" feature enabled.
	//
	EnableShortSegmentDropping bool `xml:"enableShortSegmentDropping,omitempty" json:"enableShortSegmentDropping,omitempty"`

	//
	// An additional code that can be used in constructing live stream event URLs. This field is
	// immutable after creation and can only be set for pod serving live streams. The custom asset key
	// may be at most 64 characters and can contain alphanumeric characters and symbols other than the
	// following: ", ', =, !, +, #, *, ~, ;, ^, (, ), <, >, [, ], the white space character.
	//
	CustomAssetKey string `xml:"customAssetKey,omitempty" json:"customAssetKey,omitempty"`

	//
	// The list of {@code DaiEncodingProfile} IDs that will be used for this live stream event. This
	// field only applies to pod serving events. New profile IDs can be added to running live streams.
	// Profile IDs cannot be removed from running live streams. Modifying settings for an active live
	// stream may break the stream for some users. Exercise caution.
	//
	DaiEncodingProfileIds []int64 `xml:"daiEncodingProfileIds,omitempty" json:"daiEncodingProfileIds,omitempty"`

	//
	// The list of {@link DaiAuthenticationKey} IDs used to authenticate ad segment url requests for
	// this live stream. This field only applies to pod serving events. Modifying settings for an
	// active live stream may break the stream for some users. Exercise caution.
	//
	SegmentUrlAuthenticationKeyIds []int64 `xml:"segmentUrlAuthenticationKeyIds,omitempty" json:"segmentUrlAuthenticationKeyIds,omitempty"`

	//
	// The formats that will be recognized as ad break start/end markers. This field is ignored if
	// {@code adBreakMarkupTypesEnabled} is false
	//
	AdBreakMarkups []*AdBreakMarkupType `xml:"adBreakMarkups,omitempty" json:"adBreakMarkups,omitempty"`

	//
	// Whether this {@link LiveStreamEvent} is specifying a subset of supported {@code
	// adBreakMarkups}. If this field is false, all supported formats will be treated as ad break
	// start/end markers.
	//
	AdBreakMarkupTypesEnabled bool `xml:"adBreakMarkupTypesEnabled,omitempty" json:"adBreakMarkupTypesEnabled,omitempty"`

	//
	// Whether ads on this {@link LiveStreamEvent} are served by Google Ad Manager DAI or Google Ad
	// Serving.
	//
	AdServingFormat *AdServingFormat `xml:"adServingFormat,omitempty" json:"adServingFormat,omitempty"`

	//
	// The conditioning to apply to this {@link LiveStreamEvent}.
	//
	LiveStreamConditioning *LiveStreamConditioning `xml:"liveStreamConditioning,omitempty" json:"liveStreamConditioning,omitempty"`
}

type LiveStreamEventDvrWindowError struct {
	*ApiError

	Reason *LiveStreamEventDvrWindowError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LiveStreamEventPage struct {

	//
	// The size of the total result set to which this page belongs.
	//
	TotalResultSetSize int32 `xml:"totalResultSetSize,omitempty" json:"totalResultSetSize,omitempty"`

	//
	// The absolute index in the total result set on which this page begins.
	//
	StartIndex int32 `xml:"startIndex,omitempty" json:"startIndex,omitempty"`

	//
	// The collection of live stream events contained within this page.
	//
	Results []*LiveStreamEvent `xml:"results,omitempty" json:"results,omitempty"`
}

type LiveStreamEventPrerollSettingsError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *LiveStreamEventPrerollSettingsError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LiveStreamEventSlateError struct {
	*ApiError

	Reason *LiveStreamEventSlateError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type MasterPlaylistSettings struct {

	//
	// Indicates how the master playlist gets refreshed. This field is optional and defaults to {@link
	// RefreshType#AUTOMATIC}. This field can only be modified when the live stream is in a {@link
	// LiveStreamEventStatus#PAUSED} state.
	//
	RefreshType *RefreshType `xml:"refreshType,omitempty" json:"refreshType,omitempty"`
}

type NotNullError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *NotNullError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type NullError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *NullError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type NumberValue struct {
	*_Value

	//
	// The numeric value represented as a string.
	//
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

type ParseError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ParseError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PauseLiveStreamEventAds struct {
	*LiveStreamEventAction
}

type PauseLiveStreamEvents struct {
	*LiveStreamEventAction
}

type PermissionError struct {
	*ApiError

	Reason *PermissionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PrefetchSettings struct {

	//
	// The duration of the part of the break to be prefetched.
	//
	InitialAdRequestDurationSeconds int32 `xml:"initialAdRequestDurationSeconds,omitempty" json:"initialAdRequestDurationSeconds,omitempty"`
}

type PrerollSettings struct {

	//
	// The Ad Manager ad tag URL generated by the Ad Manager trafficking workflow that is associated
	// with this live stream event. This attribute is required.
	// <span class="constraint Required">This attribute is required.</span>
	//
	AdTag string `xml:"adTag,omitempty" json:"adTag,omitempty"`

	//
	// The maximum duration (in seconds) for an ad break.
	// <span class="constraint Required">This attribute is required.</span>
	//
	MaxAdPodDurationSeconds int64 `xml:"maxAdPodDurationSeconds,omitempty" json:"maxAdPodDurationSeconds,omitempty"`
}

type PublisherQueryLanguageContextError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PublisherQueryLanguageContextError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PublisherQueryLanguageSyntaxError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PublisherQueryLanguageSyntaxError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type QuotaError struct {
	*ApiError

	Reason *QuotaError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RangeError struct {
	*ApiError

	Reason *RangeError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RefreshLiveStreamEventMasterPlaylists struct {
	*LiveStreamEventAction
}

type RequiredCollectionError struct {
	*ApiError

	Reason *RequiredCollectionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequiredError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *RequiredError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequiredNumberError struct {
	*ApiError

	Reason *RequiredNumberError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ServerError struct {
	*ApiError

	Reason *ServerError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type SetValue struct {
	*_Value

	//
	// The values. They must all be the same type of {@code Value} and not contain duplicates.
	//
	Values []*_Value `xml:"values,omitempty" json:"values,omitempty"`
}

type SlateAction struct {
}

type Slate struct {

	//
	// The unique ID of the {@code Slate}. This value is read-only and is assigned by Google.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// The name of the {@code Slate}. This value is required to create a slate and has a maximum
	// length of 255 characters.
	//
	Name string `xml:"name,omitempty" json:"name,omitempty"`

	//
	// The status of this {@code Slate}. This attribute is read-only and is assigned by Google. Slates
	// are created in the {@link SlateStatus#ACTIVE} state.
	//
	Status *SlateStatus `xml:"status,omitempty" json:"status,omitempty"`

	//
	// Server side transcoding status of the current slate.
	//
	TranscodeStatus *TranscodeStatus `xml:"transcodeStatus,omitempty" json:"transcodeStatus,omitempty"`

	//
	// The location of the original asset if publisher provided and slate is externally hosted.
	//
	VideoSourceUrl string `xml:"videoSourceUrl,omitempty" json:"videoSourceUrl,omitempty"`

	//
	// The date and time this slate was last modified.
	//
	LastModifiedDateTime soap.XSDDateTime `xml:"lastModifiedDateTime,omitempty" json:"lastModifiedDateTime,omitempty"`
}

type SlatePage struct {

	//
	// The size of the total result set to which this page belongs.
	//
	TotalResultSetSize int32 `xml:"totalResultSetSize,omitempty" json:"totalResultSetSize,omitempty"`

	//
	// The absolute index in the total result set on which this page begins.
	//
	StartIndex int32 `xml:"startIndex,omitempty" json:"startIndex,omitempty"`

	//
	// The collection of live stream events contained within this page.
	//
	Results []*Slate `xml:"results,omitempty" json:"results,omitempty"`
}

type SoapRequestHeader struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 RequestHeader"`

	//
	// The network code to use in the context of a request.
	//
	NetworkCode string `xml:"networkCode,omitempty" json:"networkCode,omitempty"`

	//
	// The name of client library application.
	//
	ApplicationName string `xml:"applicationName,omitempty" json:"applicationName,omitempty"`
}

type SoapResponseHeader struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 ResponseHeader"`

	RequestId string `xml:"requestId,omitempty" json:"requestId,omitempty"`

	ResponseTime int64 `xml:"responseTime,omitempty" json:"responseTime,omitempty"`
}

type Statement struct {

	//
	// Holds the query in PQL syntax. The syntax is:<br>
	// <code>[WHERE <condition> {[AND | OR] <condition> ...}]</code><br>
	// <code>[ORDER BY <property> [ASC | DESC]]</code><br>
	// <code>[LIMIT {[<offset>,] <count>} | {<count> OFFSET <offset>}]</code><br>
	// <p>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <value></code><br>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <bind variable></code><br>
	// <code><condition> := <property> IN <list></code><br>
	// <code><condition> := <property> IS NULL</code><br>
	// <code><condition> := <property> LIKE <wildcard%match></code><br>
	// <code><bind variable> := :<name></code><br>
	// </p>
	//
	Query string `xml:"query,omitempty" json:"query,omitempty"`

	//
	// Holds keys and values for bind variables and their values. The key is the
	// name of the bind variable. The value is the literal value of the variable.
	// <p>
	// In the example {@code "WHERE status = :bindStatus ORDER BY id LIMIT 30"},
	// the bind variable, represented by {@code :bindStatus} is named {@code
	// bindStatus}, which would also be the parameter map key. The bind variable's
	// value would be represented by a parameter map value of type
	// {@link TextValue}. The final result, for example, would be an entry of
	// {@code "bindStatus" => StringParam("ACTIVE")}.
	// </p>
	//
	Values []*String_ValueMapEntry `xml:"values,omitempty" json:"values,omitempty"`
}

type StatementError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *StatementError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type StringFormatError struct {
	*ApiError

	Reason *StringFormatError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type StringLengthError struct {
	*ApiError

	Reason *StringLengthError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type String_ValueMapEntry struct {
	Key string `xml:"key,omitempty" json:"key,omitempty"`

	Value *_Value `xml:"value,omitempty" json:"value,omitempty"`
}

type TextValue struct {
	*_Value

	//
	// The string value.
	//
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

type UnarchiveSlates struct {
	*SlateAction
}

type UniqueError struct {
	*ApiError
}

type UpdateResult struct {

	//
	// The number of objects that were changed as a result of performing the
	// action.
	//
	NumChanges int32 `xml:"numChanges,omitempty" json:"numChanges,omitempty"`
}

type _Value struct {
}

type VideoAdTagError struct {
	*ApiError

	Reason *VideoAdTagError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LiveStreamEventServiceInterface interface {

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Creates new {@link LiveStreamEvent} objects.

	   <p>The following fields are required:

	   <ul>
	   <li>{@link LiveStreamEvent#name}
	   <li>{@link LiveStreamEvent#startDateTime}
	   <li>{@link LiveStreamEvent#endDateTime}
	   <li>{@link LiveStreamEvent#contentUrls}
	   <li>{@link LiveStreamEvent#adTags}
	   </ul>
	*/
	CreateLiveStreamEvents(request *CreateLiveStreamEvents) (*CreateLiveStreamEventsResponse, error)

	CreateLiveStreamEventsContext(ctx context.Context, request *CreateLiveStreamEvents) (*CreateLiveStreamEventsResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Create new slates.

	   <p>A slate creative is served as backup content in a live stream event when no other creatives
	   are eligible to be served.
	*/
	CreateSlates(request *CreateSlates) (*CreateSlatesResponse, error)

	CreateSlatesContext(ctx context.Context, request *CreateSlates) (*CreateSlatesResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Gets a {@link LiveStreamEventPage} of {@link LiveStreamEvent} objects that satisfy the given
	   {@link Statement#query}. The following fields are supported for filtering:

	   <table>
	   <tr>
	   <th scope="col">PQL Property</th> <th scope="col">Object Property</th>
	   </tr>
	   <tr>
	   <td>{@code id}</td>
	   <td>{@link LiveStreamEvent#id}</td>
	   </tr>
	   <tr>
	   <td>{@code slateCreativeId}</td>
	   <td>{@link LiveStreamEvent#slateCreativeId}</td>
	   </tr>
	   <tr>
	   <td>{@code assetKey}</td>
	   <td>{@link LiveStreamEvent#assetKey}</td>
	   </tr>
	   <tr>
	   <td>{@code streamCreateDaiAuthenticationKeyIds}</td>
	   <td>{@link LiveStreamEvent#streamCreateDaiAuthenticationKeyIds}</td>
	   </tr>
	   <tr>
	   <td>{@code dynamicAdInsertionType}</td>
	   <td>{@link LiveStreamEvent#dynamicAdInsertionType}</td>
	   </tr>
	   <tr>
	   <td>{@code streamingFormat}</td>
	   <td>{@link LiveStreamEvent#streamingFormat}</td>
	   </tr>
	   <tr>
	   <td>{@code customAssetKey}</td>
	   <td>{@link LiveStreamEvent#customAssetKey}</td>
	   </tr>
	   <tr>
	   <td>{@code daiEncodingProfileIds}</td>
	   <td>{@link LiveStreamEvent#daiEncodingProfileIds}</td>
	   </tr>
	   <tr>
	   <td>{@code segmentUrlAuthenticationKeyIds}</td>
	   <td>{@link LiveStreamEvent#segmentUrlAuthenticationKeyIds}</td>
	   </tr>
	   </table>
	*/
	GetLiveStreamEventsByStatement(request *GetLiveStreamEventsByStatement) (*GetLiveStreamEventsByStatementResponse, error)

	GetLiveStreamEventsByStatementContext(ctx context.Context, request *GetLiveStreamEventsByStatement) (*GetLiveStreamEventsByStatementResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Gets a {@link SlatePage} of {@link Slate} objects that satisfy the given {@link
	   Statement#query}. The following fields are supported for filtering:

	   <table>
	   <tr>
	   <th scope="col">PQL Property</th> <th scope="col">Object Property</th>
	   </tr>
	   <tr>
	   <td>{@code id}</td>
	   <td>{@link Slate#id}</td>
	   </tr>
	   <tr>
	   <td>{@code name}</td>
	   <td>{@link Slate#name}</td>
	   </tr>
	   <tr>
	   <td>{@code lastModifiedDateTime}</td>
	   <td>{@link Slate#lastModifiedDateTime}</td>
	   </tr>
	   </table>
	*/
	GetSlatesByStatement(request *GetSlatesByStatement) (*GetSlatesByStatementResponse, error)

	GetSlatesByStatementContext(ctx context.Context, request *GetSlatesByStatement) (*GetSlatesByStatementResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Performs actions on {@link LiveStreamEvent} objects that match the given {@link
	   Statement#query}.
	*/
	PerformLiveStreamEventAction(request *PerformLiveStreamEventAction) (*PerformLiveStreamEventActionResponse, error)

	PerformLiveStreamEventActionContext(ctx context.Context, request *PerformLiveStreamEventAction) (*PerformLiveStreamEventActionResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Performs actions on slates that match the given {@link Statement}.
	*/
	PerformSlateAction(request *PerformSlateAction) (*PerformSlateActionResponse, error)

	PerformSlateActionContext(ctx context.Context, request *PerformSlateAction) (*PerformSlateActionResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Updates the specified {@link LiveStreamEvent} objects.
	*/
	UpdateLiveStreamEvents(request *UpdateLiveStreamEvents) (*UpdateLiveStreamEventsResponse, error)

	UpdateLiveStreamEventsContext(ctx context.Context, request *UpdateLiveStreamEvents) (*UpdateLiveStreamEventsResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Update existing slates.

	   <p>Only the slateName is editable.
	*/
	UpdateSlates(request *UpdateSlates) (*UpdateSlatesResponse, error)

	UpdateSlatesContext(ctx context.Context, request *UpdateSlates) (*UpdateSlatesResponse, error)
}

type liveStreamEventServiceInterface struct {
	client *soap.Client
}

func NewLiveStreamEventServiceInterface(client *soap.Client) LiveStreamEventServiceInterface {
	return &liveStreamEventServiceInterface{
		client: client,
	}
}

func (service *liveStreamEventServiceInterface) CreateLiveStreamEventsContext(ctx context.Context, request *CreateLiveStreamEvents) (*CreateLiveStreamEventsResponse, error) {
	response := new(CreateLiveStreamEventsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *liveStreamEventServiceInterface) CreateLiveStreamEvents(request *CreateLiveStreamEvents) (*CreateLiveStreamEventsResponse, error) {
	return service.CreateLiveStreamEventsContext(
		context.Background(),
		request,
	)
}

func (service *liveStreamEventServiceInterface) CreateSlatesContext(ctx context.Context, request *CreateSlates) (*CreateSlatesResponse, error) {
	response := new(CreateSlatesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *liveStreamEventServiceInterface) CreateSlates(request *CreateSlates) (*CreateSlatesResponse, error) {
	return service.CreateSlatesContext(
		context.Background(),
		request,
	)
}

func (service *liveStreamEventServiceInterface) GetLiveStreamEventsByStatementContext(ctx context.Context, request *GetLiveStreamEventsByStatement) (*GetLiveStreamEventsByStatementResponse, error) {
	response := new(GetLiveStreamEventsByStatementResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *liveStreamEventServiceInterface) GetLiveStreamEventsByStatement(request *GetLiveStreamEventsByStatement) (*GetLiveStreamEventsByStatementResponse, error) {
	return service.GetLiveStreamEventsByStatementContext(
		context.Background(),
		request,
	)
}

func (service *liveStreamEventServiceInterface) GetSlatesByStatementContext(ctx context.Context, request *GetSlatesByStatement) (*GetSlatesByStatementResponse, error) {
	response := new(GetSlatesByStatementResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *liveStreamEventServiceInterface) GetSlatesByStatement(request *GetSlatesByStatement) (*GetSlatesByStatementResponse, error) {
	return service.GetSlatesByStatementContext(
		context.Background(),
		request,
	)
}

func (service *liveStreamEventServiceInterface) PerformLiveStreamEventActionContext(ctx context.Context, request *PerformLiveStreamEventAction) (*PerformLiveStreamEventActionResponse, error) {
	response := new(PerformLiveStreamEventActionResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *liveStreamEventServiceInterface) PerformLiveStreamEventAction(request *PerformLiveStreamEventAction) (*PerformLiveStreamEventActionResponse, error) {
	return service.PerformLiveStreamEventActionContext(
		context.Background(),
		request,
	)
}

func (service *liveStreamEventServiceInterface) PerformSlateActionContext(ctx context.Context, request *PerformSlateAction) (*PerformSlateActionResponse, error) {
	response := new(PerformSlateActionResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *liveStreamEventServiceInterface) PerformSlateAction(request *PerformSlateAction) (*PerformSlateActionResponse, error) {
	return service.PerformSlateActionContext(
		context.Background(),
		request,
	)
}

func (service *liveStreamEventServiceInterface) UpdateLiveStreamEventsContext(ctx context.Context, request *UpdateLiveStreamEvents) (*UpdateLiveStreamEventsResponse, error) {
	response := new(UpdateLiveStreamEventsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *liveStreamEventServiceInterface) UpdateLiveStreamEvents(request *UpdateLiveStreamEvents) (*UpdateLiveStreamEventsResponse, error) {
	return service.UpdateLiveStreamEventsContext(
		context.Background(),
		request,
	)
}

func (service *liveStreamEventServiceInterface) UpdateSlatesContext(ctx context.Context, request *UpdateSlates) (*UpdateSlatesResponse, error) {
	response := new(UpdateSlatesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *liveStreamEventServiceInterface) UpdateSlates(request *UpdateSlates) (*UpdateSlatesResponse, error) {
	return service.UpdateSlatesContext(
		context.Background(),
		request,
	)
}
