// Code generated by gowsdl DO NOT EDIT.

package audiencesegment

import (
	"context"
	"encoding/xml"
	"github.com/hooklift/gowsdl/soap"
	"time"
)

// against "unused imports"
var _ time.Time
var _ xml.Name

type AnyType struct {
	InnerXML string `xml:",innerxml"`
}

type AnyURI string

type NCName string

type ApiVersionError_Reason string

const (

	//
	// Indicates that the operation is not allowed in the version the request
	// was made in.
	//
	ApiVersionError_ReasonUPDATE_TO_NEWER_VERSION ApiVersionError_Reason = "UPDATE_TO_NEWER_VERSION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ApiVersionError_ReasonUNKNOWN ApiVersionError_Reason = "UNKNOWN"
)

//
// Approval status values for {@link ThirdPartyAudienceSegment} objects.
//

type AudienceSegmentApprovalStatus string

const (

	//
	// Specifies that this segment is waiting to be approved or rejected. It cannot be targeted.
	//
	AudienceSegmentApprovalStatusUNAPPROVED AudienceSegmentApprovalStatus = "UNAPPROVED"

	//
	// Specifies that this segment is approved and can be targeted.
	//
	AudienceSegmentApprovalStatusAPPROVED AudienceSegmentApprovalStatus = "APPROVED"

	//
	// Specifies that this segment is rejected and cannot be targeted.
	//
	AudienceSegmentApprovalStatusREJECTED AudienceSegmentApprovalStatus = "REJECTED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AudienceSegmentApprovalStatusUNKNOWN AudienceSegmentApprovalStatus = "UNKNOWN"
)

type AuthenticationError_Reason string

const (

	//
	// The SOAP message contains a request header with an ambiguous definition of the authentication
	// header fields. This means either the {@code authToken} and {@code oAuthToken} fields were
	// both null or both were specified. Exactly one value should be specified with each request.
	//
	AuthenticationError_ReasonAMBIGUOUS_SOAP_REQUEST_HEADER AuthenticationError_Reason = "AMBIGUOUS_SOAP_REQUEST_HEADER"

	//
	// The login provided is invalid.
	//
	AuthenticationError_ReasonINVALID_EMAIL AuthenticationError_Reason = "INVALID_EMAIL"

	//
	// Tried to authenticate with provided information, but failed.
	//
	AuthenticationError_ReasonAUTHENTICATION_FAILED AuthenticationError_Reason = "AUTHENTICATION_FAILED"

	//
	// The OAuth provided is invalid.
	//
	AuthenticationError_ReasonINVALID_OAUTH_SIGNATURE AuthenticationError_Reason = "INVALID_OAUTH_SIGNATURE"

	//
	// The specified service to use was not recognized.
	//
	AuthenticationError_ReasonINVALID_SERVICE AuthenticationError_Reason = "INVALID_SERVICE"

	//
	// The SOAP message is missing a request header with an {@code authToken} and optional {@code
	// networkCode}.
	//
	AuthenticationError_ReasonMISSING_SOAP_REQUEST_HEADER AuthenticationError_Reason = "MISSING_SOAP_REQUEST_HEADER"

	//
	// The HTTP request is missing a request header with an {@code authToken}
	//
	AuthenticationError_ReasonMISSING_AUTHENTICATION_HTTP_HEADER AuthenticationError_Reason = "MISSING_AUTHENTICATION_HTTP_HEADER"

	//
	// The request is missing an {@code authToken}
	//
	AuthenticationError_ReasonMISSING_AUTHENTICATION AuthenticationError_Reason = "MISSING_AUTHENTICATION"

	//
	// The network does not have API access enabled.
	//
	AuthenticationError_ReasonNETWORK_API_ACCESS_DISABLED AuthenticationError_Reason = "NETWORK_API_ACCESS_DISABLED"

	//
	// The user is not associated with any network.
	//
	AuthenticationError_ReasonNO_NETWORKS_TO_ACCESS AuthenticationError_Reason = "NO_NETWORKS_TO_ACCESS"

	//
	// No network for the given {@code networkCode} was found.
	//
	AuthenticationError_ReasonNETWORK_NOT_FOUND AuthenticationError_Reason = "NETWORK_NOT_FOUND"

	//
	// The user has access to more than one network, but did not provide a {@code networkCode}.
	//
	AuthenticationError_ReasonNETWORK_CODE_REQUIRED AuthenticationError_Reason = "NETWORK_CODE_REQUIRED"

	//
	// An error happened on the server side during connection to authentication service.
	//
	AuthenticationError_ReasonCONNECTION_ERROR AuthenticationError_Reason = "CONNECTION_ERROR"

	//
	// The user tried to create a test network using an account that already is associated with a
	// network.
	//
	AuthenticationError_ReasonGOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK AuthenticationError_Reason = "GOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK"

	//
	// The account is blocked and under investigation by the collections team. Please contact Google
	// for more information.
	//
	AuthenticationError_ReasonUNDER_INVESTIGATION AuthenticationError_Reason = "UNDER_INVESTIGATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AuthenticationError_ReasonUNKNOWN AuthenticationError_Reason = "UNKNOWN"
)

type CollectionSizeError_Reason string

const (
	CollectionSizeError_ReasonTOO_LARGE CollectionSizeError_Reason = "TOO_LARGE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CollectionSizeError_ReasonUNKNOWN CollectionSizeError_Reason = "UNKNOWN"
)

//
// Describes reasons for common errors
//

type CommonError_Reason string

const (

	//
	// Indicates that an attempt was made to retrieve an entity that does not
	// exist.
	//
	CommonError_ReasonNOT_FOUND CommonError_Reason = "NOT_FOUND"

	//
	// Indicates that an attempt was made to create an entity that already
	// exists.
	//
	CommonError_ReasonALREADY_EXISTS CommonError_Reason = "ALREADY_EXISTS"

	//
	// Indicates that a value is not applicable for given use case.
	//
	CommonError_ReasonNOT_APPLICABLE CommonError_Reason = "NOT_APPLICABLE"

	//
	// Indicates that two elements in the collection were identical.
	//
	CommonError_ReasonDUPLICATE_OBJECT CommonError_Reason = "DUPLICATE_OBJECT"

	//
	// Indicates that an attempt was made to change an immutable field.
	//
	CommonError_ReasonCANNOT_UPDATE CommonError_Reason = "CANNOT_UPDATE"

	//
	// Indicates that the requested operation is not supported.
	//
	CommonError_ReasonUNSUPPORTED_OPERATION CommonError_Reason = "UNSUPPORTED_OPERATION"

	//
	// Indicates that another request attempted to update the same data in the same network
	// at about the same time. Please wait and try the request again.
	//
	CommonError_ReasonCONCURRENT_MODIFICATION CommonError_Reason = "CONCURRENT_MODIFICATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CommonError_ReasonUNKNOWN CommonError_Reason = "UNKNOWN"
)

//
// Specifies the available comparison operators.
//

type CustomCriteria_ComparisonOperator string

const (
	CustomCriteria_ComparisonOperatorIS CustomCriteria_ComparisonOperator = "IS"

	CustomCriteria_ComparisonOperatorIS_NOT CustomCriteria_ComparisonOperator = "IS_NOT"
)

//
// Specifies the available logical operators.
//

type CustomCriteriaSet_LogicalOperator string

const (
	CustomCriteriaSet_LogicalOperatorAND CustomCriteriaSet_LogicalOperator = "AND"

	CustomCriteriaSet_LogicalOperatorOR CustomCriteriaSet_LogicalOperator = "OR"
)

//
// Specifies the available comparison operators.
//

type CmsMetadataCriteria_ComparisonOperator string

const (
	CmsMetadataCriteria_ComparisonOperatorEQUALS CmsMetadataCriteria_ComparisonOperator = "EQUALS"

	CmsMetadataCriteria_ComparisonOperatorNOT_EQUALS CmsMetadataCriteria_ComparisonOperator = "NOT_EQUALS"
)

//
// The reasons for the target error.
//

type CustomTargetingError_Reason string

const (

	//
	// Requested {@link CustomTargetingKey} is not found.
	//
	CustomTargetingError_ReasonKEY_NOT_FOUND CustomTargetingError_Reason = "KEY_NOT_FOUND"

	//
	// Number of {@link CustomTargetingKey} objects created exceeds the limit
	// allowed for the network.
	//
	CustomTargetingError_ReasonKEY_COUNT_TOO_LARGE CustomTargetingError_Reason = "KEY_COUNT_TOO_LARGE"

	//
	// {@link CustomTargetingKey} with the same {@link CustomTargetingKey#name}
	// already exists.
	//
	CustomTargetingError_ReasonKEY_NAME_DUPLICATE CustomTargetingError_Reason = "KEY_NAME_DUPLICATE"

	//
	// {@link CustomTargetingKey#name} is empty.
	//
	CustomTargetingError_ReasonKEY_NAME_EMPTY CustomTargetingError_Reason = "KEY_NAME_EMPTY"

	//
	// {@link CustomTargetingKey#name} is too long.
	//
	CustomTargetingError_ReasonKEY_NAME_INVALID_LENGTH CustomTargetingError_Reason = "KEY_NAME_INVALID_LENGTH"

	//
	// {@link CustomTargetingKey#name} contains unsupported or reserved
	// characters.
	//
	CustomTargetingError_ReasonKEY_NAME_INVALID_CHARS CustomTargetingError_Reason = "KEY_NAME_INVALID_CHARS"

	//
	// {@link CustomTargetingKey#name} matches one of the reserved custom
	// targeting key names.
	//
	CustomTargetingError_ReasonKEY_NAME_RESERVED CustomTargetingError_Reason = "KEY_NAME_RESERVED"

	//
	// {@link CustomTargetingKey#displayName} is too long.
	//
	CustomTargetingError_ReasonKEY_DISPLAY_NAME_INVALID_LENGTH CustomTargetingError_Reason = "KEY_DISPLAY_NAME_INVALID_LENGTH"

	//
	// Key is not active.
	//
	CustomTargetingError_ReasonKEY_STATUS_NOT_ACTIVE CustomTargetingError_Reason = "KEY_STATUS_NOT_ACTIVE"

	//
	// Requested {@link CustomTargetingValue} is not found.
	//
	CustomTargetingError_ReasonVALUE_NOT_FOUND CustomTargetingError_Reason = "VALUE_NOT_FOUND"

	//
	// The {@code WHERE} clause in the {@link Statement#query} must always
	// contain {@link CustomTargetingValue#customTargetingKeyId} as one of its
	// columns in a way that it is AND'ed with the rest of the query.
	//
	CustomTargetingError_ReasonGET_VALUES_BY_STATEMENT_MUST_CONTAIN_KEY_ID CustomTargetingError_Reason = "GET_VALUES_BY_STATEMENT_MUST_CONTAIN_KEY_ID"

	//
	// The number of {@link CustomTargetingValue} objects associated with a
	// {@link CustomTargetingKey} exceeds the network limit. This is only
	// applicable for keys of type {@code CustomTargetingKey.Type#PREDEFINED}.
	//
	CustomTargetingError_ReasonVALUE_COUNT_FOR_KEY_TOO_LARGE CustomTargetingError_Reason = "VALUE_COUNT_FOR_KEY_TOO_LARGE"

	//
	// {@link CustomTargetingValue} with the same
	// {@link CustomTargetingValue#name} already exists.
	//
	CustomTargetingError_ReasonVALUE_NAME_DUPLICATE CustomTargetingError_Reason = "VALUE_NAME_DUPLICATE"

	//
	// {@link CustomTargetingValue#name} is empty.
	//
	CustomTargetingError_ReasonVALUE_NAME_EMPTY CustomTargetingError_Reason = "VALUE_NAME_EMPTY"

	//
	// {@link CustomTargetingValue#name} is too long.
	//
	CustomTargetingError_ReasonVALUE_NAME_INVALID_LENGTH CustomTargetingError_Reason = "VALUE_NAME_INVALID_LENGTH"

	//
	// {@link CustomTargetingValue#name} contains unsupported or reserved
	// characters.
	//
	CustomTargetingError_ReasonVALUE_NAME_INVALID_CHARS CustomTargetingError_Reason = "VALUE_NAME_INVALID_CHARS"

	//
	// {@link CustomTargetingValue#displayName} is too long.
	//
	CustomTargetingError_ReasonVALUE_DISPLAY_NAME_INVALID_LENGTH CustomTargetingError_Reason = "VALUE_DISPLAY_NAME_INVALID_LENGTH"

	//
	// Only Ad Manager 360 networks can have {@link CustomTargetingValue#matchType}
	// other than {@link CustomTargetingValue.MatchType#EXACT}.
	//
	CustomTargetingError_ReasonVALUE_MATCH_TYPE_NOT_ALLOWED CustomTargetingError_Reason = "VALUE_MATCH_TYPE_NOT_ALLOWED"

	//
	// You can only create {@link CustomTargetingValue} objects with match type
	// {@link CustomTargetingValue.MatchType#EXACT} when associating
	// with {@link CustomTargetingKey} objects of type
	// {@link CustomTargetingKey.Type#PREDEFINED}
	//
	CustomTargetingError_ReasonVALUE_MATCH_TYPE_NOT_EXACT_FOR_PREDEFINED_KEY CustomTargetingError_Reason = "VALUE_MATCH_TYPE_NOT_EXACT_FOR_PREDEFINED_KEY"

	//
	// {@link CustomTargetingValue} object cannot have match type of
	// {@link CustomTargetingValue.MatchType#SUFFIX} when adding a
	// {@link CustomTargetingValue} to a line item.
	//
	CustomTargetingError_ReasonSUFFIX_MATCH_TYPE_NOT_ALLOWED CustomTargetingError_Reason = "SUFFIX_MATCH_TYPE_NOT_ALLOWED"

	//
	// {@link CustomTargetingValue} object cannot have match type of
	// {@link CustomTargetingValue.MatchType#CONTAINS} when adding a
	// {@link CustomTargetingValue} to targeting expression of a line item.
	//
	CustomTargetingError_ReasonCONTAINS_MATCH_TYPE_NOT_ALLOWED CustomTargetingError_Reason = "CONTAINS_MATCH_TYPE_NOT_ALLOWED"

	//
	// Value is not active.
	//
	CustomTargetingError_ReasonVALUE_STATUS_NOT_ACTIVE CustomTargetingError_Reason = "VALUE_STATUS_NOT_ACTIVE"

	//
	// The {@link CustomTargetingKey} does not have any
	// {@link CustomTargetingValue} associated with it.
	//
	CustomTargetingError_ReasonKEY_WITH_MISSING_VALUES CustomTargetingError_Reason = "KEY_WITH_MISSING_VALUES"

	//
	// The {@link CustomTargetingKey} has a {@link CustomTargetingValue} specified for which the
	// value is not a valid child.
	//
	CustomTargetingError_ReasonINVALID_VALUE_FOR_KEY CustomTargetingError_Reason = "INVALID_VALUE_FOR_KEY"

	//
	// {@link CustomCriteriaSet.LogicalOperator#OR} operation cannot be applied
	// to values with different keys.
	//
	CustomTargetingError_ReasonCANNOT_OR_DIFFERENT_KEYS CustomTargetingError_Reason = "CANNOT_OR_DIFFERENT_KEYS"

	//
	// Targeting expression is invalid. This can happen if the sequence of
	// operators is wrong, or a node contains invalid number of children.
	//
	CustomTargetingError_ReasonINVALID_TARGETING_EXPRESSION CustomTargetingError_Reason = "INVALID_TARGETING_EXPRESSION"

	//
	// The key has been deleted. {@link CustomCriteria} cannot have deleted
	// keys.
	//
	CustomTargetingError_ReasonDELETED_KEY_CANNOT_BE_USED_FOR_TARGETING CustomTargetingError_Reason = "DELETED_KEY_CANNOT_BE_USED_FOR_TARGETING"

	//
	// The value has been deleted. {@link CustomCriteria} cannot have deleted
	// values.
	//
	CustomTargetingError_ReasonDELETED_VALUE_CANNOT_BE_USED_FOR_TARGETING CustomTargetingError_Reason = "DELETED_VALUE_CANNOT_BE_USED_FOR_TARGETING"

	//
	// The key is set as the video browse-by key, which cannot be used for
	// custom targeting.
	//
	CustomTargetingError_ReasonVIDEO_BROWSE_BY_KEY_CANNOT_BE_USED_FOR_CUSTOM_TARGETING CustomTargetingError_Reason = "VIDEO_BROWSE_BY_KEY_CANNOT_BE_USED_FOR_CUSTOM_TARGETING"

	//
	// Only active custom-criteria keys are supported in content metadata mapping.
	//
	CustomTargetingError_ReasonCANNOT_DELETE_CUSTOM_KEY_USED_IN_CONTENT_METADATA_MAPPING CustomTargetingError_Reason = "CANNOT_DELETE_CUSTOM_KEY_USED_IN_CONTENT_METADATA_MAPPING"

	//
	// Only active custom-criteria values are supported in content metadata mapping.
	//
	CustomTargetingError_ReasonCANNOT_DELETE_CUSTOM_VALUE_USED_IN_CONTENT_METADATA_MAPPING CustomTargetingError_Reason = "CANNOT_DELETE_CUSTOM_VALUE_USED_IN_CONTENT_METADATA_MAPPING"

	//
	// Cannot delete a custom criteria key that is targeted by an active partner assignment.
	//
	CustomTargetingError_ReasonCANNOT_DELETE_CUSTOM_KEY_USED_IN_PARTNER_ASSIGNMENT_TARGETING CustomTargetingError_Reason = "CANNOT_DELETE_CUSTOM_KEY_USED_IN_PARTNER_ASSIGNMENT_TARGETING"

	//
	// Cannot delete a custom criteria value that is targeted by an active partner assignment.
	//
	CustomTargetingError_ReasonCANNOT_DELETE_CUSTOM_VALUE_USED_IN_PARTNER_ASSIGNMENT_TARGETING CustomTargetingError_Reason = "CANNOT_DELETE_CUSTOM_VALUE_USED_IN_PARTNER_ASSIGNMENT_TARGETING"

	//
	// {@link AudienceSegment} object cannot be targeted.
	//
	CustomTargetingError_ReasonCANNOT_TARGET_AUDIENCE_SEGMENT CustomTargetingError_Reason = "CANNOT_TARGET_AUDIENCE_SEGMENT"

	//
	// Third party {@link AudienceSegment} cannot be targeted.
	//
	CustomTargetingError_ReasonCANNOT_TARGET_THIRD_PARTY_AUDIENCE_SEGMENT CustomTargetingError_Reason = "CANNOT_TARGET_THIRD_PARTY_AUDIENCE_SEGMENT"

	//
	// Inactive {@link AudienceSegment} object cannot be targeted.
	//
	CustomTargetingError_ReasonCANNOT_TARGET_INACTIVE_AUDIENCE_SEGMENT CustomTargetingError_Reason = "CANNOT_TARGET_INACTIVE_AUDIENCE_SEGMENT"

	//
	// Targeted {@link AudienceSegment} object is not valid.
	//
	CustomTargetingError_ReasonINVALID_AUDIENCE_SEGMENTS CustomTargetingError_Reason = "INVALID_AUDIENCE_SEGMENTS"

	//
	// Mapped metadata key-values are deprecated and cannot be targeted.
	//
	CustomTargetingError_ReasonCANNOT_TARGET_MAPPED_METADATA CustomTargetingError_Reason = "CANNOT_TARGET_MAPPED_METADATA"

	//
	// Targeted {@link AudienceSegment} objects have not been approved.
	//
	CustomTargetingError_ReasonONLY_APPROVED_AUDIENCE_SEGMENTS_CAN_BE_TARGETED CustomTargetingError_Reason = "ONLY_APPROVED_AUDIENCE_SEGMENTS_CAN_BE_TARGETED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CustomTargetingError_ReasonUNKNOWN CustomTargetingError_Reason = "UNKNOWN"
)

//
// Specifies the available comparison operators.
//

type AudienceSegmentCriteria_ComparisonOperator string

const (
	AudienceSegmentCriteria_ComparisonOperatorIS AudienceSegmentCriteria_ComparisonOperator = "IS"

	AudienceSegmentCriteria_ComparisonOperatorIS_NOT AudienceSegmentCriteria_ComparisonOperator = "IS_NOT"
)

//
// The reasons for the entity children limit reached error.
//

type EntityChildrenLimitReachedError_Reason string

const (

	//
	// The number of line items on the order exceeds the max number of line items allowed per order
	// in the network.
	//
	EntityChildrenLimitReachedError_ReasonLINE_ITEM_LIMIT_FOR_ORDER_REACHED EntityChildrenLimitReachedError_Reason = "LINE_ITEM_LIMIT_FOR_ORDER_REACHED"

	//
	// The number of creatives associated with the line item exceeds the max number of creatives
	// allowed to be associated with a line item in the network.
	//
	EntityChildrenLimitReachedError_ReasonCREATIVE_ASSOCIATION_LIMIT_FOR_LINE_ITEM_REACHED EntityChildrenLimitReachedError_Reason = "CREATIVE_ASSOCIATION_LIMIT_FOR_LINE_ITEM_REACHED"

	//
	// The number of ad units on the placement exceeds the max number of ad units
	// allowed per placement in the network.
	//
	EntityChildrenLimitReachedError_ReasonAD_UNIT_LIMIT_FOR_PLACEMENT_REACHED EntityChildrenLimitReachedError_Reason = "AD_UNIT_LIMIT_FOR_PLACEMENT_REACHED"

	//
	// The number of targeting expressions on the line item exceeds the max number of targeting
	// expressions allowed per line item in the network.
	//
	EntityChildrenLimitReachedError_ReasonTARGETING_EXPRESSION_LIMIT_FOR_LINE_ITEM_REACHED EntityChildrenLimitReachedError_Reason = "TARGETING_EXPRESSION_LIMIT_FOR_LINE_ITEM_REACHED"

	//
	// The size of a single targeting expression tree exceeds the max size allowed by the network.
	//
	EntityChildrenLimitReachedError_ReasonTARGETING_EXPRESSION_SIZE_LIMIT_REACHED EntityChildrenLimitReachedError_Reason = "TARGETING_EXPRESSION_SIZE_LIMIT_REACHED"

	//
	// The number of custom targeting values for the free-form or predefined custom targeting key
	// exceeds the max number allowed.
	//
	EntityChildrenLimitReachedError_ReasonCUSTOM_TARGETING_VALUES_FOR_KEY_LIMIT_REACHED EntityChildrenLimitReachedError_Reason = "CUSTOM_TARGETING_VALUES_FOR_KEY_LIMIT_REACHED"

	//
	// The total number of targeting expressions on the creatives for the line item exceeds
	// the max number allowed per line item in the network.
	//
	EntityChildrenLimitReachedError_ReasonTARGETING_EXPRESSION_LIMIT_FOR_CREATIVES_ON_LINE_ITEM_REACHED EntityChildrenLimitReachedError_Reason = "TARGETING_EXPRESSION_LIMIT_FOR_CREATIVES_ON_LINE_ITEM_REACHED"

	//
	// The number of attachments added to the proposal exceeds the max number
	// allowed per proposal in the network.
	//
	EntityChildrenLimitReachedError_ReasonATTACHMENT_LIMIT_FOR_PROPOSAL_REACHED EntityChildrenLimitReachedError_Reason = "ATTACHMENT_LIMIT_FOR_PROPOSAL_REACHED"

	//
	// The number of proposal line items on the proposal exceeds the max number
	// allowed per proposal in the network.
	//
	EntityChildrenLimitReachedError_ReasonPROPOSAL_LINE_ITEM_LIMIT_FOR_PROPOSAL_REACHED EntityChildrenLimitReachedError_Reason = "PROPOSAL_LINE_ITEM_LIMIT_FOR_PROPOSAL_REACHED"

	//
	// The number of product package items on the product package exceeds the max number
	// allowed per product package in the network.
	//
	EntityChildrenLimitReachedError_ReasonPRODUCT_LIMIT_FOR_PRODUCT_PACKAGE_REACHED EntityChildrenLimitReachedError_Reason = "PRODUCT_LIMIT_FOR_PRODUCT_PACKAGE_REACHED"

	//
	// The number of product template and product base rates on the rate card (including excluded
	// product base rates) exceeds the max number allowed per rate card in the network.
	//
	EntityChildrenLimitReachedError_ReasonPRODUCT_TEMPLATE_AND_PRODUCT_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED EntityChildrenLimitReachedError_Reason = "PRODUCT_TEMPLATE_AND_PRODUCT_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED"

	//
	// The number of product package item base rates on the rate card exceeds the max number
	// allowed per rate card in the network.
	//
	EntityChildrenLimitReachedError_ReasonPRODUCT_PACKAGE_ITEM_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED EntityChildrenLimitReachedError_Reason = "PRODUCT_PACKAGE_ITEM_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED"

	//
	// The number of premiums of the rate card exceeds the max number allowed per rate card
	// in the network.
	//
	EntityChildrenLimitReachedError_ReasonPREMIUM_LIMIT_FOR_RATE_CARD_REACHED EntityChildrenLimitReachedError_Reason = "PREMIUM_LIMIT_FOR_RATE_CARD_REACHED"

	//
	// The number of ad units on {@link AdExclusionRule#inventoryTargeting} exceeds the max number
	// of ad units allowed per ad exclusion rule inventory targeting in the network.
	//
	EntityChildrenLimitReachedError_ReasonAD_UNIT_LIMIT_FOR_AD_EXCLUSION_RULE_TARGETING_REACHED EntityChildrenLimitReachedError_Reason = "AD_UNIT_LIMIT_FOR_AD_EXCLUSION_RULE_TARGETING_REACHED"

	//
	// The number of native styles under the native creative template exceeds the
	// max number of native styles allowed per native creative template in the
	// network.
	//
	EntityChildrenLimitReachedError_ReasonNATIVE_STYLE_LIMIT_FOR_NATIVE_AD_FORMAT_REACHED EntityChildrenLimitReachedError_Reason = "NATIVE_STYLE_LIMIT_FOR_NATIVE_AD_FORMAT_REACHED"

	//
	// The number of targeting expressions on the native style exceeds the max number of targeting
	// expressions allowed per native style in the network.
	//
	EntityChildrenLimitReachedError_ReasonTARGETING_EXPRESSION_LIMIT_FOR_PRESENTATION_ASSIGNMENT_REACHED EntityChildrenLimitReachedError_Reason = "TARGETING_EXPRESSION_LIMIT_FOR_PRESENTATION_ASSIGNMENT_REACHED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityChildrenLimitReachedError_ReasonUNKNOWN EntityChildrenLimitReachedError_Reason = "UNKNOWN"
)

//
// The reasons for the entity limit reached error.
//

type EntityLimitReachedError_Reason string

const (

	//
	// The number of custom targeting values exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonCUSTOM_TARGETING_VALUES_LIMIT_REACHED EntityLimitReachedError_Reason = "CUSTOM_TARGETING_VALUES_LIMIT_REACHED"

	//
	// The number of ad exclusion rules exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonAD_EXCLUSION_RULES_LIMIT_REACHED EntityLimitReachedError_Reason = "AD_EXCLUSION_RULES_LIMIT_REACHED"

	//
	// The number of first party audience segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonFIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "FIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED"

	//
	// The number of active placements exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonPLACEMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "PLACEMENTS_LIMIT_REACHED"

	//
	// The number of line items excceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonLINE_ITEMS_LIMIT_REACHED EntityLimitReachedError_Reason = "LINE_ITEMS_LIMIT_REACHED"

	//
	// The number of active line items exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonACTIVE_LINE_ITEMS_LIMIT_REACHED EntityLimitReachedError_Reason = "ACTIVE_LINE_ITEMS_LIMIT_REACHED"

	//
	// The number of not-archived encoding profiles exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonDAI_ENCODING_PROFILES_LIMIT_REACHED EntityLimitReachedError_Reason = "DAI_ENCODING_PROFILES_LIMIT_REACHED"

	//
	// The number of traffic forecast segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonTRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "TRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED"

	//
	// The number of forecast adjustments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonFORECAST_ADJUSTMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "FORECAST_ADJUSTMENTS_LIMIT_REACHED"

	//
	// The number of active experiments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonACTIVE_EXPERIMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "ACTIVE_EXPERIMENTS_LIMIT_REACHED"

	//
	// The number of sites exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonSITES_LIMIT_REACHED EntityLimitReachedError_Reason = "SITES_LIMIT_REACHED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityLimitReachedError_ReasonUNKNOWN EntityLimitReachedError_Reason = "UNKNOWN"
)

type FeatureError_Reason string

const (

	//
	// A feature is being used that is not enabled on the current network.
	//
	FeatureError_ReasonMISSING_FEATURE FeatureError_Reason = "MISSING_FEATURE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FeatureError_ReasonUNKNOWN FeatureError_Reason = "UNKNOWN"
)

//
// The single reason for the internal API error.
//

type InternalApiError_Reason string

const (

	//
	// API encountered an unexpected internal error.
	//
	InternalApiError_ReasonUNEXPECTED_INTERNAL_API_ERROR InternalApiError_Reason = "UNEXPECTED_INTERNAL_API_ERROR"

	//
	// A temporary error occurred during the request. Please retry.
	//
	InternalApiError_ReasonTRANSIENT_ERROR InternalApiError_Reason = "TRANSIENT_ERROR"

	//
	// The cause of the error is not known or only defined in newer versions.
	//
	InternalApiError_ReasonUNKNOWN InternalApiError_Reason = "UNKNOWN"

	//
	// The API is currently unavailable for a planned downtime.
	//
	InternalApiError_ReasonDOWNTIME InternalApiError_Reason = "DOWNTIME"

	//
	// Mutate succeeded but server was unable to build response. Client should not retry mutate.
	//
	InternalApiError_ReasonERROR_GENERATING_RESPONSE InternalApiError_Reason = "ERROR_GENERATING_RESPONSE"
)

//
// Specifies the license type of a {@link ThirdPartyAudienceSegment}.
//

type LicenseType string

const (

	//
	// A direct license is the result of a direct contract between the data provider and the
	// publisher.
	//
	LicenseTypeDIRECT_LICENSE LicenseType = "DIRECT_LICENSE"

	//
	// A global license is the result of an agreement between Google and the data provider, which
	// agrees to license their audience segments to all the publishers and/or advertisers of the
	// Google ecosystem.
	//
	LicenseTypeGLOBAL_LICENSE LicenseType = "GLOBAL_LICENSE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LicenseTypeUNKNOWN LicenseType = "UNKNOWN"
)

//
// The reasons for the target error.
//

type NotNullError_Reason string

const (

	//
	// Assuming that a method will not have more than 3 arguments, if it does,
	// return NULL
	//
	NotNullError_ReasonARG1_NULL NotNullError_Reason = "ARG1_NULL"

	NotNullError_ReasonARG2_NULL NotNullError_Reason = "ARG2_NULL"

	NotNullError_ReasonARG3_NULL NotNullError_Reason = "ARG3_NULL"

	NotNullError_ReasonNULL NotNullError_Reason = "NULL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NotNullError_ReasonUNKNOWN NotNullError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ParseError_Reason string

const (

	//
	// Indicates an error in parsing an attribute.
	//
	ParseError_ReasonUNPARSABLE ParseError_Reason = "UNPARSABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ParseError_ReasonUNKNOWN ParseError_Reason = "UNKNOWN"
)

//
// Describes reasons for permission errors.
//

type PermissionError_Reason string

const (

	//
	// User does not have the required permission for the request.
	//
	PermissionError_ReasonPERMISSION_DENIED PermissionError_Reason = "PERMISSION_DENIED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PermissionError_ReasonUNKNOWN PermissionError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PublisherQueryLanguageContextError_Reason string

const (

	//
	// Indicates that there was an error executing the PQL.
	//
	PublisherQueryLanguageContextError_ReasonUNEXECUTABLE PublisherQueryLanguageContextError_Reason = "UNEXECUTABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageContextError_ReasonUNKNOWN PublisherQueryLanguageContextError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PublisherQueryLanguageSyntaxError_Reason string

const (

	//
	// Indicates that there was a PQL syntax error.
	//
	PublisherQueryLanguageSyntaxError_ReasonUNPARSABLE PublisherQueryLanguageSyntaxError_Reason = "UNPARSABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageSyntaxError_ReasonUNKNOWN PublisherQueryLanguageSyntaxError_Reason = "UNKNOWN"
)

type QuotaError_Reason string

const (

	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>Another way to mitigate this error is to limit requests to 8 per second for Ad Manager
	// 360 accounts, or 2 per second for Ad Manager accounts. Once again
	// this does not guarantee that every request will succeed, but may help
	// reduce the number of times you receive this error.
	//
	QuotaError_ReasonEXCEEDED_QUOTA QuotaError_Reason = "EXCEEDED_QUOTA"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	QuotaError_ReasonUNKNOWN QuotaError_Reason = "UNKNOWN"

	//
	// This user has exceeded the allowed number of new report requests per hour
	// (this includes both reports run via the UI and reports
	// run via {@link ReportService#runReportJob}).
	// The recommended approach to handle this error is to wait about 10 minutes
	// and then retry the request. Note that this does not guarantee the request
	// will succeed. If it fails again, try increasing the wait time.
	// <p>Another way to mitigate this error is to limit the number of new report
	// requests to 250 per hour per user. Once again, this does not guarantee that
	// every request will succeed, but may help reduce the number of times you
	// receive this error.
	//
	QuotaError_ReasonREPORT_JOB_LIMIT QuotaError_Reason = "REPORT_JOB_LIMIT"

	//
	// This network has exceeded the allowed number of identifiers uploaded within a 24 hour period.
	// The recommended approach to handle this error is to wait 30 minutes and then retry the
	// request. Note that this does not guarantee the request will succeed. If it fails again, try
	// increasing the wait time.
	//
	QuotaError_ReasonSEGMENT_POPULATION_LIMIT QuotaError_Reason = "SEGMENT_POPULATION_LIMIT"
)

type RequiredCollectionError_Reason string

const (

	//
	// A required collection is missing.
	//
	RequiredCollectionError_ReasonREQUIRED RequiredCollectionError_Reason = "REQUIRED"

	//
	// Collection size is too large.
	//
	RequiredCollectionError_ReasonTOO_LARGE RequiredCollectionError_Reason = "TOO_LARGE"

	//
	// Collection size is too small.
	//
	RequiredCollectionError_ReasonTOO_SMALL RequiredCollectionError_Reason = "TOO_SMALL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredCollectionError_ReasonUNKNOWN RequiredCollectionError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type RequiredError_Reason string

const (

	//
	// Missing required field.
	//
	RequiredError_ReasonREQUIRED RequiredError_Reason = "REQUIRED"
)

//
// Specifies types for {@link AudienceSegment} objects.
//

type AudienceSegment_Type string

const (

	//
	// First party segments created and owned by the publisher.
	//
	AudienceSegment_TypeFIRST_PARTY AudienceSegment_Type = "FIRST_PARTY"

	//
	// First party segments shared by other clients.
	//
	AudienceSegment_TypeSHARED AudienceSegment_Type = "SHARED"

	//
	// Third party segments licensed by the publisher from data providers. This doesn't include
	// Google-provided licensed segments.
	//
	AudienceSegment_TypeTHIRD_PARTY AudienceSegment_Type = "THIRD_PARTY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AudienceSegment_TypeUNKNOWN AudienceSegment_Type = "UNKNOWN"
)

//
// Specifies the statuses for {@link AudienceSegment} objects.
//

type AudienceSegment_Status string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AudienceSegment_StatusUNKNOWN AudienceSegment_Status = "UNKNOWN"

	//
	// Active status means this audience segment is available for targeting.
	//
	AudienceSegment_StatusACTIVE AudienceSegment_Status = "ACTIVE"

	//
	// Inactive status means this audience segment is not available for targeting.
	//
	AudienceSegment_StatusINACTIVE AudienceSegment_Status = "INACTIVE"

	//
	// Unused status means this audience segment was deactivated by Google because it is unused.
	//
	AudienceSegment_StatusUNUSED AudienceSegment_Status = "UNUSED"
)

//
// Reason of the given {@link AudienceSegmentError}.
//

type AudienceSegmentError_Reason string

const (

	//
	// First party audience segment is not supported.
	//
	AudienceSegmentError_ReasonFIRST_PARTY_AUDIENCE_SEGMENT_NOT_SUPPORTED AudienceSegmentError_Reason = "FIRST_PARTY_AUDIENCE_SEGMENT_NOT_SUPPORTED"

	//
	// Only rule-based first-party audience segments can be created.
	//
	AudienceSegmentError_ReasonONLY_RULE_BASED_FIRST_PARTY_AUDIENCE_SEGMENTS_CAN_BE_CREATED AudienceSegmentError_Reason = "ONLY_RULE_BASED_FIRST_PARTY_AUDIENCE_SEGMENTS_CAN_BE_CREATED"

	//
	// Audience segment for the given id is not found.
	//
	AudienceSegmentError_ReasonAUDIENCE_SEGMENT_ID_NOT_FOUND AudienceSegmentError_Reason = "AUDIENCE_SEGMENT_ID_NOT_FOUND"

	//
	// Audience segment rule is invalid.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_RULE AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_RULE"

	//
	// Audience segment rule contains too many ad units and/or custom criteria.
	//
	AudienceSegmentError_ReasonAUDIENCE_SEGMENT_RULE_TOO_LONG AudienceSegmentError_Reason = "AUDIENCE_SEGMENT_RULE_TOO_LONG"

	//
	// Audience segment name is invalid.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_NAME AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_NAME"

	//
	// Audience segment with this name already exists.
	//
	AudienceSegmentError_ReasonDUPLICATE_AUDIENCE_SEGMENT_NAME AudienceSegmentError_Reason = "DUPLICATE_AUDIENCE_SEGMENT_NAME"

	//
	// Audience segment description is invalid.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_DESCRIPTION AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_DESCRIPTION"

	//
	// Audience segment pageviews value is invalid. It must be between 1 and 12.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_PAGEVIEWS AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_PAGEVIEWS"

	//
	// Audience segment recency value is invalid. It must be between 1 and 90 if pageviews > 1.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_RECENCY AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_RECENCY"

	//
	// Audience segment membership expiration value is invalid. It must be between 1 and 180.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_MEMBERSHIP_EXPIRATION AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_MEMBERSHIP_EXPIRATION"

	//
	// The given custom key cannot be part of audience segment rule due to unsupported characters.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_CUSTOM_KEY_NAME AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_CUSTOM_KEY_NAME"

	//
	// The given custom value cannot be part of audience segment rule due to unsupported characters.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_NAME AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_NAME"

	//
	// Broad-match custom value cannot be part of audience segment rule.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_MATCH_TYPE AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_MATCH_TYPE"

	//
	// Audience segment rule cannot contain itself.
	//
	AudienceSegmentError_ReasonINVALID_NESTED_FIRST_PARTY_AUDIENCE_SEGMENT AudienceSegmentError_Reason = "INVALID_NESTED_FIRST_PARTY_AUDIENCE_SEGMENT"

	//
	// Audience segment rule cannot contain shared selling inventory unit.
	//
	AudienceSegmentError_ReasonSHARED_SELLING_PARTNER_ROOT_CANNOT_BE_INCLUDED AudienceSegmentError_Reason = "SHARED_SELLING_PARTNER_ROOT_CANNOT_BE_INCLUDED"

	//
	// Audience segment rule cannot contain a nested third-party segment.
	//
	AudienceSegmentError_ReasonINVALID_NESTED_THIRD_PARTY_AUDIENCE_SEGMENT AudienceSegmentError_Reason = "INVALID_NESTED_THIRD_PARTY_AUDIENCE_SEGMENT"

	//
	// Audience segment rule cannot contain a nested inactive segment.
	//
	AudienceSegmentError_ReasonINACTIVE_NESTED_AUDIENCE_SEGMENT AudienceSegmentError_Reason = "INACTIVE_NESTED_AUDIENCE_SEGMENT"

	//
	// An error occurred when purchasing global licenses.
	//
	AudienceSegmentError_ReasonAUDIENCE_SEGMENT_GLOBAL_LICENSE_ERROR AudienceSegmentError_Reason = "AUDIENCE_SEGMENT_GLOBAL_LICENSE_ERROR"

	//
	// Segment cannot be activated as it violates Google's Platform Policy.
	//
	AudienceSegmentError_ReasonSEGMENT_VIOLATED_POLICY AudienceSegmentError_Reason = "SEGMENT_VIOLATED_POLICY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AudienceSegmentError_ReasonUNKNOWN AudienceSegmentError_Reason = "UNKNOWN"
)

//
// Describes reasons for server errors
//

type ServerError_Reason string

const (

	//
	// Indicates that an unexpected error occured.
	//
	ServerError_ReasonSERVER_ERROR ServerError_Reason = "SERVER_ERROR"

	//
	// Indicates that the server is currently experiencing a high load. Please
	// wait and try your request again.
	//
	ServerError_ReasonSERVER_BUSY ServerError_Reason = "SERVER_BUSY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ServerError_ReasonUNKNOWN ServerError_Reason = "UNKNOWN"
)

type StatementError_Reason string

const (

	//
	// A bind variable has not been bound to a value.
	//
	StatementError_ReasonVARIABLE_NOT_BOUND_TO_VALUE StatementError_Reason = "VARIABLE_NOT_BOUND_TO_VALUE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StatementError_ReasonUNKNOWN StatementError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type StringFormatError_Reason string

const (
	StringFormatError_ReasonUNKNOWN StringFormatError_Reason = "UNKNOWN"

	//
	// The input string value contains disallowed characters.
	//
	StringFormatError_ReasonILLEGAL_CHARS StringFormatError_Reason = "ILLEGAL_CHARS"

	//
	// The input string value is invalid for the associated field.
	//
	StringFormatError_ReasonINVALID_FORMAT StringFormatError_Reason = "INVALID_FORMAT"
)

type StringLengthError_Reason string

const (
	StringLengthError_ReasonTOO_LONG StringLengthError_Reason = "TOO_LONG"

	StringLengthError_ReasonTOO_SHORT StringLengthError_Reason = "TOO_SHORT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StringLengthError_ReasonUNKNOWN StringLengthError_Reason = "UNKNOWN"
)

type CreateAudienceSegments struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createAudienceSegments"`

	Segments []*FirstPartyAudienceSegment `xml:"segments,omitempty" json:"segments,omitempty"`
}

type CreateAudienceSegmentsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createAudienceSegmentsResponse"`

	Rval []*FirstPartyAudienceSegment `xml:"rval,omitempty" json:"rval,omitempty"`
}

type ApiExceptionFault ApiException

type GetAudienceSegmentsByStatement struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getAudienceSegmentsByStatement"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type GetAudienceSegmentsByStatementResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getAudienceSegmentsByStatementResponse"`

	Rval *AudienceSegmentPage `xml:"rval,omitempty" json:"rval,omitempty"`
}

type PerformAudienceSegmentAction struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 performAudienceSegmentAction"`

	Action *AudienceSegmentAction `xml:"action,omitempty" json:"action,omitempty"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type PerformAudienceSegmentActionResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 performAudienceSegmentActionResponse"`

	Rval *UpdateResult `xml:"rval,omitempty" json:"rval,omitempty"`
}

type UpdateAudienceSegments struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateAudienceSegments"`

	Segments []*FirstPartyAudienceSegment `xml:"segments,omitempty" json:"segments,omitempty"`
}

type UpdateAudienceSegmentsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateAudienceSegmentsResponse"`

	Rval []*FirstPartyAudienceSegment `xml:"rval,omitempty" json:"rval,omitempty"`
}

type RequestHeader SoapRequestHeader

type ResponseHeader SoapResponseHeader

type ObjectValue struct {
	*_Value
}

type ActivateAudienceSegments struct {
	*AudienceSegmentAction
}

type AdUnitTargeting struct {

	//
	// Included or excluded ad unit id.
	//
	AdUnitId string `xml:"adUnitId,omitempty" json:"adUnitId,omitempty"`

	//
	// Whether or not all descendants are included (or excluded) as part of including (or excluding)
	// this ad unit. By default, the value is {@code true} which means targeting this ad unit will
	// target all of its descendants.
	//
	IncludeDescendants bool `xml:"includeDescendants,omitempty" json:"includeDescendants,omitempty"`
}

type ApiError struct {

	//
	// The OGNL field path to identify cause of error.
	//
	FieldPath string `xml:"fieldPath,omitempty" json:"fieldPath,omitempty"`

	//
	// A parsed copy of the field path. For example, the field path "operations[1].operand"
	// corresponds to this list: {FieldPathElement(field = "operations", index = 1),
	// FieldPathElement(field = "operand", index = null)}.
	//
	FieldPathElements []*FieldPathElement `xml:"fieldPathElements,omitempty" json:"fieldPathElements,omitempty"`

	//
	// The data that caused the error.
	//
	Trigger string `xml:"trigger,omitempty" json:"trigger,omitempty"`

	//
	// A simple string representation of the error and reason.
	//
	ErrorString string `xml:"errorString,omitempty" json:"errorString,omitempty"`
}

type ApiException struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 ApiExceptionFault"`

	*ApplicationException

	//
	// List of errors.
	//
	Errors []*ApiError `xml:"errors,omitempty" json:"errors,omitempty"`
}

type ApiVersionError struct {
	*ApiError

	Reason *ApiVersionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ApplicationException struct {

	//
	// Error message.
	//
	Message string `xml:"message,omitempty" json:"message,omitempty"`
}

type ApproveAudienceSegments struct {
	*AudienceSegmentAction
}

type AudienceSegmentDataProvider struct {

	//
	// Name of the data provider. This attribute is readonly and is assigned by Google.
	//
	Name string `xml:"name,omitempty" json:"name,omitempty"`
}

type AudienceSegmentPage struct {

	//
	// The size of the total result set to which this page belongs.
	//
	TotalResultSetSize int32 `xml:"totalResultSetSize,omitempty" json:"totalResultSetSize,omitempty"`

	//
	// The absolute index in the total result set on which this page begins.
	//
	StartIndex int32 `xml:"startIndex,omitempty" json:"startIndex,omitempty"`

	//
	// The collection of audience segments contained within this page.
	//
	Results []*AudienceSegment `xml:"results,omitempty" json:"results,omitempty"`
}

type AuthenticationError struct {
	*ApiError

	Reason *AuthenticationError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FirstPartyAudienceSegment struct {
	*AudienceSegment
}

type BooleanValue struct {
	*_Value

	//
	// The boolean value.
	//
	Value bool `xml:"value,omitempty" json:"value,omitempty"`
}

type CollectionSizeError struct {
	*ApiError

	Reason *CollectionSizeError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CommonError struct {
	*ApiError

	Reason *CommonError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CustomCriteria struct {
	*CustomCriteriaLeaf

	//
	// The {@link CustomTargetingKey#id} of the {@link CustomTargetingKey} object that was created
	// using {@link CustomTargetingService}. This attribute is required.
	//
	KeyId int64 `xml:"keyId,omitempty" json:"keyId,omitempty"`

	//
	// The ids of {@link CustomTargetingValue} objects to target the custom targeting key with id
	// {@link CustomCriteria#keyId}. This attribute is required.
	//
	ValueIds []int64 `xml:"valueIds,omitempty" json:"valueIds,omitempty"`

	//
	// The comparison operator. This attribute is required.
	//
	Operator *CustomCriteria_ComparisonOperator `xml:"operator,omitempty" json:"operator,omitempty"`
}

type CustomCriteriaSet struct {
	*CustomCriteriaNode

	//
	// The logical operator to be applied to {@link CustomCriteriaSet#children}. This attribute is
	// required.
	// <span class="constraint Required">This attribute is required.</span>
	//
	LogicalOperator *CustomCriteriaSet_LogicalOperator `xml:"logicalOperator,omitempty" json:"logicalOperator,omitempty"`

	//
	// The custom criteria. This attribute is required.
	//
	Children []*CustomCriteriaNode `xml:"children,omitempty" json:"children,omitempty"`
}

type CmsMetadataCriteria struct {
	*CustomCriteriaLeaf

	//
	// The comparison operator. This attribute is required.
	//
	Operator *CmsMetadataCriteria_ComparisonOperator `xml:"operator,omitempty" json:"operator,omitempty"`

	//
	// The ids of {@link CmsMetadataValue} objects used to target CMS metadata. This attribute is
	// required.
	//
	CmsMetadataValueIds []int64 `xml:"cmsMetadataValueIds,omitempty" json:"cmsMetadataValueIds,omitempty"`
}

type CustomTargetingError struct {
	*ApiError

	Reason *CustomTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CustomCriteriaLeaf struct {
	*CustomCriteriaNode
}

type CustomCriteriaNode struct {
}

type AudienceSegmentCriteria struct {
	*CustomCriteriaLeaf

	//
	// The comparison operator. This attribute is required.
	//
	Operator *AudienceSegmentCriteria_ComparisonOperator `xml:"operator,omitempty" json:"operator,omitempty"`

	//
	// The ids of {@link AudienceSegment} objects used to target audience segments. This attribute is
	// required.
	//
	AudienceSegmentIds []int64 `xml:"audienceSegmentIds,omitempty" json:"audienceSegmentIds,omitempty"`
}

type Date struct {

	//
	// Year (e.g., 2009)
	//
	Year int32 `xml:"year,omitempty" json:"year,omitempty"`

	//
	// Month (1..12)
	//
	Month int32 `xml:"month,omitempty" json:"month,omitempty"`

	//
	// Day (1..31)
	//
	Day int32 `xml:"day,omitempty" json:"day,omitempty"`
}

type DateTime struct {
	Date soap.XSDDate `xml:"date,omitempty" json:"date,omitempty"`

	Hour int32 `xml:"hour,omitempty" json:"hour,omitempty"`

	Minute int32 `xml:"minute,omitempty" json:"minute,omitempty"`

	Second int32 `xml:"second,omitempty" json:"second,omitempty"`

	TimeZoneId string `xml:"timeZoneId,omitempty" json:"timeZoneId,omitempty"`
}

type DateTimeValue struct {
	*_Value

	//
	// The {@code DateTime} value.
	//
	Value soap.XSDDateTime `xml:"value,omitempty" json:"value,omitempty"`
}

type DateValue struct {
	*_Value

	//
	// The {@code Date} value.
	//
	Value soap.XSDDate `xml:"value,omitempty" json:"value,omitempty"`
}

type DeactivateAudienceSegments struct {
	*AudienceSegmentAction
}

type EntityChildrenLimitReachedError struct {
	*ApiError

	Reason *EntityChildrenLimitReachedError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type EntityLimitReachedError struct {
	*ApiError

	Reason *EntityLimitReachedError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ThirdPartyAudienceSegment struct {
	*AudienceSegment

	//
	// Specifies if the publisher has approved or rejected the segment.
	//
	ApprovalStatus *AudienceSegmentApprovalStatus `xml:"approvalStatus,omitempty" json:"approvalStatus,omitempty"`

	//
	// Specifies CPM cost for the given segment. This attribute is readonly and is assigned by the
	// data provider.
	//
	// <p>The CPM cost comes from the active pricing, if there is one; otherwise it comes from the
	// latest pricing.
	//
	Cost *Money `xml:"cost,omitempty" json:"cost,omitempty"`

	//
	// Specifies the license type of the external segment. This attribute is read-only.
	//
	LicenseType *LicenseType `xml:"licenseType,omitempty" json:"licenseType,omitempty"`

	//
	// Specifies the date and time at which this segment becomes available for use. This attribute is
	// readonly and is assigned by the data provider.
	//
	StartDateTime soap.XSDDateTime `xml:"startDateTime,omitempty" json:"startDateTime,omitempty"`

	//
	// Specifies the date and time at which this segment ceases to be available for use. This
	// attribute is readonly and is assigned by the data provider.
	//
	EndDateTime soap.XSDDateTime `xml:"endDateTime,omitempty" json:"endDateTime,omitempty"`
}

type FeatureError struct {
	*ApiError

	Reason *FeatureError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FieldPathElement struct {

	//
	// The name of a field in lower camelcase. (e.g. "biddingStrategy")
	//
	Field string `xml:"field,omitempty" json:"field,omitempty"`

	//
	// For list fields, this is a 0-indexed position in the list. Null for non-list fields.
	//
	Index int32 `xml:"index,omitempty" json:"index,omitempty"`
}

type InternalApiError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *InternalApiError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InventoryTargeting struct {

	//
	// A list of targeted {@link AdUnitTargeting}.
	//
	TargetedAdUnits []*AdUnitTargeting `xml:"targetedAdUnits,omitempty" json:"targetedAdUnits,omitempty"`

	//
	// A list of excluded {@link AdUnitTargeting}.
	//
	ExcludedAdUnits []*AdUnitTargeting `xml:"excludedAdUnits,omitempty" json:"excludedAdUnits,omitempty"`

	//
	// A list of targeted {@link Placement} ids.
	//
	TargetedPlacementIds []int64 `xml:"targetedPlacementIds,omitempty" json:"targetedPlacementIds,omitempty"`
}

type Money struct {

	//
	// Three letter currency code in string format.
	//
	CurrencyCode string `xml:"currencyCode,omitempty" json:"currencyCode,omitempty"`

	//
	// Money values are always specified in terms of micros which are a millionth
	// of the fundamental currency unit. For US dollars, $1 is 1,000,000 micros.
	//
	MicroAmount int64 `xml:"microAmount,omitempty" json:"microAmount,omitempty"`
}

type NonRuleBasedFirstPartyAudienceSegment struct {
	*FirstPartyAudienceSegment

	//
	// Specifies the number of days after which a user's cookie will be removed from the audience
	// segment due to inactivity. This attribute is required and can be between 1 and 540.
	//
	MembershipExpirationDays int32 `xml:"membershipExpirationDays,omitempty" json:"membershipExpirationDays,omitempty"`
}

type NotNullError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *NotNullError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type NumberValue struct {
	*_Value

	//
	// The numeric value represented as a string.
	//
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

type ParseError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ParseError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PermissionError struct {
	*ApiError

	Reason *PermissionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PopulateAudienceSegments struct {
	*AudienceSegmentAction
}

type PublisherQueryLanguageContextError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PublisherQueryLanguageContextError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PublisherQueryLanguageSyntaxError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PublisherQueryLanguageSyntaxError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FirstPartyAudienceSegmentRule struct {

	//
	// Specifies the inventory (i.e. ad units and placements) that are part of the rule of a {@link
	// FirstPartyAudienceSegment}. This attribute is required.
	//
	InventoryRule *InventoryTargeting `xml:"inventoryRule,omitempty" json:"inventoryRule,omitempty"`

	//
	// Specifies the collection of custom criteria that are part of the rule of a {@link
	// FirstPartyAudienceSegment}.
	//
	// <p>Once the {@link FirstPartyAudienceSegment} is updated or modified with custom criteria, the
	// server may return a normalized, but equivalent representation of the custom criteria rule.
	//
	// <ul>
	// {@code customCriteriaRule} will have up to three levels including itself.
	// <li>The top level {@link CustomCriteriaSet} i.e. the {@code customTargeting} object can only
	// contain a {@link CustomCriteriaSet.LogicalOperator#OR} of all its children.
	// <li>The second level of {@link CustomCriteriaSet} objects can only contain {@link
	// CustomCriteriaSet.LogicalOperator#AND} of all their children. If a {@link CustomCriteria}
	// is placed on this level, the server will wrap it in a {@link CustomCriteriaSet}.
	// <li>The third level can only comprise of {@link CustomCriteria} objects.
	// </ul>
	//
	// <p>The resulting custom criteria rule would be of the form: <br>
	// <img
	// src="https://chart.apis.google.com/chart?cht=gv&chl=digraph{customTargeting_LogicalOperator_OR-%3ECustomCriteriaSet_LogicalOperator_AND_1-%3ECustomCriteria_1;CustomCriteriaSet_LogicalOperator_AND_1-%3Eellipsis1;customTargeting_LogicalOperator_OR-%3Eellipsis2;ellipsis1[label=%22...%22,shape=none,fontsize=32];ellipsis2[label=%22...%22,shape=none,fontsize=32]}&chs=450x200"/>
	//
	CustomCriteriaRule *CustomCriteriaSet `xml:"customCriteriaRule,omitempty" json:"customCriteriaRule,omitempty"`
}

type QuotaError struct {
	*ApiError

	Reason *QuotaError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RejectAudienceSegments struct {
	*AudienceSegmentAction
}

type RequiredCollectionError struct {
	*ApiError

	Reason *RequiredCollectionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequiredError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *RequiredError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RuleBasedFirstPartyAudienceSegment struct {
	*RuleBasedFirstPartyAudienceSegmentSummary

	//
	// Specifies the rule of the segment which determines user's eligibility criteria to be part of
	// the segment. This attribute is required.
	//
	Rule *FirstPartyAudienceSegmentRule `xml:"rule,omitempty" json:"rule,omitempty"`
}

type RuleBasedFirstPartyAudienceSegmentSummary struct {
	*FirstPartyAudienceSegment

	//
	// Specifies the number of times a user's cookie must match the segment rule before it's
	// associated with the audience segment. This is used in combination with {@link
	// FirstPartyAudienceSegment#recencyDays} to determine eligibility of the association. This
	// attribute is required and can be between 1 and 12.
	//
	PageViews int32 `xml:"pageViews,omitempty" json:"pageViews,omitempty"`

	//
	// Specifies the number of days within which a user's cookie must match the segment rule before
	// it's associated with the audience segment. This is used in combination with {@link
	// FirstPartyAudienceSegment#pageViews} to determine eligibility of the association. This
	// attribute is required only if {@link FirstPartyAudienceSegment#pageViews} is greater than 1.
	// When required, it can be between 1 and 90.
	//
	RecencyDays int32 `xml:"recencyDays,omitempty" json:"recencyDays,omitempty"`

	//
	// Specifies the number of days after which a user's cookie will be removed from the audience
	// segment due to inactivity. This attribute is required and can be between 1 and 540.
	//
	MembershipExpirationDays int32 `xml:"membershipExpirationDays,omitempty" json:"membershipExpirationDays,omitempty"`
}

type AudienceSegmentAction struct {
}

type AudienceSegment struct {

	//
	// Id of the {@link AudienceSegment}. This attribute is readonly and is populated by Google.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// Name of the {@link AudienceSegment}. This attribute is required and has a maximum length of 255
	// characters.
	//
	Name string `xml:"name,omitempty" json:"name,omitempty"`

	//
	// The ids of the categories this segment belongs to. This field is optional, it may be empty.
	//
	CategoryIds []int64 `xml:"categoryIds,omitempty" json:"categoryIds,omitempty"`

	//
	// Description of the {@link AudienceSegment}. This attribute is optional and has a maximum length
	// of 8192 characters.
	//
	Description string `xml:"description,omitempty" json:"description,omitempty"`

	//
	// Status of the {@link AudienceSegment}. This controls whether the given segment is available for
	// targeting or not. During creation this attribute is optional and defaults to {@code ACTIVE}.
	// This attribute is readonly for updates.
	//
	Status *AudienceSegment_Status `xml:"status,omitempty" json:"status,omitempty"`

	//
	// Number of unique identifiers in the {@link AudienceSegment}. This attribute is readonly and is
	// populated by Google.
	//
	Size int64 `xml:"size,omitempty" json:"size,omitempty"`

	//
	// Number of unique identifiers in the {@link AudienceSegment} for mobile web.
	// This attribute is read-only.
	//
	MobileWebSize int64 `xml:"mobileWebSize,omitempty" json:"mobileWebSize,omitempty"`

	//
	// Number of unique IDFA identifiers in the {@link AudienceSegment}.
	// This attribute is read-only.
	//
	IdfaSize int64 `xml:"idfaSize,omitempty" json:"idfaSize,omitempty"`

	//
	// Number of unique AdID identifiers in the {@link AudienceSegment}.
	// This attribute is read-only.
	//
	AdIdSize int64 `xml:"adIdSize,omitempty" json:"adIdSize,omitempty"`

	//
	// Number of unique PPID (publisher provided identifiers) in the {@link AudienceSegment}.
	// This attribute is read-only.
	//
	PpidSize int64 `xml:"ppidSize,omitempty" json:"ppidSize,omitempty"`

	//
	// Owner data provider of this segment. This attribute is readonly and is assigned by Google.
	//
	DataProvider *AudienceSegmentDataProvider `xml:"dataProvider,omitempty" json:"dataProvider,omitempty"`

	//
	// Type of the segment. This attribute is readonly and is assigned by Google.
	//
	Type_ *AudienceSegment_Type `xml:"type,omitempty" json:"type,omitempty"`
}

type AudienceSegmentError struct {
	*ApiError

	Reason *AudienceSegmentError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ServerError struct {
	*ApiError

	Reason *ServerError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type SetValue struct {
	*_Value

	//
	// The values. They must all be the same type of {@code Value} and not contain duplicates.
	//
	Values []*_Value `xml:"values,omitempty" json:"values,omitempty"`
}

type SharedAudienceSegment struct {
	*AudienceSegment
}

type SoapRequestHeader struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 RequestHeader"`

	//
	// The network code to use in the context of a request.
	//
	NetworkCode string `xml:"networkCode,omitempty" json:"networkCode,omitempty"`

	//
	// The name of client library application.
	//
	ApplicationName string `xml:"applicationName,omitempty" json:"applicationName,omitempty"`
}

type SoapResponseHeader struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 ResponseHeader"`

	RequestId string `xml:"requestId,omitempty" json:"requestId,omitempty"`

	ResponseTime int64 `xml:"responseTime,omitempty" json:"responseTime,omitempty"`
}

type Statement struct {

	//
	// Holds the query in PQL syntax. The syntax is:<br>
	// <code>[WHERE <condition> {[AND | OR] <condition> ...}]</code><br>
	// <code>[ORDER BY <property> [ASC | DESC]]</code><br>
	// <code>[LIMIT {[<offset>,] <count>} | {<count> OFFSET <offset>}]</code><br>
	// <p>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <value></code><br>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <bind variable></code><br>
	// <code><condition> := <property> IN <list></code><br>
	// <code><condition> := <property> IS NULL</code><br>
	// <code><condition> := <property> LIKE <wildcard%match></code><br>
	// <code><bind variable> := :<name></code><br>
	// </p>
	//
	Query string `xml:"query,omitempty" json:"query,omitempty"`

	//
	// Holds keys and values for bind variables and their values. The key is the
	// name of the bind variable. The value is the literal value of the variable.
	// <p>
	// In the example {@code "WHERE status = :bindStatus ORDER BY id LIMIT 30"},
	// the bind variable, represented by {@code :bindStatus} is named {@code
	// bindStatus}, which would also be the parameter map key. The bind variable's
	// value would be represented by a parameter map value of type
	// {@link TextValue}. The final result, for example, would be an entry of
	// {@code "bindStatus" => StringParam("ACTIVE")}.
	// </p>
	//
	Values []*String_ValueMapEntry `xml:"values,omitempty" json:"values,omitempty"`
}

type StatementError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *StatementError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type StringFormatError struct {
	*ApiError

	Reason *StringFormatError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type StringLengthError struct {
	*ApiError

	Reason *StringLengthError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type String_ValueMapEntry struct {
	Key string `xml:"key,omitempty" json:"key,omitempty"`

	Value *_Value `xml:"value,omitempty" json:"value,omitempty"`
}

type TextValue struct {
	*_Value

	//
	// The string value.
	//
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

type TypeError struct {
	*ApiError
}

type UpdateResult struct {

	//
	// The number of objects that were changed as a result of performing the
	// action.
	//
	NumChanges int32 `xml:"numChanges,omitempty" json:"numChanges,omitempty"`
}

type _Value struct {
}

type AudienceSegmentServiceInterface interface {

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Creates new {@link FirstPartyAudienceSegment} objects.
	*/
	CreateAudienceSegments(request *CreateAudienceSegments) (*CreateAudienceSegmentsResponse, error)

	CreateAudienceSegmentsContext(ctx context.Context, request *CreateAudienceSegments) (*CreateAudienceSegmentsResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Gets an {@link AudienceSegmentPage} of {@link AudienceSegment} objects that satisfy the given
	   {@link Statement#query}. The following fields are supported for filtering:

	   <table>
	   <tr>
	   <th scope="col">PQL Property</th>
	   <th scope="col">Object Property</th>
	   </tr>
	   <tr>
	   <td>{@code id}</td>
	   <td>{@link AudienceSegment#id}</td>
	   </tr>
	   <tr>
	   <td>{@code name}</td>
	   <td>{@link AudienceSegment#name}</td>
	   </tr>
	   <tr>
	   <td>{@code status}</td>
	   <td>{@link AudienceSegment#status}</td>
	   </tr>
	   <tr>
	   <td>{@code type}</td>
	   <td>{@link AudienceSegment#type}</td>
	   </tr>
	   <tr>
	   <td>{@code size}</td>
	   <td>{@link AudienceSegment#size}</td>
	   </tr>
	   <tr>
	   <td>{@code dataProviderName}</td>
	   <td>{@link AudienceSegmentDataProvider#name}</td>
	   </tr>
	   <tr>
	   <td>{@code segmentType}</td>
	   <td>{@link AudienceSegment#type}</td>
	   </tr>
	   <tr>
	   <td>{@code approvalStatus}</td>
	   <td>{@link ThirdPartyAudienceSegment#approvalStatus}</td>
	   </tr>
	   <tr>
	   <td>{@code cost}</td>
	   <td>{@link ThirdPartyAudienceSegment#cost}</td>
	   </tr>
	   <tr>
	   <td>{@code startDateTime}</td>
	   <td>{@link ThirdPartyAudienceSegment#startDateTime}</td>
	   </tr>
	   <tr>
	   <td>{@code endDateTime}</td>
	   <td>{@link ThirdPartyAudienceSegment#endDateTime}</td>
	   </tr>
	   </table>
	*/
	GetAudienceSegmentsByStatement(request *GetAudienceSegmentsByStatement) (*GetAudienceSegmentsByStatementResponse, error)

	GetAudienceSegmentsByStatementContext(ctx context.Context, request *GetAudienceSegmentsByStatement) (*GetAudienceSegmentsByStatementResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Performs the given {@link AudienceSegmentAction} on the set of segments identified by the given
	   statement.
	*/
	PerformAudienceSegmentAction(request *PerformAudienceSegmentAction) (*PerformAudienceSegmentActionResponse, error)

	PerformAudienceSegmentActionContext(ctx context.Context, request *PerformAudienceSegmentAction) (*PerformAudienceSegmentActionResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Updates the given {@link FirstPartyAudienceSegment} objects.
	*/
	UpdateAudienceSegments(request *UpdateAudienceSegments) (*UpdateAudienceSegmentsResponse, error)

	UpdateAudienceSegmentsContext(ctx context.Context, request *UpdateAudienceSegments) (*UpdateAudienceSegmentsResponse, error)
}

type audienceSegmentServiceInterface struct {
	client *soap.Client
}

func NewAudienceSegmentServiceInterface(client *soap.Client) AudienceSegmentServiceInterface {
	return &audienceSegmentServiceInterface{
		client: client,
	}
}

func (service *audienceSegmentServiceInterface) CreateAudienceSegmentsContext(ctx context.Context, request *CreateAudienceSegments) (*CreateAudienceSegmentsResponse, error) {
	response := new(CreateAudienceSegmentsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *audienceSegmentServiceInterface) CreateAudienceSegments(request *CreateAudienceSegments) (*CreateAudienceSegmentsResponse, error) {
	return service.CreateAudienceSegmentsContext(
		context.Background(),
		request,
	)
}

func (service *audienceSegmentServiceInterface) GetAudienceSegmentsByStatementContext(ctx context.Context, request *GetAudienceSegmentsByStatement) (*GetAudienceSegmentsByStatementResponse, error) {
	response := new(GetAudienceSegmentsByStatementResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *audienceSegmentServiceInterface) GetAudienceSegmentsByStatement(request *GetAudienceSegmentsByStatement) (*GetAudienceSegmentsByStatementResponse, error) {
	return service.GetAudienceSegmentsByStatementContext(
		context.Background(),
		request,
	)
}

func (service *audienceSegmentServiceInterface) PerformAudienceSegmentActionContext(ctx context.Context, request *PerformAudienceSegmentAction) (*PerformAudienceSegmentActionResponse, error) {
	response := new(PerformAudienceSegmentActionResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *audienceSegmentServiceInterface) PerformAudienceSegmentAction(request *PerformAudienceSegmentAction) (*PerformAudienceSegmentActionResponse, error) {
	return service.PerformAudienceSegmentActionContext(
		context.Background(),
		request,
	)
}

func (service *audienceSegmentServiceInterface) UpdateAudienceSegmentsContext(ctx context.Context, request *UpdateAudienceSegments) (*UpdateAudienceSegmentsResponse, error) {
	response := new(UpdateAudienceSegmentsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *audienceSegmentServiceInterface) UpdateAudienceSegments(request *UpdateAudienceSegments) (*UpdateAudienceSegmentsResponse, error) {
	return service.UpdateAudienceSegmentsContext(
		context.Background(),
		request,
	)
}
