// Code generated by gowsdl DO NOT EDIT.

package content

import (
	"context"
	"encoding/xml"
	"github.com/hooklift/gowsdl/soap"
	"time"
)

// against "unused imports"
var _ time.Time
var _ xml.Name

type AnyType struct {
	InnerXML string `xml:",innerxml"`
}

type AnyURI string

type NCName string

type ApiVersionError_Reason string

const (

	//
	// Indicates that the operation is not allowed in the version the request
	// was made in.
	//
	ApiVersionError_ReasonUPDATE_TO_NEWER_VERSION ApiVersionError_Reason = "UPDATE_TO_NEWER_VERSION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ApiVersionError_ReasonUNKNOWN ApiVersionError_Reason = "UNKNOWN"
)

type AuthenticationError_Reason string

const (

	//
	// The SOAP message contains a request header with an ambiguous definition of the authentication
	// header fields. This means either the {@code authToken} and {@code oAuthToken} fields were
	// both null or both were specified. Exactly one value should be specified with each request.
	//
	AuthenticationError_ReasonAMBIGUOUS_SOAP_REQUEST_HEADER AuthenticationError_Reason = "AMBIGUOUS_SOAP_REQUEST_HEADER"

	//
	// The login provided is invalid.
	//
	AuthenticationError_ReasonINVALID_EMAIL AuthenticationError_Reason = "INVALID_EMAIL"

	//
	// Tried to authenticate with provided information, but failed.
	//
	AuthenticationError_ReasonAUTHENTICATION_FAILED AuthenticationError_Reason = "AUTHENTICATION_FAILED"

	//
	// The OAuth provided is invalid.
	//
	AuthenticationError_ReasonINVALID_OAUTH_SIGNATURE AuthenticationError_Reason = "INVALID_OAUTH_SIGNATURE"

	//
	// The specified service to use was not recognized.
	//
	AuthenticationError_ReasonINVALID_SERVICE AuthenticationError_Reason = "INVALID_SERVICE"

	//
	// The SOAP message is missing a request header with an {@code authToken} and optional {@code
	// networkCode}.
	//
	AuthenticationError_ReasonMISSING_SOAP_REQUEST_HEADER AuthenticationError_Reason = "MISSING_SOAP_REQUEST_HEADER"

	//
	// The HTTP request is missing a request header with an {@code authToken}
	//
	AuthenticationError_ReasonMISSING_AUTHENTICATION_HTTP_HEADER AuthenticationError_Reason = "MISSING_AUTHENTICATION_HTTP_HEADER"

	//
	// The request is missing an {@code authToken}
	//
	AuthenticationError_ReasonMISSING_AUTHENTICATION AuthenticationError_Reason = "MISSING_AUTHENTICATION"

	//
	// The network does not have API access enabled.
	//
	AuthenticationError_ReasonNETWORK_API_ACCESS_DISABLED AuthenticationError_Reason = "NETWORK_API_ACCESS_DISABLED"

	//
	// The user is not associated with any network.
	//
	AuthenticationError_ReasonNO_NETWORKS_TO_ACCESS AuthenticationError_Reason = "NO_NETWORKS_TO_ACCESS"

	//
	// No network for the given {@code networkCode} was found.
	//
	AuthenticationError_ReasonNETWORK_NOT_FOUND AuthenticationError_Reason = "NETWORK_NOT_FOUND"

	//
	// The user has access to more than one network, but did not provide a {@code networkCode}.
	//
	AuthenticationError_ReasonNETWORK_CODE_REQUIRED AuthenticationError_Reason = "NETWORK_CODE_REQUIRED"

	//
	// An error happened on the server side during connection to authentication service.
	//
	AuthenticationError_ReasonCONNECTION_ERROR AuthenticationError_Reason = "CONNECTION_ERROR"

	//
	// The user tried to create a test network using an account that already is associated with a
	// network.
	//
	AuthenticationError_ReasonGOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK AuthenticationError_Reason = "GOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK"

	//
	// The account is blocked and under investigation by the collections team. Please contact Google
	// for more information.
	//
	AuthenticationError_ReasonUNDER_INVESTIGATION AuthenticationError_Reason = "UNDER_INVESTIGATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AuthenticationError_ReasonUNKNOWN AuthenticationError_Reason = "UNKNOWN"
)

type CollectionSizeError_Reason string

const (
	CollectionSizeError_ReasonTOO_LARGE CollectionSizeError_Reason = "TOO_LARGE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CollectionSizeError_ReasonUNKNOWN CollectionSizeError_Reason = "UNKNOWN"
)

//
// Describes reasons for common errors
//

type CommonError_Reason string

const (

	//
	// Indicates that an attempt was made to retrieve an entity that does not
	// exist.
	//
	CommonError_ReasonNOT_FOUND CommonError_Reason = "NOT_FOUND"

	//
	// Indicates that an attempt was made to create an entity that already
	// exists.
	//
	CommonError_ReasonALREADY_EXISTS CommonError_Reason = "ALREADY_EXISTS"

	//
	// Indicates that a value is not applicable for given use case.
	//
	CommonError_ReasonNOT_APPLICABLE CommonError_Reason = "NOT_APPLICABLE"

	//
	// Indicates that two elements in the collection were identical.
	//
	CommonError_ReasonDUPLICATE_OBJECT CommonError_Reason = "DUPLICATE_OBJECT"

	//
	// Indicates that an attempt was made to change an immutable field.
	//
	CommonError_ReasonCANNOT_UPDATE CommonError_Reason = "CANNOT_UPDATE"

	//
	// Indicates that the requested operation is not supported.
	//
	CommonError_ReasonUNSUPPORTED_OPERATION CommonError_Reason = "UNSUPPORTED_OPERATION"

	//
	// Indicates that another request attempted to update the same data in the same network
	// at about the same time. Please wait and try the request again.
	//
	CommonError_ReasonCONCURRENT_MODIFICATION CommonError_Reason = "CONCURRENT_MODIFICATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CommonError_ReasonUNKNOWN CommonError_Reason = "UNKNOWN"
)

//
// Describes the status of a {@link Content} object.
//

type ContentStatus string

const (

	//
	// Indicates the {@link Content} has been created and is eligible to have
	// ads served against it.
	//
	ContentStatusACTIVE ContentStatus = "ACTIVE"

	//
	// Indicates the {@link Content} has been deactivated and cannot have ads
	// served against it.
	//
	ContentStatusINACTIVE ContentStatus = "INACTIVE"

	//
	// Indicates the {@link Content} has been archived; user-visible.
	//
	ContentStatusARCHIVED ContentStatus = "ARCHIVED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ContentStatusUNKNOWN ContentStatus = "UNKNOWN"
)

type FeatureError_Reason string

const (

	//
	// A feature is being used that is not enabled on the current network.
	//
	FeatureError_ReasonMISSING_FEATURE FeatureError_Reason = "MISSING_FEATURE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FeatureError_ReasonUNKNOWN FeatureError_Reason = "UNKNOWN"
)

//
// The single reason for the internal API error.
//

type InternalApiError_Reason string

const (

	//
	// API encountered an unexpected internal error.
	//
	InternalApiError_ReasonUNEXPECTED_INTERNAL_API_ERROR InternalApiError_Reason = "UNEXPECTED_INTERNAL_API_ERROR"

	//
	// A temporary error occurred during the request. Please retry.
	//
	InternalApiError_ReasonTRANSIENT_ERROR InternalApiError_Reason = "TRANSIENT_ERROR"

	//
	// The cause of the error is not known or only defined in newer versions.
	//
	InternalApiError_ReasonUNKNOWN InternalApiError_Reason = "UNKNOWN"

	//
	// The API is currently unavailable for a planned downtime.
	//
	InternalApiError_ReasonDOWNTIME InternalApiError_Reason = "DOWNTIME"

	//
	// Mutate succeeded but server was unable to build response. Client should not retry mutate.
	//
	InternalApiError_ReasonERROR_GENERATING_RESPONSE InternalApiError_Reason = "ERROR_GENERATING_RESPONSE"
)

type InvalidUrlError_Reason string

const (

	//
	// The URL contains invalid characters.
	//
	InvalidUrlError_ReasonILLEGAL_CHARACTERS InvalidUrlError_Reason = "ILLEGAL_CHARACTERS"

	//
	// The format of the URL is not allowed. This could occur for a number of
	// reasons. For example, if an invalid scheme is specified (like "ftp://")
	// or if a port is specified when not required, or if a query was specified
	// when not required.
	//
	InvalidUrlError_ReasonINVALID_FORMAT InvalidUrlError_Reason = "INVALID_FORMAT"

	//
	// URL contains insecure scheme.
	//
	InvalidUrlError_ReasonINSECURE_SCHEME InvalidUrlError_Reason = "INSECURE_SCHEME"

	//
	// The URL does not contain a scheme.
	//
	InvalidUrlError_ReasonNO_SCHEME InvalidUrlError_Reason = "NO_SCHEME"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InvalidUrlError_ReasonUNKNOWN InvalidUrlError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type NotNullError_Reason string

const (

	//
	// Assuming that a method will not have more than 3 arguments, if it does,
	// return NULL
	//
	NotNullError_ReasonARG1_NULL NotNullError_Reason = "ARG1_NULL"

	NotNullError_ReasonARG2_NULL NotNullError_Reason = "ARG2_NULL"

	NotNullError_ReasonARG3_NULL NotNullError_Reason = "ARG3_NULL"

	NotNullError_ReasonNULL NotNullError_Reason = "NULL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NotNullError_ReasonUNKNOWN NotNullError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ParseError_Reason string

const (

	//
	// Indicates an error in parsing an attribute.
	//
	ParseError_ReasonUNPARSABLE ParseError_Reason = "UNPARSABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ParseError_ReasonUNKNOWN ParseError_Reason = "UNKNOWN"
)

//
// Describes reasons for permission errors.
//

type PermissionError_Reason string

const (

	//
	// User does not have the required permission for the request.
	//
	PermissionError_ReasonPERMISSION_DENIED PermissionError_Reason = "PERMISSION_DENIED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PermissionError_ReasonUNKNOWN PermissionError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PublisherQueryLanguageContextError_Reason string

const (

	//
	// Indicates that there was an error executing the PQL.
	//
	PublisherQueryLanguageContextError_ReasonUNEXECUTABLE PublisherQueryLanguageContextError_Reason = "UNEXECUTABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageContextError_ReasonUNKNOWN PublisherQueryLanguageContextError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PublisherQueryLanguageSyntaxError_Reason string

const (

	//
	// Indicates that there was a PQL syntax error.
	//
	PublisherQueryLanguageSyntaxError_ReasonUNPARSABLE PublisherQueryLanguageSyntaxError_Reason = "UNPARSABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageSyntaxError_ReasonUNKNOWN PublisherQueryLanguageSyntaxError_Reason = "UNKNOWN"
)

type QuotaError_Reason string

const (

	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>Another way to mitigate this error is to limit requests to 8 per second for Ad Manager
	// 360 accounts, or 2 per second for Ad Manager accounts. Once again
	// this does not guarantee that every request will succeed, but may help
	// reduce the number of times you receive this error.
	//
	QuotaError_ReasonEXCEEDED_QUOTA QuotaError_Reason = "EXCEEDED_QUOTA"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	QuotaError_ReasonUNKNOWN QuotaError_Reason = "UNKNOWN"

	//
	// This user has exceeded the allowed number of new report requests per hour
	// (this includes both reports run via the UI and reports
	// run via {@link ReportService#runReportJob}).
	// The recommended approach to handle this error is to wait about 10 minutes
	// and then retry the request. Note that this does not guarantee the request
	// will succeed. If it fails again, try increasing the wait time.
	// <p>Another way to mitigate this error is to limit the number of new report
	// requests to 250 per hour per user. Once again, this does not guarantee that
	// every request will succeed, but may help reduce the number of times you
	// receive this error.
	//
	QuotaError_ReasonREPORT_JOB_LIMIT QuotaError_Reason = "REPORT_JOB_LIMIT"

	//
	// This network has exceeded the allowed number of identifiers uploaded within a 24 hour period.
	// The recommended approach to handle this error is to wait 30 minutes and then retry the
	// request. Note that this does not guarantee the request will succeed. If it fails again, try
	// increasing the wait time.
	//
	QuotaError_ReasonSEGMENT_POPULATION_LIMIT QuotaError_Reason = "SEGMENT_POPULATION_LIMIT"
)

type RequiredCollectionError_Reason string

const (

	//
	// A required collection is missing.
	//
	RequiredCollectionError_ReasonREQUIRED RequiredCollectionError_Reason = "REQUIRED"

	//
	// Collection size is too large.
	//
	RequiredCollectionError_ReasonTOO_LARGE RequiredCollectionError_Reason = "TOO_LARGE"

	//
	// Collection size is too small.
	//
	RequiredCollectionError_ReasonTOO_SMALL RequiredCollectionError_Reason = "TOO_SMALL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredCollectionError_ReasonUNKNOWN RequiredCollectionError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type RequiredError_Reason string

const (

	//
	// Missing required field.
	//
	RequiredError_ReasonREQUIRED RequiredError_Reason = "REQUIRED"
)

//
// Describes reasons for a number to be invalid.
//

type RequiredNumberError_Reason string

const (
	RequiredNumberError_ReasonREQUIRED RequiredNumberError_Reason = "REQUIRED"

	RequiredNumberError_ReasonTOO_LARGE RequiredNumberError_Reason = "TOO_LARGE"

	RequiredNumberError_ReasonTOO_SMALL RequiredNumberError_Reason = "TOO_SMALL"

	RequiredNumberError_ReasonTOO_LARGE_WITH_DETAILS RequiredNumberError_Reason = "TOO_LARGE_WITH_DETAILS"

	RequiredNumberError_ReasonTOO_SMALL_WITH_DETAILS RequiredNumberError_Reason = "TOO_SMALL_WITH_DETAILS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredNumberError_ReasonUNKNOWN RequiredNumberError_Reason = "UNKNOWN"
)

//
// Describes reasons for server errors
//

type ServerError_Reason string

const (

	//
	// Indicates that an unexpected error occured.
	//
	ServerError_ReasonSERVER_ERROR ServerError_Reason = "SERVER_ERROR"

	//
	// Indicates that the server is currently experiencing a high load. Please
	// wait and try your request again.
	//
	ServerError_ReasonSERVER_BUSY ServerError_Reason = "SERVER_BUSY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ServerError_ReasonUNKNOWN ServerError_Reason = "UNKNOWN"
)

type StatementError_Reason string

const (

	//
	// A bind variable has not been bound to a value.
	//
	StatementError_ReasonVARIABLE_NOT_BOUND_TO_VALUE StatementError_Reason = "VARIABLE_NOT_BOUND_TO_VALUE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StatementError_ReasonUNKNOWN StatementError_Reason = "UNKNOWN"
)

//
// Describes who defined the effective status of the {@code Content}.
//

type ContentStatusDefinedBy string

const (

	//
	// Indicates that the status of the {@code Content} is defined by the CMS.
	//
	ContentStatusDefinedByCMS ContentStatusDefinedBy = "CMS"

	//
	// Indicates that the status of the {@code Content} is defined by the user.
	//
	ContentStatusDefinedByUSER ContentStatusDefinedBy = "USER"
)

//
// The reasons for the target error.
//

type StringFormatError_Reason string

const (
	StringFormatError_ReasonUNKNOWN StringFormatError_Reason = "UNKNOWN"

	//
	// The input string value contains disallowed characters.
	//
	StringFormatError_ReasonILLEGAL_CHARS StringFormatError_Reason = "ILLEGAL_CHARS"

	//
	// The input string value is invalid for the associated field.
	//
	StringFormatError_ReasonINVALID_FORMAT StringFormatError_Reason = "INVALID_FORMAT"
)

type StringLengthError_Reason string

const (
	StringLengthError_ReasonTOO_LONG StringLengthError_Reason = "TOO_LONG"

	StringLengthError_ReasonTOO_SHORT StringLengthError_Reason = "TOO_SHORT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StringLengthError_ReasonUNKNOWN StringLengthError_Reason = "UNKNOWN"
)

//
// Describes what caused the DAI content to fail during the ingestion process.
//

type DaiIngestErrorReason string

const (

	//
	// The ingest URL provided in the publisher's content source feed is invalid. The trigger for this
	// error is the ingest URL specified in the publisher's feed.
	//
	DaiIngestErrorReasonINVALID_INGEST_URL DaiIngestErrorReason = "INVALID_INGEST_URL"

	//
	// The closed caption URL provided in the publisher's content source feed is invalid. The trigger
	// for this error is the closed caption URL specified in the publisher's feed.
	//
	DaiIngestErrorReasonINVALID_CLOSED_CAPTION_URL DaiIngestErrorReason = "INVALID_CLOSED_CAPTION_URL"

	//
	// There is no closed caption URL for a content in the publisher's content source feed. There is
	// no trigger for this error.
	//
	DaiIngestErrorReasonMISSING_CLOSED_CAPTION_URL DaiIngestErrorReason = "MISSING_CLOSED_CAPTION_URL"

	//
	// There was an error while trying to fetch the HLS from the specified ingest URL. The trigger for
	// this error is the ingest URL specified in the publisher's feed.
	//
	DaiIngestErrorReasonCOULD_NOT_FETCH_HLS DaiIngestErrorReason = "COULD_NOT_FETCH_HLS"

	//
	// There was an error while trying to fetch the subtitles from the specified closed caption url.
	// The trigger for this error is the closed caption URL specified in the publisher's feed.
	//
	DaiIngestErrorReasonCOULD_NOT_FETCH_SUBTITLES DaiIngestErrorReason = "COULD_NOT_FETCH_SUBTITLES"

	//
	// One of the subtitles from the closed caption URL is missing a language. The trigger for this
	// error is the closed caption URL that does not have a language associated with it.
	//
	DaiIngestErrorReasonMISSING_SUBTITLE_LANGUAGE DaiIngestErrorReason = "MISSING_SUBTITLE_LANGUAGE"

	//
	// Error fetching the media files from the URLs specified in the master HLS playlist. The trigger
	// for this error is a media playlist URL within the publisher's HLS playlist that could not be
	// fetched.
	//
	DaiIngestErrorReasonCOULD_NOT_FETCH_MEDIA DaiIngestErrorReason = "COULD_NOT_FETCH_MEDIA"

	//
	// The media from the publisher's CDN is malformed and cannot be conditioned. The trigger for this
	// error is a media playlist URL within the publisher's HLS playlist that is malformed.
	//
	DaiIngestErrorReasonMALFORMED_MEDIA_BYTES DaiIngestErrorReason = "MALFORMED_MEDIA_BYTES"

	//
	// A chapter time for the content is outside of the range of the content's duration. The trigger
	// for this error is the chapter time (a parsable long representing the time in ms) that is out of
	// bounds.
	//
	DaiIngestErrorReasonCHAPTER_TIME_OUT_OF_BOUNDS DaiIngestErrorReason = "CHAPTER_TIME_OUT_OF_BOUNDS"

	//
	// An internal error occurred while conditioning the content. There is no trigger for this error.
	//
	DaiIngestErrorReasonINTERNAL_ERROR DaiIngestErrorReason = "INTERNAL_ERROR"

	//
	// The content has chapter times but the content's source has no CDN settings for midrolls. There
	// is no trigger for this error.
	//
	DaiIngestErrorReasonCONTENT_HAS_CHAPTER_TIMES_BUT_NO_MIDROLL_SETTINGS DaiIngestErrorReason = "CONTENT_HAS_CHAPTER_TIMES_BUT_NO_MIDROLL_SETTINGS"

	//
	// There is bad/missing/malformed data in a media playlist. The trigger for this error is the URL
	// that points to the malformed media playlist.
	//
	DaiIngestErrorReasonMALFORMED_MEDIA_PLAYLIST DaiIngestErrorReason = "MALFORMED_MEDIA_PLAYLIST"

	//
	// Multiple ways of denoting ad breaks were detected in a media playlist (e.g. placement
	// opportunity tags, cue markers, etc.)
	//
	DaiIngestErrorReasonMIXED_AD_BREAK_TAGS DaiIngestErrorReason = "MIXED_AD_BREAK_TAGS"

	//
	// The ad break tags in the preconditioned content are not in the same locations across all
	// variant playlists.
	//
	DaiIngestErrorReasonAD_BREAK_TAGS_INCONSISTENT_ACROSS_VARIANTS DaiIngestErrorReason = "AD_BREAK_TAGS_INCONSISTENT_ACROSS_VARIANTS"

	//
	// There is bad/missing/malformed data in a subtitles file. The trigger for this error is the URL
	// that points to the malformed subtitles.
	//
	DaiIngestErrorReasonMALFORMED_SUBTITLES DaiIngestErrorReason = "MALFORMED_SUBTITLES"

	//
	// A playlist item has a URL that does not begin with the ingest common path provided in the DAI
	// settings. The trigger for this error is the playlist item URL.
	//
	DaiIngestErrorReasonPLAYLIST_ITEM_URL_DOES_NOT_MATCH_INGEST_COMMON_PATH DaiIngestErrorReason = "PLAYLIST_ITEM_URL_DOES_NOT_MATCH_INGEST_COMMON_PATH"

	//
	// Uploading split media segments failed due to an authentication error.
	//
	DaiIngestErrorReasonCOULD_NOT_UPLOAD_SPLIT_MEDIA_AUTHENTICATION_FAILED DaiIngestErrorReason = "COULD_NOT_UPLOAD_SPLIT_MEDIA_AUTHENTICATION_FAILED"

	//
	// Uploading spit media segments failed due to a connection error.
	//
	DaiIngestErrorReasonCOULD_NOT_UPLOAD_SPLIT_MEDIA_CONNECTION_FAILED DaiIngestErrorReason = "COULD_NOT_UPLOAD_SPLIT_MEDIA_CONNECTION_FAILED"

	//
	// Uploading split media segments failed due to a write error.
	//
	DaiIngestErrorReasonCOULD_NOT_UPLOAD_SPLIT_MEDIA_WRITE_FAILED DaiIngestErrorReason = "COULD_NOT_UPLOAD_SPLIT_MEDIA_WRITE_FAILED"

	//
	// Variants in a playlist do not have the same number of discontinuities. The trigger for this
	// error is the master playlist URI.
	//
	DaiIngestErrorReasonPLAYLISTS_HAVE_DIFFERENT_NUMBER_OF_DISCONTINUITIES DaiIngestErrorReason = "PLAYLISTS_HAVE_DIFFERENT_NUMBER_OF_DISCONTINUITIES"

	//
	// The playlist does not have a starting PTS value. The trigger for this error is the master
	// playlist URI.
	//
	DaiIngestErrorReasonPLAYIST_HAS_NO_STARTING_PTS_VALUE DaiIngestErrorReason = "PLAYIST_HAS_NO_STARTING_PTS_VALUE"

	//
	// The PTS at a discontinuity varies too much between the different variants. The trigger for this
	// error is the master playlist URI.
	//
	DaiIngestErrorReasonPLAYLIST_DISCONTINUITY_PTS_VALUES_DIFFER_TOO_MUCH DaiIngestErrorReason = "PLAYLIST_DISCONTINUITY_PTS_VALUES_DIFFER_TOO_MUCH"

	//
	// A media segment has no PTS. The trigger for this error is the segment data URI.
	//
	DaiIngestErrorReasonSEGMENT_HAS_NO_PTS DaiIngestErrorReason = "SEGMENT_HAS_NO_PTS"

	//
	// The language in the subtitles file does not match the language specified in the feed. The
	// trigger for this error is the feed language and the parsed language separated by a semi-colon,
	// e.g. "en;sp".
	//
	DaiIngestErrorReasonSUBTITLE_LANGUAGE_DOES_NOT_MATCH_LANGUAGE_IN_FEED DaiIngestErrorReason = "SUBTITLE_LANGUAGE_DOES_NOT_MATCH_LANGUAGE_IN_FEED"

	//
	// There are multiple subtitles files at the closed caption URI, and none of them match the
	// language defined in the feed. The trigger for this error is language in the feed.
	//
	DaiIngestErrorReasonCANNOT_DETERMINE_CORRECT_SUBTITLES_FOR_LANGUAGE DaiIngestErrorReason = "CANNOT_DETERMINE_CORRECT_SUBTITLES_FOR_LANGUAGE"

	//
	// No CDN configuration found for the content. The trigger for this error is the content's master
	// playlist URI.
	//
	DaiIngestErrorReasonNO_CDN_CONFIGURATION_FOUND DaiIngestErrorReason = "NO_CDN_CONFIGURATION_FOUND"

	//
	// The content has midrolls but there was no split content config on the CDN configuration for
	// that content so the content was not conditioned. There is no trigger for this error.
	//
	DaiIngestErrorReasonCONTENT_HAS_MIDROLLS_BUT_NO_SPLIT_CONTENT_CONFIG DaiIngestErrorReason = "CONTENT_HAS_MIDROLLS_BUT_NO_SPLIT_CONTENT_CONFIG"

	//
	// The content has midrolls but the source the content was ingested from has mid-rolls disabled,
	// so the content was not conditioned. There is no trigger for this error.
	//
	DaiIngestErrorReasonCONTENT_HAS_MIDROLLS_BUT_SOURCE_HAS_MIDROLLS_DISABLED DaiIngestErrorReason = "CONTENT_HAS_MIDROLLS_BUT_SOURCE_HAS_MIDROLLS_DISABLED"

	//
	// Error parsing ADTS while splitting the content. The trigger for this error is the variant URL
	// and the cue-point separated by a semi-colon, e.g. "www.variant2.com;5000".
	//
	DaiIngestErrorReasonADTS_PARSE_ERROR DaiIngestErrorReason = "ADTS_PARSE_ERROR"

	//
	// Error splitting an AAC segment. The trigger for this error is the variant URL and the cue-point
	// separated by a semi-colon, e.g. "www.variant2.com;5000".
	//
	DaiIngestErrorReasonAAC_SPLIT_ERROR DaiIngestErrorReason = "AAC_SPLIT_ERROR"

	//
	// Error parsing an AAC file while splitting the content. The trigger for this error is the
	// variant URL and the cue-point separated by a semi-colon, e.g. "www.variant2.com;5000".
	//
	DaiIngestErrorReasonAAC_PARSE_ERROR DaiIngestErrorReason = "AAC_PARSE_ERROR"

	//
	// Error parsing a TS file while splitting the content. The trigger for this error is the variant
	// URL and the cue-point separated by a semi-colon, e.g. "www.variant2.com;5000".
	//
	DaiIngestErrorReasonTS_PARSE_ERROR DaiIngestErrorReason = "TS_PARSE_ERROR"

	//
	// Error splitting a TS file while splitting the content. The trigger for this error is the
	// variant URL and the cue-point separated by a semi-colon, e.g. "www.variant2.com;5000".
	//
	DaiIngestErrorReasonTS_SPLIT_ERROR DaiIngestErrorReason = "TS_SPLIT_ERROR"

	//
	// Encountered an unsupported container format while splitting the content. The trigger for this
	// error is the variant URL and the cue-point separated by a semi-colon, e.g.
	// "www.variant2.com;5000".
	//
	DaiIngestErrorReasonUNSUPPORTED_CONTAINER_FORMAT DaiIngestErrorReason = "UNSUPPORTED_CONTAINER_FORMAT"

	//
	// Encountered multiple elementary streams of the same media type (audio, video) within a
	// transport stream. The trigger for this error is the variant URL and the cue-point separated by
	// a semi-colon, e.g. "www.variant2.com;5000".
	//
	DaiIngestErrorReasonMULTIPLE_ELEMENTARY_STREAMS_OF_SAME_MEDIA_TYPE_IN_TS DaiIngestErrorReason = "MULTIPLE_ELEMENTARY_STREAMS_OF_SAME_MEDIA_TYPE_IN_TS"

	//
	// Encountered an unsupported TS media format while splitting the content. The trigger for this
	// error is the variant URL and the cue-point separated by a semi-colon, e.g.
	// "www.variant2.com;5000".
	//
	DaiIngestErrorReasonUNSUPPORTED_TS_MEDIA_FORMAT DaiIngestErrorReason = "UNSUPPORTED_TS_MEDIA_FORMAT"

	//
	// Error splitting because there were no i-frames near the target split point. The trigger for
	// this error is the variant URL and the cue-point separated by a semi-colon, e.g.
	// "www.variant2.com;5000".
	//
	DaiIngestErrorReasonNO_IFRAMES_NEAR_CUE_POINT DaiIngestErrorReason = "NO_IFRAMES_NEAR_CUE_POINT"

	//
	// Error splitting an AC-3 segment. The trigger for this error is the variant URL and the
	// cue-point separated by a semi-colon, e.g. "www.variant2.com;5000".
	//
	DaiIngestErrorReasonAC3_SPLIT_ERROR DaiIngestErrorReason = "AC3_SPLIT_ERROR"

	//
	// Error parsing an AC-3 file while splitting the content. The trigger for this error is the
	// variant URL and the cue-point separated by a semi-colon, e.g. "www.variant2.com;5000".
	//
	DaiIngestErrorReasonAC3_PARSE_ERROR DaiIngestErrorReason = "AC3_PARSE_ERROR"

	//
	// Error splitting an E-AC-3 segment. The trigger for this error is the variant URL and the
	// cue-point separated by a semi-colon, e.g. "www.variant2.com;5000".
	//
	DaiIngestErrorReasonEAC3_SPLIT_ERROR DaiIngestErrorReason = "EAC3_SPLIT_ERROR"

	//
	// Error caused by an invalid encryption key. The trigger for this error is a media playlist URL
	// within the publisher's HLS playlist that has the invalid encryption key.
	//
	DaiIngestErrorReasonINVALID_ENCRYPTION_KEY DaiIngestErrorReason = "INVALID_ENCRYPTION_KEY"

	//
	// Error parsing an E-AC-3 file while splitting the content. The trigger for this error is the
	// variant URL and the cue-point separated by a semi-colon, e.g. "www.variant2.com;5000".
	//
	DaiIngestErrorReasonEAC3_PARSE_ERROR DaiIngestErrorReason = "EAC3_PARSE_ERROR"

	//
	// Error caused by the number of PTS being a different value than the number of cue points + 1.
	//
	DaiIngestErrorReasonCUE_POINT_COUNT_DOES_NOT_MATCH_PTS_COUNT DaiIngestErrorReason = "CUE_POINT_COUNT_DOES_NOT_MATCH_PTS_COUNT"

	//
	// The DASH content has cue points but they do not match the Event durations from the DASH
	// manifest EventStream, if present.
	//
	DaiIngestErrorReasonDASH_CUE_POINT_EVENT_MISMATCH DaiIngestErrorReason = "DASH_CUE_POINT_EVENT_MISMATCH"

	//
	// The DASH manifest cannot be conditioned for midrolls.
	//
	DaiIngestErrorReasonDASH_MANIFEST_CONDITIONING_FAILED DaiIngestErrorReason = "DASH_MANIFEST_CONDITIONING_FAILED"

	//
	// The DASH manifest cannot be conditioned for midrolls because one or more of the cue points do
	// not lie on a media segment boundary.
	//
	DaiIngestErrorReasonDASH_MANIFEST_CONDITIONING_SEGMENT_BOUNDARY_ERROR DaiIngestErrorReason = "DASH_MANIFEST_CONDITIONING_SEGMENT_BOUNDARY_ERROR"

	//
	// The subtitle language code should not contain "$$$$$".
	//
	DaiIngestErrorReasonCLOSED_CAPTION_LANGUAGE_VALUE_INVALID DaiIngestErrorReason = "CLOSED_CAPTION_LANGUAGE_VALUE_INVALID"

	//
	// The subtitle name should not contain "$$$$$".
	//
	DaiIngestErrorReasonCLOSED_CAPTION_NAME_VALUE_INVALID DaiIngestErrorReason = "CLOSED_CAPTION_NAME_VALUE_INVALID"

	//
	// The common subtitle characteristics values listed in the HLS spec are:
	// 1)"public.accessibility.transcribes-spoken-dialog",
	// 2)"public.accessibility.describes-music-and-sound", 3)"public.easy-to-read";
	//
	DaiIngestErrorReasonCLOSED_CAPTION_CHARACTERISTICS_VALUE_UNEXPECTED DaiIngestErrorReason = "CLOSED_CAPTION_CHARACTERISTICS_VALUE_UNEXPECTED"

	//
	// Closed captions for a content should be unique by 'language + name'.
	//
	DaiIngestErrorReasonCLOSED_CAPTIONS_WITH_DUPLICATE_KEYS DaiIngestErrorReason = "CLOSED_CAPTIONS_WITH_DUPLICATE_KEYS"

	//
	// Subtitles are defined in the content source feed as well as inside the stream manifest. Only
	// feed subtitles will be ingested.
	//
	DaiIngestErrorReasonSUBTITLES_PRESENT_IN_FEED_AND_MANIFEST DaiIngestErrorReason = "SUBTITLES_PRESENT_IN_FEED_AND_MANIFEST"

	//
	// The media profile is invalid due to missing data.
	//
	DaiIngestErrorReasonINVALID_MEDIA_PROFILE DaiIngestErrorReason = "INVALID_MEDIA_PROFILE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DaiIngestErrorReasonUNKNOWN DaiIngestErrorReason = "UNKNOWN"
)

//
// The status of the DAI ingestion process. Only content with a status of {@link #SUCCESS} will be
// available for dynamic ad insertion.
//

type DaiIngestStatus string

const (

	//
	// The content was successfully ingested for DAI.
	//
	DaiIngestStatusSUCCESS DaiIngestStatus = "SUCCESS"

	//
	// There was a non-fatal issue during the DAI ingestion process.
	//
	DaiIngestStatusWARNING DaiIngestStatus = "WARNING"

	//
	// The preconditioned content was successfully ingested for DAI.
	//
	DaiIngestStatusINGESTED DaiIngestStatus = "INGESTED"

	//
	// There was a non-fatal issue during the DAI ingestion process on preconditioned content.
	//
	DaiIngestStatusINGESTED_WITH_WARNINGS DaiIngestStatus = "INGESTED_WITH_WARNINGS"

	//
	// The unconditioned content was successfully conditioned for DAI.
	//
	DaiIngestStatusCONDITIONED DaiIngestStatus = "CONDITIONED"

	//
	// There was a non-fatal issue during the DAI conditioning process on originally unconditioned
	// content.
	//
	DaiIngestStatusCONDITIONED_WITH_WARNINGS DaiIngestStatus = "CONDITIONED_WITH_WARNINGS"

	//
	// There was a non-fatal issue during the DAI ingestion process and the content is not available
	// for dynamic ad insertion.
	//
	DaiIngestStatusFAILURE DaiIngestStatus = "FAILURE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DaiIngestStatusUNKNOWN DaiIngestStatus = "UNKNOWN"
)

type GetContentByStatement struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getContentByStatement"`

	Statement *Statement `xml:"statement,omitempty" json:"statement,omitempty"`
}

type GetContentByStatementResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getContentByStatementResponse"`

	Rval *ContentPage `xml:"rval,omitempty" json:"rval,omitempty"`
}

type ApiExceptionFault ApiException

type RequestHeader SoapRequestHeader

type ResponseHeader SoapResponseHeader

type ObjectValue struct {
	*_Value
}

type ApiError struct {

	//
	// The OGNL field path to identify cause of error.
	//
	FieldPath string `xml:"fieldPath,omitempty" json:"fieldPath,omitempty"`

	//
	// A parsed copy of the field path. For example, the field path "operations[1].operand"
	// corresponds to this list: {FieldPathElement(field = "operations", index = 1),
	// FieldPathElement(field = "operand", index = null)}.
	//
	FieldPathElements []*FieldPathElement `xml:"fieldPathElements,omitempty" json:"fieldPathElements,omitempty"`

	//
	// The data that caused the error.
	//
	Trigger string `xml:"trigger,omitempty" json:"trigger,omitempty"`

	//
	// A simple string representation of the error and reason.
	//
	ErrorString string `xml:"errorString,omitempty" json:"errorString,omitempty"`
}

type ApiException struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 ApiExceptionFault"`

	*ApplicationException

	//
	// List of errors.
	//
	Errors []*ApiError `xml:"errors,omitempty" json:"errors,omitempty"`
}

type ApiVersionError struct {
	*ApiError

	Reason *ApiVersionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ApplicationException struct {

	//
	// Error message.
	//
	Message string `xml:"message,omitempty" json:"message,omitempty"`
}

type AuthenticationError struct {
	*ApiError

	Reason *AuthenticationError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type BooleanValue struct {
	*_Value

	//
	// The boolean value.
	//
	Value bool `xml:"value,omitempty" json:"value,omitempty"`
}

type CmsContent struct {

	//
	// The ID of the Content Source associated with the CMS in Ad Manager.
	// This attribute is read-only.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// The display name of the CMS this content is in. This attribute is read-only.
	//
	DisplayName string `xml:"displayName,omitempty" json:"displayName,omitempty"`

	//
	// The ID of the {@link Content} in the CMS. This ID will be a 3rd party
	// ID, usually the ID of the content in a CMS (Content Management System).
	// This attribute is read-only.
	//
	CmsContentId string `xml:"cmsContentId,omitempty" json:"cmsContentId,omitempty"`
}

type CollectionSizeError struct {
	*ApiError

	Reason *CollectionSizeError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CommonError struct {
	*ApiError

	Reason *CommonError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type Content struct {

	//
	// Uniquely identifies the {@code Content}. This attribute is read-only and is assigned by Google
	// when the content is created.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// The name of the {@code Content}. This attribute is read-only.
	//
	Name string `xml:"name,omitempty" json:"name,omitempty"`

	//
	// The status of this {@code Content}. This attribute is read-only.
	//
	Status *ContentStatus `xml:"status,omitempty" json:"status,omitempty"`

	//
	// Whether the content status was defined by the user, or by the source CMS from which the content
	// was ingested. This attribute is read-only.
	//
	StatusDefinedBy *ContentStatusDefinedBy `xml:"statusDefinedBy,omitempty" json:"statusDefinedBy,omitempty"`

	//
	// The current DAI ingest status of the HLS media for the {@code content}. This attribute is
	// read-only and is null if the content is not eligible for dynamic ad insertion or if the content
	// does not have HLS media.
	//
	HlsIngestStatus *DaiIngestStatus `xml:"hlsIngestStatus,omitempty" json:"hlsIngestStatus,omitempty"`

	//
	// The list of any errors that occurred during the most recent DAI ingestion process of the HLS
	// media. This attribute is read-only and will be null if the {@link #hlsIngestStatus} is {@link
	// DaiIngestStatus#STATUS_SUCCESS} or if the content is not eligible for dynamic ad insertion or
	// if the content does not have HLS media.
	//
	HlsIngestErrors []*DaiIngestError `xml:"hlsIngestErrors,omitempty" json:"hlsIngestErrors,omitempty"`

	//
	// The date and time at which this content's HLS media was last ingested for DAI. This attribute
	// is read-only and will be null if the content is not eligible for dynamic ad insertion or if the
	// content does not have HLS media.
	//
	LastHlsIngestDateTime soap.XSDDateTime `xml:"lastHlsIngestDateTime,omitempty" json:"lastHlsIngestDateTime,omitempty"`

	//
	// The current DAI ingest status of the DASH media for the {@code content}. This attribute is
	// read-only and is null if the content is not eligible for dynamic ad insertion or if the content
	// does not have DASH media.
	//
	DashIngestStatus *DaiIngestStatus `xml:"dashIngestStatus,omitempty" json:"dashIngestStatus,omitempty"`

	//
	// The list of any errors that occurred during the most recent DAI ingestion process of the DASH
	// media. This attribute is read-only and will be null if the {@link #hlsIngestStatus} is {@link
	// DaiIngestStatus#STATUS_SUCCESS} or if the content is not eligible for dynamic ad insertion or
	// if the content does not have DASH media.
	//
	DashIngestErrors []*DaiIngestError `xml:"dashIngestErrors,omitempty" json:"dashIngestErrors,omitempty"`

	//
	// The date and time at which this content's DASH media was last ingested for DAI. This attribute
	// is read-only and will be null if the content is not eligible for dynamic ad insertion or if the
	// content does not have DASH media.
	//
	LastDashIngestDateTime soap.XSDDateTime `xml:"lastDashIngestDateTime,omitempty" json:"lastDashIngestDateTime,omitempty"`

	//
	// The date and time at which this content was published. This attribute is read-only.
	//
	ImportDateTime soap.XSDDateTime `xml:"importDateTime,omitempty" json:"importDateTime,omitempty"`

	//
	// The date and time at which this content was last modified. The last modified date time will
	// always be updated when a {@link ContentBundle} association is changed, but will not always be
	// updated when a {@link CmsMetadataValue} value is changed.
	// This attribute is read-only.
	//
	LastModifiedDateTime soap.XSDDateTime `xml:"lastModifiedDateTime,omitempty" json:"lastModifiedDateTime,omitempty"`

	//
	// Information about the content from the CMS it was ingested from. This attribute is read-only.
	//
	CmsSources []*CmsContent `xml:"cmsSources,omitempty" json:"cmsSources,omitempty"`

	//
	// IDs of the {@link ContentBundle} of which this content is a member.
	// This attribute is read-only.
	//
	ContentBundleIds []int64 `xml:"contentBundleIds,omitempty" json:"contentBundleIds,omitempty"`

	//
	// A collection of {@link CmsMetadataValue} IDs that are associated with this content.
	// This attribute is read-only.
	//
	CmsMetadataValueIds []int64 `xml:"cmsMetadataValueIds,omitempty" json:"cmsMetadataValueIds,omitempty"`

	//
	// The duration of the content in milliseconds.
	// This attribute is read-only.
	//
	Duration int64 `xml:"duration,omitempty" json:"duration,omitempty"`
}

type ContentPage struct {

	//
	// The size of the total result set to which this page belongs.
	//
	TotalResultSetSize int32 `xml:"totalResultSetSize,omitempty" json:"totalResultSetSize,omitempty"`

	//
	// The absolute index in the total result set on which this page begins.
	//
	StartIndex int32 `xml:"startIndex,omitempty" json:"startIndex,omitempty"`

	//
	// The collection of content contained within this page.
	//
	Results []*Content `xml:"results,omitempty" json:"results,omitempty"`
}

type DaiIngestError struct {

	//
	// The error associated with the content.
	//
	Reason *DaiIngestErrorReason `xml:"reason,omitempty" json:"reason,omitempty"`

	//
	// The field, if any, that triggered the error.
	//
	Trigger string `xml:"trigger,omitempty" json:"trigger,omitempty"`
}

type Date struct {

	//
	// Year (e.g., 2009)
	//
	Year int32 `xml:"year,omitempty" json:"year,omitempty"`

	//
	// Month (1..12)
	//
	Month int32 `xml:"month,omitempty" json:"month,omitempty"`

	//
	// Day (1..31)
	//
	Day int32 `xml:"day,omitempty" json:"day,omitempty"`
}

type DateTime struct {
	Date soap.XSDDate `xml:"date,omitempty" json:"date,omitempty"`

	Hour int32 `xml:"hour,omitempty" json:"hour,omitempty"`

	Minute int32 `xml:"minute,omitempty" json:"minute,omitempty"`

	Second int32 `xml:"second,omitempty" json:"second,omitempty"`

	TimeZoneId string `xml:"timeZoneId,omitempty" json:"timeZoneId,omitempty"`
}

type DateTimeValue struct {
	*_Value

	//
	// The {@code DateTime} value.
	//
	Value soap.XSDDateTime `xml:"value,omitempty" json:"value,omitempty"`
}

type DateValue struct {
	*_Value

	//
	// The {@code Date} value.
	//
	Value soap.XSDDate `xml:"value,omitempty" json:"value,omitempty"`
}

type FeatureError struct {
	*ApiError

	Reason *FeatureError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FieldPathElement struct {

	//
	// The name of a field in lower camelcase. (e.g. "biddingStrategy")
	//
	Field string `xml:"field,omitempty" json:"field,omitempty"`

	//
	// For list fields, this is a 0-indexed position in the list. Null for non-list fields.
	//
	Index int32 `xml:"index,omitempty" json:"index,omitempty"`
}

type InternalApiError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *InternalApiError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InvalidUrlError struct {
	*ApiError

	Reason *InvalidUrlError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type NotNullError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *NotNullError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type NumberValue struct {
	*_Value

	//
	// The numeric value represented as a string.
	//
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

type ParseError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ParseError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PermissionError struct {
	*ApiError

	Reason *PermissionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PublisherQueryLanguageContextError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PublisherQueryLanguageContextError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PublisherQueryLanguageSyntaxError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PublisherQueryLanguageSyntaxError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type QuotaError struct {
	*ApiError

	Reason *QuotaError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequiredCollectionError struct {
	*ApiError

	Reason *RequiredCollectionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequiredError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *RequiredError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequiredNumberError struct {
	*ApiError

	Reason *RequiredNumberError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ServerError struct {
	*ApiError

	Reason *ServerError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type SetValue struct {
	*_Value

	//
	// The values. They must all be the same type of {@code Value} and not contain duplicates.
	//
	Values []*_Value `xml:"values,omitempty" json:"values,omitempty"`
}

type SoapRequestHeader struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 RequestHeader"`

	//
	// The network code to use in the context of a request.
	//
	NetworkCode string `xml:"networkCode,omitempty" json:"networkCode,omitempty"`

	//
	// The name of client library application.
	//
	ApplicationName string `xml:"applicationName,omitempty" json:"applicationName,omitempty"`
}

type SoapResponseHeader struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 ResponseHeader"`

	RequestId string `xml:"requestId,omitempty" json:"requestId,omitempty"`

	ResponseTime int64 `xml:"responseTime,omitempty" json:"responseTime,omitempty"`
}

type Statement struct {

	//
	// Holds the query in PQL syntax. The syntax is:<br>
	// <code>[WHERE <condition> {[AND | OR] <condition> ...}]</code><br>
	// <code>[ORDER BY <property> [ASC | DESC]]</code><br>
	// <code>[LIMIT {[<offset>,] <count>} | {<count> OFFSET <offset>}]</code><br>
	// <p>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <value></code><br>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <bind variable></code><br>
	// <code><condition> := <property> IN <list></code><br>
	// <code><condition> := <property> IS NULL</code><br>
	// <code><condition> := <property> LIKE <wildcard%match></code><br>
	// <code><bind variable> := :<name></code><br>
	// </p>
	//
	Query string `xml:"query,omitempty" json:"query,omitempty"`

	//
	// Holds keys and values for bind variables and their values. The key is the
	// name of the bind variable. The value is the literal value of the variable.
	// <p>
	// In the example {@code "WHERE status = :bindStatus ORDER BY id LIMIT 30"},
	// the bind variable, represented by {@code :bindStatus} is named {@code
	// bindStatus}, which would also be the parameter map key. The bind variable's
	// value would be represented by a parameter map value of type
	// {@link TextValue}. The final result, for example, would be an entry of
	// {@code "bindStatus" => StringParam("ACTIVE")}.
	// </p>
	//
	Values []*String_ValueMapEntry `xml:"values,omitempty" json:"values,omitempty"`
}

type StatementError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *StatementError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type StringFormatError struct {
	*ApiError

	Reason *StringFormatError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type StringLengthError struct {
	*ApiError

	Reason *StringLengthError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type String_ValueMapEntry struct {
	Key string `xml:"key,omitempty" json:"key,omitempty"`

	Value *_Value `xml:"value,omitempty" json:"value,omitempty"`
}

type TextValue struct {
	*_Value

	//
	// The string value.
	//
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

type TypeError struct {
	*ApiError
}

type _Value struct {
}

type ContentServiceInterface interface {

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Gets a {@link ContentPage} of {@link Content} objects that satisfy the given {@link
	   Statement#query}. The following fields are supported for filtering:

	   <table>
	   <tr>
	   <th scope="col">PQL Property</th> <th scope="col">Object Property</th>
	   </tr>
	   <tr>
	   <td>{@code id}</td>
	   <td>{@link Content#id}</td>
	   </tr>
	   <tr>
	   <td>{@code status}</td>
	   <td>{@link Content#status}</td>
	   </tr>
	   <tr>
	   <td>{@code name}</td>
	   <td>{@link Content#name}</td>
	   </tr>
	   <tr>
	   <td>{@code lastModifiedDateTime}</td>
	   <td>{@link Content#lastModifiedDateTime}</td>
	   </tr>
	   <tr>
	   <td>{@code lastDaiIngestDateTime}</td>
	   <td>{@link Content#lastDaiIngestDateTime}</td>
	   </tr>
	   <tr>
	   <td>{@code daiIngestStatus}</td>
	   <td>{@link Content#daiIngestStatus}</td>
	   </tr>
	   </table>
	*/
	GetContentByStatement(request *GetContentByStatement) (*GetContentByStatementResponse, error)

	GetContentByStatementContext(ctx context.Context, request *GetContentByStatement) (*GetContentByStatementResponse, error)
}

type contentServiceInterface struct {
	client *soap.Client
}

func NewContentServiceInterface(client *soap.Client) ContentServiceInterface {
	return &contentServiceInterface{
		client: client,
	}
}

func (service *contentServiceInterface) GetContentByStatementContext(ctx context.Context, request *GetContentByStatement) (*GetContentByStatementResponse, error) {
	response := new(GetContentByStatementResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *contentServiceInterface) GetContentByStatement(request *GetContentByStatement) (*GetContentByStatementResponse, error) {
	return service.GetContentByStatementContext(
		context.Background(),
		request,
	)
}
