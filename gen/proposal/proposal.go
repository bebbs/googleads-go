// Code generated by gowsdl DO NOT EDIT.

package proposal

import (
	"context"
	"encoding/xml"
	"github.com/hooklift/gowsdl/soap"
	"time"
)

// against "unused imports"
var _ time.Time
var _ xml.Name

type AnyType struct {
	InnerXML string `xml:",innerxml"`
}

type AnyURI string

type NCName string

//
// Identifies the format of inventory or "channel" in which ads serve.
//

type AdExchangeEnvironment string

const (

	//
	// Ads serve in a browser.
	//
	AdExchangeEnvironmentDISPLAY AdExchangeEnvironment = "DISPLAY"

	//
	// In-stream video ads serve in a video.
	//
	AdExchangeEnvironmentVIDEO AdExchangeEnvironment = "VIDEO"

	//
	// In-stream video ads serve in a game.
	//
	AdExchangeEnvironmentGAMES AdExchangeEnvironment = "GAMES"

	//
	// Ads serve in a mobile app.
	//
	AdExchangeEnvironmentMOBILE AdExchangeEnvironment = "MOBILE"

	//
	// Out-stream video ads serve in a mobile app. Examples include mobile app interstitials and
	// mobile app rewarded ads.
	//
	AdExchangeEnvironmentMOBILE_OUTSTREAM_VIDEO AdExchangeEnvironment = "MOBILE_OUTSTREAM_VIDEO"

	//
	// Out-stream video ads serve in a browser. Examples include in-feed and in-banner video ads.
	//
	AdExchangeEnvironmentDISPLAY_OUTSTREAM_VIDEO AdExchangeEnvironment = "DISPLAY_OUTSTREAM_VIDEO"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AdExchangeEnvironmentUNKNOWN AdExchangeEnvironment = "UNKNOWN"
)

type ApiVersionError_Reason string

const (

	//
	// Indicates that the operation is not allowed in the version the request
	// was made in.
	//
	ApiVersionError_ReasonUPDATE_TO_NEWER_VERSION ApiVersionError_Reason = "UPDATE_TO_NEWER_VERSION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ApiVersionError_ReasonUNKNOWN ApiVersionError_Reason = "UNKNOWN"
)

type AuthenticationError_Reason string

const (

	//
	// The SOAP message contains a request header with an ambiguous definition of the authentication
	// header fields. This means either the {@code authToken} and {@code oAuthToken} fields were
	// both null or both were specified. Exactly one value should be specified with each request.
	//
	AuthenticationError_ReasonAMBIGUOUS_SOAP_REQUEST_HEADER AuthenticationError_Reason = "AMBIGUOUS_SOAP_REQUEST_HEADER"

	//
	// The login provided is invalid.
	//
	AuthenticationError_ReasonINVALID_EMAIL AuthenticationError_Reason = "INVALID_EMAIL"

	//
	// Tried to authenticate with provided information, but failed.
	//
	AuthenticationError_ReasonAUTHENTICATION_FAILED AuthenticationError_Reason = "AUTHENTICATION_FAILED"

	//
	// The OAuth provided is invalid.
	//
	AuthenticationError_ReasonINVALID_OAUTH_SIGNATURE AuthenticationError_Reason = "INVALID_OAUTH_SIGNATURE"

	//
	// The specified service to use was not recognized.
	//
	AuthenticationError_ReasonINVALID_SERVICE AuthenticationError_Reason = "INVALID_SERVICE"

	//
	// The SOAP message is missing a request header with an {@code authToken} and optional {@code
	// networkCode}.
	//
	AuthenticationError_ReasonMISSING_SOAP_REQUEST_HEADER AuthenticationError_Reason = "MISSING_SOAP_REQUEST_HEADER"

	//
	// The HTTP request is missing a request header with an {@code authToken}
	//
	AuthenticationError_ReasonMISSING_AUTHENTICATION_HTTP_HEADER AuthenticationError_Reason = "MISSING_AUTHENTICATION_HTTP_HEADER"

	//
	// The request is missing an {@code authToken}
	//
	AuthenticationError_ReasonMISSING_AUTHENTICATION AuthenticationError_Reason = "MISSING_AUTHENTICATION"

	//
	// The network does not have API access enabled.
	//
	AuthenticationError_ReasonNETWORK_API_ACCESS_DISABLED AuthenticationError_Reason = "NETWORK_API_ACCESS_DISABLED"

	//
	// The user is not associated with any network.
	//
	AuthenticationError_ReasonNO_NETWORKS_TO_ACCESS AuthenticationError_Reason = "NO_NETWORKS_TO_ACCESS"

	//
	// No network for the given {@code networkCode} was found.
	//
	AuthenticationError_ReasonNETWORK_NOT_FOUND AuthenticationError_Reason = "NETWORK_NOT_FOUND"

	//
	// The user has access to more than one network, but did not provide a {@code networkCode}.
	//
	AuthenticationError_ReasonNETWORK_CODE_REQUIRED AuthenticationError_Reason = "NETWORK_CODE_REQUIRED"

	//
	// An error happened on the server side during connection to authentication service.
	//
	AuthenticationError_ReasonCONNECTION_ERROR AuthenticationError_Reason = "CONNECTION_ERROR"

	//
	// The user tried to create a test network using an account that already is associated with a
	// network.
	//
	AuthenticationError_ReasonGOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK AuthenticationError_Reason = "GOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK"

	//
	// The account is blocked and under investigation by the collections team. Please contact Google
	// for more information.
	//
	AuthenticationError_ReasonUNDER_INVESTIGATION AuthenticationError_Reason = "UNDER_INVESTIGATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AuthenticationError_ReasonUNKNOWN AuthenticationError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type BillingError_Reason string

const (

	//
	// Found unsupported billing schedule.
	//
	BillingError_ReasonUNSUPPORTED_BILLING_SCHEDULE BillingError_Reason = "UNSUPPORTED_BILLING_SCHEDULE"

	//
	// Found unsupported billing cap.
	//
	BillingError_ReasonUNSUPPORTED_BILLING_CAP BillingError_Reason = "UNSUPPORTED_BILLING_CAP"

	//
	// Billing source is missing when either billing scheule or billing cap is provided.
	//
	BillingError_ReasonMISSING_BILLING_SOURCE BillingError_Reason = "MISSING_BILLING_SOURCE"

	//
	// Billing schedule is missing when the provided billing source is CONSTRACTED.
	//
	BillingError_ReasonMISSING_BILLING_SCHEDULE BillingError_Reason = "MISSING_BILLING_SCHEDULE"

	//
	// Billing cap is missing when the provided billing source is not CONSTRACTED.
	//
	BillingError_ReasonMISSING_BILLING_CAP BillingError_Reason = "MISSING_BILLING_CAP"

	//
	// The billing source is invalid for offline proposal line item.
	//
	BillingError_ReasonINVALID_BILLING_SOURCE_FOR_OFFLINE BillingError_Reason = "INVALID_BILLING_SOURCE_FOR_OFFLINE"

	//
	// Billing settings cannot be updated once the proposal has been approved.
	//
	BillingError_ReasonUPDATE_BILLING_NOT_ALLOWED BillingError_Reason = "UPDATE_BILLING_NOT_ALLOWED"

	//
	// Billing base is missing when the provided billing source is CONTRACTED.
	//
	BillingError_ReasonMISSING_BILLING_BASE BillingError_Reason = "MISSING_BILLING_BASE"

	//
	// The billing base is invalid for the provided billing source.
	//
	BillingError_ReasonINVALID_BILLING_BASE BillingError_Reason = "INVALID_BILLING_BASE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	BillingError_ReasonUNKNOWN BillingError_Reason = "UNKNOWN"
)

type CollectionSizeError_Reason string

const (
	CollectionSizeError_ReasonTOO_LARGE CollectionSizeError_Reason = "TOO_LARGE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CollectionSizeError_ReasonUNKNOWN CollectionSizeError_Reason = "UNKNOWN"
)

//
// Describes reasons for common errors
//

type CommonError_Reason string

const (

	//
	// Indicates that an attempt was made to retrieve an entity that does not
	// exist.
	//
	CommonError_ReasonNOT_FOUND CommonError_Reason = "NOT_FOUND"

	//
	// Indicates that an attempt was made to create an entity that already
	// exists.
	//
	CommonError_ReasonALREADY_EXISTS CommonError_Reason = "ALREADY_EXISTS"

	//
	// Indicates that a value is not applicable for given use case.
	//
	CommonError_ReasonNOT_APPLICABLE CommonError_Reason = "NOT_APPLICABLE"

	//
	// Indicates that two elements in the collection were identical.
	//
	CommonError_ReasonDUPLICATE_OBJECT CommonError_Reason = "DUPLICATE_OBJECT"

	//
	// Indicates that an attempt was made to change an immutable field.
	//
	CommonError_ReasonCANNOT_UPDATE CommonError_Reason = "CANNOT_UPDATE"

	//
	// Indicates that the requested operation is not supported.
	//
	CommonError_ReasonUNSUPPORTED_OPERATION CommonError_Reason = "UNSUPPORTED_OPERATION"

	//
	// Indicates that another request attempted to update the same data in the same network
	// at about the same time. Please wait and try the request again.
	//
	CommonError_ReasonCONCURRENT_MODIFICATION CommonError_Reason = "CONCURRENT_MODIFICATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CommonError_ReasonUNKNOWN CommonError_Reason = "UNKNOWN"
)

//
// Descriptions of the types of sizes a creative can be.  Not all creatives can
// be described by a height-width pair, this provides additional context.
//

type CreativeSizeType string

const (

	//
	// Dimension based size, an actual height and width.
	//
	CreativeSizeTypePIXEL CreativeSizeType = "PIXEL"

	//
	// Mobile size, that is expressed as a ratio of say 4 by 1, that could be
	// met by a 100 x 25 sized image.
	//
	CreativeSizeTypeASPECT_RATIO CreativeSizeType = "ASPECT_RATIO"

	//
	// Out-of-page size, that is not related to the slot it is served.  But rather
	// is a function of the snippet, and the values set. This must be used with
	// 1x1 size.
	//
	CreativeSizeTypeINTERSTITIAL CreativeSizeType = "INTERSTITIAL"

	//
	// Size has no meaning
	//
	// <p>1. For Click Tracking entities, where size doesn't matter 2. For entities that allow all
	// requested sizes, where the size represents all sizes.
	//
	CreativeSizeTypeIGNORED CreativeSizeType = "IGNORED"

	//
	// Native size, which is a function of the how the client renders the creative.
	// This must be used with 1x1 size.
	//
	CreativeSizeTypeNATIVE CreativeSizeType = "NATIVE"

	//
	// Audio size. Used with audio ads. This must be used with 1x1 size.
	//
	CreativeSizeTypeAUDIO CreativeSizeType = "AUDIO"
)

//
// The reason behind the currency code error.
//

type CurrencyCodeError_Reason string

const (

	//
	// The currency code is invalid and does not follow ISO 4217.
	//
	CurrencyCodeError_ReasonINVALID CurrencyCodeError_Reason = "INVALID"

	//
	// The currency code is valid, but is not supported.
	//
	CurrencyCodeError_ReasonUNSUPPORTED CurrencyCodeError_Reason = "UNSUPPORTED"

	//
	// The currency has been used for entity creation after its deprecation
	//
	CurrencyCodeError_ReasonDEPRECATED_CURRENCY_USED CurrencyCodeError_Reason = "DEPRECATED_CURRENCY_USED"
)

//
// Specifies the available comparison operators.
//

type CustomCriteria_ComparisonOperator string

const (
	CustomCriteria_ComparisonOperatorIS CustomCriteria_ComparisonOperator = "IS"

	CustomCriteria_ComparisonOperatorIS_NOT CustomCriteria_ComparisonOperator = "IS_NOT"
)

//
// Specifies the available logical operators.
//

type CustomCriteriaSet_LogicalOperator string

const (
	CustomCriteriaSet_LogicalOperatorAND CustomCriteriaSet_LogicalOperator = "AND"

	CustomCriteriaSet_LogicalOperatorOR CustomCriteriaSet_LogicalOperator = "OR"
)

//
// The reasons for the target error.
//

type CustomFieldValueError_Reason string

const (

	//
	// An attempt was made to modify or create a {@link CustomFieldValue} for
	// a {@link CustomField} that does not exist.
	//
	CustomFieldValueError_ReasonCUSTOM_FIELD_NOT_FOUND CustomFieldValueError_Reason = "CUSTOM_FIELD_NOT_FOUND"

	//
	// An attempt was made to create a new value for a custom field
	// that is inactive.
	//
	CustomFieldValueError_ReasonCUSTOM_FIELD_INACTIVE CustomFieldValueError_Reason = "CUSTOM_FIELD_INACTIVE"

	//
	// An attempt was made to modify or create a {@link CustomFieldValue} corresponding
	// to a {@link CustomFieldOption} that could not be found.
	//
	CustomFieldValueError_ReasonCUSTOM_FIELD_OPTION_NOT_FOUND CustomFieldValueError_Reason = "CUSTOM_FIELD_OPTION_NOT_FOUND"

	//
	// An attempt was made to modify or create a {@link CustomFieldValue} with an
	// association to an entity of the wrong type for its field.
	//
	CustomFieldValueError_ReasonINVALID_ENTITY_TYPE CustomFieldValueError_Reason = "INVALID_ENTITY_TYPE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CustomFieldValueError_ReasonUNKNOWN CustomFieldValueError_Reason = "UNKNOWN"
)

//
// Specifies the available comparison operators.
//

type CmsMetadataCriteria_ComparisonOperator string

const (
	CmsMetadataCriteria_ComparisonOperatorEQUALS CmsMetadataCriteria_ComparisonOperator = "EQUALS"

	CmsMetadataCriteria_ComparisonOperatorNOT_EQUALS CmsMetadataCriteria_ComparisonOperator = "NOT_EQUALS"
)

//
// Specifies the available comparison operators.
//

type AudienceSegmentCriteria_ComparisonOperator string

const (
	AudienceSegmentCriteria_ComparisonOperatorIS AudienceSegmentCriteria_ComparisonOperator = "IS"

	AudienceSegmentCriteria_ComparisonOperatorIS_NOT AudienceSegmentCriteria_ComparisonOperator = "IS_NOT"
)

//
// Days of the week.
//

type DayOfWeek string

const (

	//
	// The day of week named Monday.
	//
	DayOfWeekMONDAY DayOfWeek = "MONDAY"

	//
	// The day of week named Tuesday.
	//
	DayOfWeekTUESDAY DayOfWeek = "TUESDAY"

	//
	// The day of week named Wednesday.
	//
	DayOfWeekWEDNESDAY DayOfWeek = "WEDNESDAY"

	//
	// The day of week named Thursday.
	//
	DayOfWeekTHURSDAY DayOfWeek = "THURSDAY"

	//
	// The day of week named Friday.
	//
	DayOfWeekFRIDAY DayOfWeek = "FRIDAY"

	//
	// The day of week named Saturday.
	//
	DayOfWeekSATURDAY DayOfWeek = "SATURDAY"

	//
	// The day of week named Sunday.
	//
	DayOfWeekSUNDAY DayOfWeek = "SUNDAY"
)

//
// Represents the time zone to be used for {@link DayPartTargeting}.
//

type DeliveryTimeZone string

const (

	//
	// Use the time zone of the publisher.
	//
	DeliveryTimeZonePUBLISHER DeliveryTimeZone = "PUBLISHER"

	//
	// Use the time zone of the browser.
	//
	DeliveryTimeZoneBROWSER DeliveryTimeZone = "BROWSER"
)

//
// The reasons for the target error.
//

type DealError_Reason string

const (

	//
	// Cannot add new {@link ProposalLineItem proposal line items} to a {@link Proposal} when
	// {@link Proposal#isSold} is {@code true}.
	//
	DealError_ReasonCANNOT_ADD_LINE_ITEM_WHEN_SOLD DealError_Reason = "CANNOT_ADD_LINE_ITEM_WHEN_SOLD"

	//
	// Cannot archive {@link ProposalLineItem proposal line items} from a {@link Proposal} when
	// {@link Proposal#isSold} is {@code true}.
	//
	DealError_ReasonCANNOT_ARCHIVE_LINE_ITEM_WHEN_SOLD DealError_Reason = "CANNOT_ARCHIVE_LINE_ITEM_WHEN_SOLD"

	//
	// Cannot archive a {@link Proposal} when {@link Proposal#isSold} is {@code true}.
	//
	DealError_ReasonCANNOT_ARCHIVE_PROPOSAL_WHEN_SOLD DealError_Reason = "CANNOT_ARCHIVE_PROPOSAL_WHEN_SOLD"

	//
	// Cannot change a field that requires buyer approval during the current operation.
	//
	DealError_ReasonCANNOT_CHANGE_FIELD_REQUIRING_BUYER_APPROVAL DealError_Reason = "CANNOT_CHANGE_FIELD_REQUIRING_BUYER_APPROVAL"

	//
	// Cannot find seller ID for the {@link Proposal}.
	//
	DealError_ReasonCANNOT_GET_SELLER_ID DealError_Reason = "CANNOT_GET_SELLER_ID"

	//
	// {@link Proposal} must be marked as editable by {@link EditProposalsForNegotiation} before
	// performing requested action.
	//
	DealError_ReasonCAN_ONLY_EXECUTE_IF_LOCAL_EDITS DealError_Reason = "CAN_ONLY_EXECUTE_IF_LOCAL_EDITS"

	//
	// {@link Proposal} contains no {@link ProposalLineItem proposal line items}.
	//
	DealError_ReasonMISSING_PROPOSAL_LINE_ITEMS DealError_Reason = "MISSING_PROPOSAL_LINE_ITEMS"

	//
	// No environment set for {@link Proposal}.
	//
	DealError_ReasonMISSING_ENVIRONMENT DealError_Reason = "MISSING_ENVIRONMENT"

	//
	// The Ad Exchange property is not associated with the current network.
	//
	DealError_ReasonMISSING_AD_EXCHANGE_PROPERTY DealError_Reason = "MISSING_AD_EXCHANGE_PROPERTY"

	//
	// Cannot find {@link Proposal} in Marketplace.
	//
	DealError_ReasonCANNOT_FIND_PROPOSAL_IN_MARKETPLACE DealError_Reason = "CANNOT_FIND_PROPOSAL_IN_MARKETPLACE"

	//
	// No {@link Product} exists for buyer-initiated programmatic {@link Proposal proposals}.
	//
	DealError_ReasonCANNOT_GET_PRODUCT DealError_Reason = "CANNOT_GET_PRODUCT"

	//
	// A new version of the {@link Proposal} was sent from buyer, cannot execute the requested
	// action before performing {@link DiscardLocalVersionEdits}.
	//
	DealError_ReasonNEW_VERSION_FROM_BUYER DealError_Reason = "NEW_VERSION_FROM_BUYER"

	//
	// A new version of the {@link Proposal} exists in Marketplace, cannot execute the requested
	// action before the proposal is synced to newest revision.
	//
	DealError_ReasonPROPOSAL_OUT_OF_SYNC_WITH_MARKETPLACE DealError_Reason = "PROPOSAL_OUT_OF_SYNC_WITH_MARKETPLACE"

	//
	// No {@link Proposal} changes were found.
	//
	DealError_ReasonNO_PROPOSAL_CHANGES_FOUND DealError_Reason = "NO_PROPOSAL_CHANGES_FOUND"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DealError_ReasonUNKNOWN DealError_Reason = "UNKNOWN"
)

//
// The reasons for the entity children limit reached error.
//

type EntityChildrenLimitReachedError_Reason string

const (

	//
	// The number of line items on the order exceeds the max number of line items allowed per order
	// in the network.
	//
	EntityChildrenLimitReachedError_ReasonLINE_ITEM_LIMIT_FOR_ORDER_REACHED EntityChildrenLimitReachedError_Reason = "LINE_ITEM_LIMIT_FOR_ORDER_REACHED"

	//
	// The number of creatives associated with the line item exceeds the max number of creatives
	// allowed to be associated with a line item in the network.
	//
	EntityChildrenLimitReachedError_ReasonCREATIVE_ASSOCIATION_LIMIT_FOR_LINE_ITEM_REACHED EntityChildrenLimitReachedError_Reason = "CREATIVE_ASSOCIATION_LIMIT_FOR_LINE_ITEM_REACHED"

	//
	// The number of ad units on the placement exceeds the max number of ad units
	// allowed per placement in the network.
	//
	EntityChildrenLimitReachedError_ReasonAD_UNIT_LIMIT_FOR_PLACEMENT_REACHED EntityChildrenLimitReachedError_Reason = "AD_UNIT_LIMIT_FOR_PLACEMENT_REACHED"

	//
	// The number of targeting expressions on the line item exceeds the max number of targeting
	// expressions allowed per line item in the network.
	//
	EntityChildrenLimitReachedError_ReasonTARGETING_EXPRESSION_LIMIT_FOR_LINE_ITEM_REACHED EntityChildrenLimitReachedError_Reason = "TARGETING_EXPRESSION_LIMIT_FOR_LINE_ITEM_REACHED"

	//
	// The size of a single targeting expression tree exceeds the max size allowed by the network.
	//
	EntityChildrenLimitReachedError_ReasonTARGETING_EXPRESSION_SIZE_LIMIT_REACHED EntityChildrenLimitReachedError_Reason = "TARGETING_EXPRESSION_SIZE_LIMIT_REACHED"

	//
	// The number of custom targeting values for the free-form or predefined custom targeting key
	// exceeds the max number allowed.
	//
	EntityChildrenLimitReachedError_ReasonCUSTOM_TARGETING_VALUES_FOR_KEY_LIMIT_REACHED EntityChildrenLimitReachedError_Reason = "CUSTOM_TARGETING_VALUES_FOR_KEY_LIMIT_REACHED"

	//
	// The total number of targeting expressions on the creatives for the line item exceeds
	// the max number allowed per line item in the network.
	//
	EntityChildrenLimitReachedError_ReasonTARGETING_EXPRESSION_LIMIT_FOR_CREATIVES_ON_LINE_ITEM_REACHED EntityChildrenLimitReachedError_Reason = "TARGETING_EXPRESSION_LIMIT_FOR_CREATIVES_ON_LINE_ITEM_REACHED"

	//
	// The number of attachments added to the proposal exceeds the max number
	// allowed per proposal in the network.
	//
	EntityChildrenLimitReachedError_ReasonATTACHMENT_LIMIT_FOR_PROPOSAL_REACHED EntityChildrenLimitReachedError_Reason = "ATTACHMENT_LIMIT_FOR_PROPOSAL_REACHED"

	//
	// The number of proposal line items on the proposal exceeds the max number
	// allowed per proposal in the network.
	//
	EntityChildrenLimitReachedError_ReasonPROPOSAL_LINE_ITEM_LIMIT_FOR_PROPOSAL_REACHED EntityChildrenLimitReachedError_Reason = "PROPOSAL_LINE_ITEM_LIMIT_FOR_PROPOSAL_REACHED"

	//
	// The number of product package items on the product package exceeds the max number
	// allowed per product package in the network.
	//
	EntityChildrenLimitReachedError_ReasonPRODUCT_LIMIT_FOR_PRODUCT_PACKAGE_REACHED EntityChildrenLimitReachedError_Reason = "PRODUCT_LIMIT_FOR_PRODUCT_PACKAGE_REACHED"

	//
	// The number of product template and product base rates on the rate card (including excluded
	// product base rates) exceeds the max number allowed per rate card in the network.
	//
	EntityChildrenLimitReachedError_ReasonPRODUCT_TEMPLATE_AND_PRODUCT_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED EntityChildrenLimitReachedError_Reason = "PRODUCT_TEMPLATE_AND_PRODUCT_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED"

	//
	// The number of product package item base rates on the rate card exceeds the max number
	// allowed per rate card in the network.
	//
	EntityChildrenLimitReachedError_ReasonPRODUCT_PACKAGE_ITEM_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED EntityChildrenLimitReachedError_Reason = "PRODUCT_PACKAGE_ITEM_BASE_RATE_LIMIT_FOR_RATE_CARD_REACHED"

	//
	// The number of premiums of the rate card exceeds the max number allowed per rate card
	// in the network.
	//
	EntityChildrenLimitReachedError_ReasonPREMIUM_LIMIT_FOR_RATE_CARD_REACHED EntityChildrenLimitReachedError_Reason = "PREMIUM_LIMIT_FOR_RATE_CARD_REACHED"

	//
	// The number of ad units on {@link AdExclusionRule#inventoryTargeting} exceeds the max number
	// of ad units allowed per ad exclusion rule inventory targeting in the network.
	//
	EntityChildrenLimitReachedError_ReasonAD_UNIT_LIMIT_FOR_AD_EXCLUSION_RULE_TARGETING_REACHED EntityChildrenLimitReachedError_Reason = "AD_UNIT_LIMIT_FOR_AD_EXCLUSION_RULE_TARGETING_REACHED"

	//
	// The number of native styles under the native creative template exceeds the
	// max number of native styles allowed per native creative template in the
	// network.
	//
	EntityChildrenLimitReachedError_ReasonNATIVE_STYLE_LIMIT_FOR_NATIVE_AD_FORMAT_REACHED EntityChildrenLimitReachedError_Reason = "NATIVE_STYLE_LIMIT_FOR_NATIVE_AD_FORMAT_REACHED"

	//
	// The number of targeting expressions on the native style exceeds the max number of targeting
	// expressions allowed per native style in the network.
	//
	EntityChildrenLimitReachedError_ReasonTARGETING_EXPRESSION_LIMIT_FOR_PRESENTATION_ASSIGNMENT_REACHED EntityChildrenLimitReachedError_Reason = "TARGETING_EXPRESSION_LIMIT_FOR_PRESENTATION_ASSIGNMENT_REACHED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityChildrenLimitReachedError_ReasonUNKNOWN EntityChildrenLimitReachedError_Reason = "UNKNOWN"
)

//
// The reasons for the entity limit reached error.
//

type EntityLimitReachedError_Reason string

const (

	//
	// The number of custom targeting values exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonCUSTOM_TARGETING_VALUES_LIMIT_REACHED EntityLimitReachedError_Reason = "CUSTOM_TARGETING_VALUES_LIMIT_REACHED"

	//
	// The number of ad exclusion rules exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonAD_EXCLUSION_RULES_LIMIT_REACHED EntityLimitReachedError_Reason = "AD_EXCLUSION_RULES_LIMIT_REACHED"

	//
	// The number of first party audience segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonFIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "FIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED"

	//
	// The number of active placements exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonPLACEMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "PLACEMENTS_LIMIT_REACHED"

	//
	// The number of line items excceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonLINE_ITEMS_LIMIT_REACHED EntityLimitReachedError_Reason = "LINE_ITEMS_LIMIT_REACHED"

	//
	// The number of active line items exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonACTIVE_LINE_ITEMS_LIMIT_REACHED EntityLimitReachedError_Reason = "ACTIVE_LINE_ITEMS_LIMIT_REACHED"

	//
	// The number of not-archived encoding profiles exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonDAI_ENCODING_PROFILES_LIMIT_REACHED EntityLimitReachedError_Reason = "DAI_ENCODING_PROFILES_LIMIT_REACHED"

	//
	// The number of traffic forecast segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonTRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "TRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED"

	//
	// The number of forecast adjustments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonFORECAST_ADJUSTMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "FORECAST_ADJUSTMENTS_LIMIT_REACHED"

	//
	// The number of active experiments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonACTIVE_EXPERIMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "ACTIVE_EXPERIMENTS_LIMIT_REACHED"

	//
	// The number of sites exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonSITES_LIMIT_REACHED EntityLimitReachedError_Reason = "SITES_LIMIT_REACHED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityLimitReachedError_ReasonUNKNOWN EntityLimitReachedError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ExchangeRateError_Reason string

const (

	//
	// The currency code is invalid and does not follow ISO 4217.
	//
	ExchangeRateError_ReasonINVALID_CURRENCY_CODE ExchangeRateError_Reason = "INVALID_CURRENCY_CODE"

	//
	// The currency code is not supported.
	//
	ExchangeRateError_ReasonUNSUPPORTED_CURRENCY_CODE ExchangeRateError_Reason = "UNSUPPORTED_CURRENCY_CODE"

	//
	// The currency code already exists. When creating an exchange rate, its currency should not be
	// associated with any existing exchange rate. When creating a list of exchange rates, there
	// should not be two exchange rates associated with same currency.
	//
	ExchangeRateError_ReasonCURRENCY_CODE_ALREADY_EXISTS ExchangeRateError_Reason = "CURRENCY_CODE_ALREADY_EXISTS"

	//
	// The exchange rate value is invalid. When the {@link ExchangeRate#refreshRate} is
	// {@link ExchangeRateRefreshRate#FIXED}, the {@link ExchangeRate#exchangeRate} should be larger
	// than 0. Otherwise it is invalid.
	//
	ExchangeRateError_ReasonINVALID_EXCHANGE_RATE ExchangeRateError_Reason = "INVALID_EXCHANGE_RATE"

	//
	// The exchange rate value is not found. When the {@link ExchangeRate#refreshRate} is
	// {@link ExchangeRateRefreshRate#DAILY} or {@link ExchangeRateRefreshRate#MONTHLY}, the
	// {@link ExchangeRate#exchangeRate} should be assigned by Google. It is not found if Google
	// cannot find such an exchange rate.
	//
	ExchangeRateError_ReasonEXCHANGE_RATE_NOT_FOUND ExchangeRateError_Reason = "EXCHANGE_RATE_NOT_FOUND"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ExchangeRateError_ReasonUNKNOWN ExchangeRateError_Reason = "UNKNOWN"
)

type FeatureError_Reason string

const (

	//
	// A feature is being used that is not enabled on the current network.
	//
	FeatureError_ReasonMISSING_FEATURE FeatureError_Reason = "MISSING_FEATURE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FeatureError_ReasonUNKNOWN FeatureError_Reason = "UNKNOWN"
)

//
// Reason why a forecast could not be retrieved.
//

type ForecastError_Reason string

const (

	//
	// The forecast could not be retrieved due to a server side
	// connection problem. Please try again soon.
	//
	ForecastError_ReasonSERVER_NOT_AVAILABLE ForecastError_Reason = "SERVER_NOT_AVAILABLE"

	//
	// There was an unexpected internal error.
	//
	ForecastError_ReasonINTERNAL_ERROR ForecastError_Reason = "INTERNAL_ERROR"

	//
	// The forecast could not be retrieved because there is not
	// enough forecasting data available yet. It may take up to one week before
	// enough data is available.
	//
	ForecastError_ReasonNO_FORECAST_YET ForecastError_Reason = "NO_FORECAST_YET"

	//
	// There's not enough inventory for the requested reservation.
	//
	ForecastError_ReasonNOT_ENOUGH_INVENTORY ForecastError_Reason = "NOT_ENOUGH_INVENTORY"

	//
	// No error from forecast.
	//
	ForecastError_ReasonSUCCESS ForecastError_Reason = "SUCCESS"

	//
	// The requested reservation is of zero length.  No forecast is returned.
	//
	ForecastError_ReasonZERO_LENGTH_RESERVATION ForecastError_Reason = "ZERO_LENGTH_RESERVATION"

	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>
	// Another way to mitigate this error is to limit requests to 2 per second.
	// Once again this does not guarantee that every request will succeed, but
	// may help reduce the number of times you receive this error.
	// </p>
	//
	ForecastError_ReasonEXCEEDED_QUOTA ForecastError_Reason = "EXCEEDED_QUOTA"

	//
	// The request falls outside the date range of the available data.
	//
	ForecastError_ReasonOUTSIDE_AVAILABLE_DATE_RANGE ForecastError_Reason = "OUTSIDE_AVAILABLE_DATE_RANGE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ForecastError_ReasonUNKNOWN ForecastError_Reason = "UNKNOWN"
)

//
// The single reason for the internal API error.
//

type InternalApiError_Reason string

const (

	//
	// API encountered an unexpected internal error.
	//
	InternalApiError_ReasonUNEXPECTED_INTERNAL_API_ERROR InternalApiError_Reason = "UNEXPECTED_INTERNAL_API_ERROR"

	//
	// A temporary error occurred during the request. Please retry.
	//
	InternalApiError_ReasonTRANSIENT_ERROR InternalApiError_Reason = "TRANSIENT_ERROR"

	//
	// The cause of the error is not known or only defined in newer versions.
	//
	InternalApiError_ReasonUNKNOWN InternalApiError_Reason = "UNKNOWN"

	//
	// The API is currently unavailable for a planned downtime.
	//
	InternalApiError_ReasonDOWNTIME InternalApiError_Reason = "DOWNTIME"

	//
	// Mutate succeeded but server was unable to build response. Client should not retry mutate.
	//
	InternalApiError_ReasonERROR_GENERATING_RESPONSE InternalApiError_Reason = "ERROR_GENERATING_RESPONSE"
)

type InvalidUrlError_Reason string

const (

	//
	// The URL contains invalid characters.
	//
	InvalidUrlError_ReasonILLEGAL_CHARACTERS InvalidUrlError_Reason = "ILLEGAL_CHARACTERS"

	//
	// The format of the URL is not allowed. This could occur for a number of
	// reasons. For example, if an invalid scheme is specified (like "ftp://")
	// or if a port is specified when not required, or if a query was specified
	// when not required.
	//
	InvalidUrlError_ReasonINVALID_FORMAT InvalidUrlError_Reason = "INVALID_FORMAT"

	//
	// URL contains insecure scheme.
	//
	InvalidUrlError_ReasonINSECURE_SCHEME InvalidUrlError_Reason = "INSECURE_SCHEME"

	//
	// The URL does not contain a scheme.
	//
	InvalidUrlError_ReasonNO_SCHEME InvalidUrlError_Reason = "NO_SCHEME"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InvalidUrlError_ReasonUNKNOWN InvalidUrlError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type LabelEntityAssociationError_Reason string

const (

	//
	// The label has already been attached to the entity.
	//
	LabelEntityAssociationError_ReasonDUPLICATE_ASSOCIATION LabelEntityAssociationError_Reason = "DUPLICATE_ASSOCIATION"

	//
	// A label is being applied to an entity that does not support that entity
	// type.
	//
	LabelEntityAssociationError_ReasonINVALID_ASSOCIATION LabelEntityAssociationError_Reason = "INVALID_ASSOCIATION"

	//
	// Label negation cannot be applied to the entity type.
	//
	LabelEntityAssociationError_ReasonNEGATION_NOT_ALLOWED LabelEntityAssociationError_Reason = "NEGATION_NOT_ALLOWED"

	//
	// The same label is being applied and negated to the same entity.
	//
	LabelEntityAssociationError_ReasonDUPLICATE_ASSOCIATION_WITH_NEGATION LabelEntityAssociationError_Reason = "DUPLICATE_ASSOCIATION_WITH_NEGATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LabelEntityAssociationError_ReasonUNKNOWN LabelEntityAssociationError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type LineItemOperationError_Reason string

const (

	//
	// The operation is not allowed due to lack of permissions.
	//
	LineItemOperationError_ReasonNOT_ALLOWED LineItemOperationError_Reason = "NOT_ALLOWED"

	//
	// The operation is not applicable for the current state of the
	// {@link LineItem}.
	//
	LineItemOperationError_ReasonNOT_APPLICABLE LineItemOperationError_Reason = "NOT_APPLICABLE"

	//
	// The {@link LineItem} is completed. A {@link LineItemAction} cannot
	// be applied to a line item that is completed.
	//
	LineItemOperationError_ReasonHAS_COMPLETED LineItemOperationError_Reason = "HAS_COMPLETED"

	//
	// The {@link LineItem} has no active creatives. A line item cannot be
	// activated with no active creatives.
	//
	LineItemOperationError_ReasonHAS_NO_ACTIVE_CREATIVES LineItemOperationError_Reason = "HAS_NO_ACTIVE_CREATIVES"

	//
	// A {@link LineItem} of type {@link LineItemType#LEGACY_DFP} cannot be
	// Activated.
	//
	LineItemOperationError_ReasonCANNOT_ACTIVATE_LEGACY_DFP_LINE_ITEM LineItemOperationError_Reason = "CANNOT_ACTIVATE_LEGACY_DFP_LINE_ITEM"

	//
	// A {@link LineItem} with publisher creative source cannot be activated if the corresponding
	// deal is not yet configured by the buyer.
	//
	LineItemOperationError_ReasonCANNOT_ACTIVATE_UNCONFIGURED_LINE_ITEM LineItemOperationError_Reason = "CANNOT_ACTIVATE_UNCONFIGURED_LINE_ITEM"

	//
	// Deleting an {@link LineItem} that has delivered is not allowed
	//
	LineItemOperationError_ReasonCANNOT_DELETE_DELIVERED_LINE_ITEM LineItemOperationError_Reason = "CANNOT_DELETE_DELIVERED_LINE_ITEM"

	//
	// Reservation cannot be made for line item because the
	// {@link LineItem#advertiserId} it is associated with has
	// {@link Company#creditStatus} that is not {@code ACTIVE}
	// or {@code ON_HOLD}.
	//
	LineItemOperationError_ReasonCANNOT_RESERVE_COMPANY_CREDIT_STATUS_NOT_ACTIVE LineItemOperationError_Reason = "CANNOT_RESERVE_COMPANY_CREDIT_STATUS_NOT_ACTIVE"

	//
	// Cannot activate line item  because the {@link LineItem#advertiserId}
	// it is associated with has {@link Company#creditStatus} that is not
	// {@code ACTIVE}, {@code INACTIVE}, or {@code ON_HOLD}.
	//
	LineItemOperationError_ReasonCANNOT_ACTIVATE_INVALID_COMPANY_CREDIT_STATUS LineItemOperationError_Reason = "CANNOT_ACTIVATE_INVALID_COMPANY_CREDIT_STATUS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	LineItemOperationError_ReasonUNKNOWN LineItemOperationError_Reason = "UNKNOWN"
)

//
// Minutes in an hour. Currently, only 0, 15, 30, and 45 are supported. This
// field is required.
//

type MinuteOfHour string

const (

	//
	// Zero minutes past hour.
	//
	MinuteOfHourZERO MinuteOfHour = "ZERO"

	//
	// Fifteen minutes past hour.
	//
	MinuteOfHourFIFTEEN MinuteOfHour = "FIFTEEN"

	//
	// Thirty minutes past hour.
	//
	MinuteOfHourTHIRTY MinuteOfHour = "THIRTY"

	//
	// Forty-five minutes past hour.
	//
	MinuteOfHourFORTY_FIVE MinuteOfHour = "FORTY_FIVE"
)

//
// Represents the {@link Proposal proposal's} negotiation status for Marketplace.
//

type NegotiationStatus string

const (

	//
	// Indicates that a new {@link Proposal} has been created by the seller and has not been sent to
	// Marketplace yet.
	//
	NegotiationStatusSELLER_INITIATED NegotiationStatus = "SELLER_INITIATED"

	//
	// Indicates that a new {@link Proposal} has been created by the buyer and is awaiting seller
	// action.
	//
	NegotiationStatusBUYER_INITIATED NegotiationStatus = "BUYER_INITIATED"

	//
	// Indicates that a {@link Proposal} has been updated by the buyer and is awaiting seller
	// approval.
	//
	NegotiationStatusAWAITING_SELLER_REVIEW NegotiationStatus = "AWAITING_SELLER_REVIEW"

	//
	// Indicates that a {@link Proposal} has been updated by the seller and is awaiting buyer
	// approval.
	//
	NegotiationStatusAWAITING_BUYER_REVIEW NegotiationStatus = "AWAITING_BUYER_REVIEW"

	//
	// Indicates that the seller has accepted the {@link Proposal} and is awaiting the buyer's
	// acceptance.
	//
	NegotiationStatusONLY_SELLER_ACCEPTED NegotiationStatus = "ONLY_SELLER_ACCEPTED"

	//
	// Indicates that the {@link Proposal} has been accepted by both the buyer and the seller.
	//
	NegotiationStatusFINALIZED NegotiationStatus = "FINALIZED"

	//
	// Indicates that negotiations for the {@link Proposal} have been cancelled.
	//
	NegotiationStatusCANCELLED NegotiationStatus = "CANCELLED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NegotiationStatusUNKNOWN NegotiationStatus = "UNKNOWN"
)

//
// The reasons for the target error.
//

type NotNullError_Reason string

const (

	//
	// Assuming that a method will not have more than 3 arguments, if it does,
	// return NULL
	//
	NotNullError_ReasonARG1_NULL NotNullError_Reason = "ARG1_NULL"

	NotNullError_ReasonARG2_NULL NotNullError_Reason = "ARG2_NULL"

	NotNullError_ReasonARG3_NULL NotNullError_Reason = "ARG3_NULL"

	NotNullError_ReasonNULL NotNullError_Reason = "NULL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NotNullError_ReasonUNKNOWN NotNullError_Reason = "UNKNOWN"
)

//
// The reasons for the validation error.
//

type NullError_Reason string

const (

	//
	// Specified list/container must not contain any null elements
	//
	NullError_ReasonNULL_CONTENT NullError_Reason = "NULL_CONTENT"
)

//
// The reasons for the target error.
//

type ParseError_Reason string

const (

	//
	// Indicates an error in parsing an attribute.
	//
	ParseError_ReasonUNPARSABLE ParseError_Reason = "UNPARSABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ParseError_ReasonUNKNOWN ParseError_Reason = "UNKNOWN"
)

//
// Describes reasons for permission errors.
//

type PermissionError_Reason string

const (

	//
	// User does not have the required permission for the request.
	//
	PermissionError_ReasonPERMISSION_DENIED PermissionError_Reason = "PERMISSION_DENIED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PermissionError_ReasonUNKNOWN PermissionError_Reason = "UNKNOWN"
)

//
// Describes reasons for precision errors.
//

type PrecisionError_Reason string

const (

	//
	// The lowest N digits of the number must be zero.
	//
	PrecisionError_ReasonWRONG_PRECISION PrecisionError_Reason = "WRONG_PRECISION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PrecisionError_ReasonUNKNOWN PrecisionError_Reason = "UNKNOWN"
)

//
// Possible error reasons for a programmatic error.
//

type ProgrammaticError_Reason string

const (

	//
	// Audience extension is not supported by programmatic line items.
	//
	ProgrammaticError_ReasonAUDIENCE_EXTENSION_NOT_SUPPORTED ProgrammaticError_Reason = "AUDIENCE_EXTENSION_NOT_SUPPORTED"

	//
	// Auto extension days is not supported by programmatic line items.
	//
	ProgrammaticError_ReasonAUTO_EXTENSION_DAYS_NOT_SUPPORTED ProgrammaticError_Reason = "AUTO_EXTENSION_DAYS_NOT_SUPPORTED"

	//
	// Video is currently not supported.
	//
	ProgrammaticError_ReasonVIDEO_NOT_SUPPORTED ProgrammaticError_Reason = "VIDEO_NOT_SUPPORTED"

	//
	// Roadblocking is not supported by programmatic line items.
	//
	ProgrammaticError_ReasonROADBLOCKING_NOT_SUPPORTED ProgrammaticError_Reason = "ROADBLOCKING_NOT_SUPPORTED"

	//
	// Programmatic line items do not support {@link CreativeRotationType#SEQUENTIAL}.
	//
	ProgrammaticError_ReasonINVALID_CREATIVE_ROTATION ProgrammaticError_Reason = "INVALID_CREATIVE_ROTATION"

	//
	// Programmatic line items only support {@link LineItemType#STANDARD} and
	// {@link LineItemType#SPONSORSHIP} if the relevant feature is on.
	//
	ProgrammaticError_ReasonINVALID_LINE_ITEM_TYPE ProgrammaticError_Reason = "INVALID_LINE_ITEM_TYPE"

	//
	// Programmatic line items only support {@link CostType#CPM}.
	//
	ProgrammaticError_ReasonINVALID_COST_TYPE ProgrammaticError_Reason = "INVALID_COST_TYPE"

	//
	// Programmatic line items only support a creative size that is supported by AdX.
	// The list of supported sizes is maintained based on the list published in the help docs:
	// <a href="https://support.google.com/adxseller/answer/1100453">
	// https://support.google.com/adxseller/answer/1100453</a>
	//
	ProgrammaticError_ReasonSIZE_NOT_SUPPORTED ProgrammaticError_Reason = "SIZE_NOT_SUPPORTED"

	//
	// Zero cost per unit is not supported by programmatic line items.
	//
	ProgrammaticError_ReasonZERO_COST_PER_UNIT_NOT_SUPPORTED ProgrammaticError_Reason = "ZERO_COST_PER_UNIT_NOT_SUPPORTED"

	//
	// Some fields cannot be updated on approved line items.
	//
	ProgrammaticError_ReasonCANNOT_UPDATE_FIELD_FOR_APPROVED_LINE_ITEMS ProgrammaticError_Reason = "CANNOT_UPDATE_FIELD_FOR_APPROVED_LINE_ITEMS"

	//
	// Creating a new line item in an approved order is not allowed.
	//
	ProgrammaticError_ReasonCANNOT_CREATE_LINE_ITEM_FOR_APPROVED_ORDER ProgrammaticError_Reason = "CANNOT_CREATE_LINE_ITEM_FOR_APPROVED_ORDER"

	//
	// Cannot change backfill web property for a programmatic line item whose order has been
	// approved.
	//
	ProgrammaticError_ReasonCANNOT_UPDATE_BACKFILL_WEB_PROPERTY_FOR_APPROVED_LINE_ITEMS ProgrammaticError_Reason = "CANNOT_UPDATE_BACKFILL_WEB_PROPERTY_FOR_APPROVED_LINE_ITEMS"

	//
	// Cost per unit is too low. It has to be at least 0.005 USD.
	//
	ProgrammaticError_ReasonCOST_PER_UNIT_TOO_LOW ProgrammaticError_Reason = "COST_PER_UNIT_TOO_LOW"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProgrammaticError_ReasonUNKNOWN ProgrammaticError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ProposalActionError_Reason string

const (

	//
	// The operation is not applicable to the current state.
	//
	ProposalActionError_ReasonNOT_APPLICABLE ProposalActionError_Reason = "NOT_APPLICABLE"

	//
	// The operation cannot be applied because the proposal is archived.
	//
	ProposalActionError_ReasonIS_ARCHIVED ProposalActionError_Reason = "IS_ARCHIVED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalActionError_ReasonUNKNOWN ProposalActionError_Reason = "UNKNOWN"
)

//
// Describes the type of a {@link Company} associated with a {@link Proposal}.
//

type ProposalCompanyAssociationType string

const (

	//
	// The company is a primary agency.
	//
	ProposalCompanyAssociationTypePRIMARY_AGENCY ProposalCompanyAssociationType = "PRIMARY_AGENCY"

	//
	// The company is a billing agency.
	//
	ProposalCompanyAssociationTypeBILLING_AGENCY ProposalCompanyAssociationType = "BILLING_AGENCY"

	//
	// The company is a branding agency.
	//
	ProposalCompanyAssociationTypeBRANDING_AGENCY ProposalCompanyAssociationType = "BRANDING_AGENCY"

	//
	// The company is other type of agency.
	//
	ProposalCompanyAssociationTypeOTHER_AGENCY ProposalCompanyAssociationType = "OTHER_AGENCY"

	//
	// The company is advertiser.
	//
	ProposalCompanyAssociationTypeADVERTISER ProposalCompanyAssociationType = "ADVERTISER"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalCompanyAssociationTypeUNKNOWN ProposalCompanyAssociationType = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ProposalError_Reason string

const (

	//
	// Unknown error from ad-server
	//
	ProposalError_ReasonAD_SERVER_UNKNOWN_ERROR ProposalError_Reason = "AD_SERVER_UNKNOWN_ERROR"

	//
	// Ad-server reports an api error for the operation.
	//
	ProposalError_ReasonAD_SERVER_API_ERROR ProposalError_Reason = "AD_SERVER_API_ERROR"

	//
	// Advertiser cannot be updated once the proposal has been reserved.
	//
	ProposalError_ReasonUPDATE_ADVERTISER_NOT_ALLOWED ProposalError_Reason = "UPDATE_ADVERTISER_NOT_ALLOWED"

	//
	// Proposal cannot be updated when its status is not {@code DRAFT} or it is archived.
	//
	ProposalError_ReasonUPDATE_PROPOSAL_NOT_ALLOWED ProposalError_Reason = "UPDATE_PROPOSAL_NOT_ALLOWED"

	//
	// {@link Contact Contacts} are not supported for {@link Company.Type#ADVERTISER advertisers}
	// in a programmatic {@link Proposal}.
	//
	ProposalError_ReasonCONTACT_UNSUPPORTED_FOR_ADVERTISER ProposalError_Reason = "CONTACT_UNSUPPORTED_FOR_ADVERTISER"

	//
	// Contact associated with a proposal does not belong to the specific company.
	//
	ProposalError_ReasonINVALID_CONTACT ProposalError_Reason = "INVALID_CONTACT"

	//
	// Contact associated with a proposal's advertiser or agency is duplicated.
	//
	ProposalError_ReasonDUPLICATED_CONTACT ProposalError_Reason = "DUPLICATED_CONTACT"

	//
	// A proposal cannot be created or updated because the company
	// it is associated with has {@link Company#creditStatus}
	// that is not {@code ACTIVE} or {@code ON_HOLD}.
	//
	ProposalError_ReasonUNACCEPTABLE_COMPANY_CREDIT_STATUS ProposalError_Reason = "UNACCEPTABLE_COMPANY_CREDIT_STATUS"

	//
	// Advertiser or agency associated with the proposal has {@link Company#creditStatus} that is
	// not {@code ACTIVE}.
	//
	ProposalError_ReasonCOMPANY_CREDIT_STATUS_NOT_ACTIVE ProposalError_Reason = "COMPANY_CREDIT_STATUS_NOT_ACTIVE"

	//
	// Cannot have other agencies without a primary agency.
	//
	ProposalError_ReasonPRIMARY_AGENCY_REQUIRED ProposalError_Reason = "PRIMARY_AGENCY_REQUIRED"

	//
	// Cannot have more than one primary agency.
	//
	ProposalError_ReasonPRIMARY_AGENCY_NOT_UNIQUE ProposalError_Reason = "PRIMARY_AGENCY_NOT_UNIQUE"

	//
	// The {@link Company} association type is not supported for programmatic
	// {@link Proposal proposals}.
	//
	ProposalError_ReasonUNSUPPORTED_COMPANY_ASSOCIATION_TYPE_FOR_PROGRAMMATIC_PROPOSAL ProposalError_Reason = "UNSUPPORTED_COMPANY_ASSOCIATION_TYPE_FOR_PROGRAMMATIC_PROPOSAL"

	//
	// Advertiser or agency associated with a proposal is duplicated.
	//
	ProposalError_ReasonDUPLICATED_COMPANY_ASSOCIATION ProposalError_Reason = "DUPLICATED_COMPANY_ASSOCIATION"

	//
	// Found duplicated primary or secondary sales person.
	//
	ProposalError_ReasonDUPLICATED_SALESPERSON ProposalError_Reason = "DUPLICATED_SALESPERSON"

	//
	// Found duplicated sales planner.
	//
	ProposalError_ReasonDUPLICATED_SALES_PLANNER ProposalError_Reason = "DUPLICATED_SALES_PLANNER"

	//
	// Found duplicated primary or secondary trafficker.
	//
	ProposalError_ReasonDUPLICATED_TRAFFICKER ProposalError_Reason = "DUPLICATED_TRAFFICKER"

	//
	// The proposal has no unarchived proposal line items.
	//
	ProposalError_ReasonHAS_NO_UNARCHIVED_PROPOSAL_LINEITEMS ProposalError_Reason = "HAS_NO_UNARCHIVED_PROPOSAL_LINEITEMS"

	//
	// One or more of the terms and conditions being added already exists on the proposal.
	//
	ProposalError_ReasonDUPLICATE_TERMS_AND_CONDITIONS ProposalError_Reason = "DUPLICATE_TERMS_AND_CONDITIONS"

	//
	// The currency code of the proposal is not supported by the current network. All supported
	// currencies can be found in the union of {@link Network#currencyCode} and
	// {@link Network#secondaryCurrencyCodes}.
	//
	ProposalError_ReasonUNSUPPORTED_PROPOSAL_CURRENCY_CODE ProposalError_Reason = "UNSUPPORTED_PROPOSAL_CURRENCY_CODE"

	//
	// The currency code of the proposal is not supported by the selected buyer.
	//
	ProposalError_ReasonUNSUPPORTED_BUYER_CURRENCY_CODE ProposalError_Reason = "UNSUPPORTED_BUYER_CURRENCY_CODE"

	//
	// The POC value of the proposal is invalid.
	//
	ProposalError_ReasonINVALID_POC ProposalError_Reason = "INVALID_POC"

	//
	// Currency cannot be updated once the proposal has been reserved.
	//
	ProposalError_ReasonUPDATE_CURRENCY_NOT_ALLOWED ProposalError_Reason = "UPDATE_CURRENCY_NOT_ALLOWED"

	//
	// Time zone cannot be updated once the proposal has been sold.
	//
	ProposalError_ReasonUPDATE_TIME_ZONE_NOT_ALLOWED ProposalError_Reason = "UPDATE_TIME_ZONE_NOT_ALLOWED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalError_ReasonUNKNOWN ProposalError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ProposalLineItemError_Reason string

const (

	//
	// The proposal line item's rate card is not the same as other proposal line items
	// in the proposal.
	//
	ProposalLineItemError_ReasonNOT_SAME_RATE_CARD ProposalLineItemError_Reason = "NOT_SAME_RATE_CARD"

	//
	// The proposal line item's type is not yet supported by Sales Manager.
	//
	ProposalLineItemError_ReasonLINE_ITEM_TYPE_NOT_ALLOWED ProposalLineItemError_Reason = "LINE_ITEM_TYPE_NOT_ALLOWED"

	//
	// The proposal line item's end date time is not after its start date time.
	//
	ProposalLineItemError_ReasonEND_DATE_TIME_NOT_AFTER_START_TIME ProposalLineItemError_Reason = "END_DATE_TIME_NOT_AFTER_START_TIME"

	//
	// The proposal line item's start date time is too late in the month. This error applies to
	// Programmatic Guaranteed deals sold on Nielsen audience measurement.
	//
	ProposalLineItemError_ReasonSTART_DATE_TIME_TOO_LATE_IN_MONTH ProposalLineItemError_Reason = "START_DATE_TIME_TOO_LATE_IN_MONTH"

	//
	// The proposal line item's end date time is after 1/1/2037.
	//
	ProposalLineItemError_ReasonEND_DATE_TIME_TOO_LATE ProposalLineItemError_Reason = "END_DATE_TIME_TOO_LATE"

	//
	// The proposal line item's start date time is in past.
	//
	ProposalLineItemError_ReasonSTART_DATE_TIME_IS_IN_PAST ProposalLineItemError_Reason = "START_DATE_TIME_IS_IN_PAST"

	//
	// The proposal line item's end date time is in past.
	//
	ProposalLineItemError_ReasonEND_DATE_TIME_IS_IN_PAST ProposalLineItemError_Reason = "END_DATE_TIME_IS_IN_PAST"

	//
	// Frontloaded delivery rate type is not allowed.
	//
	ProposalLineItemError_ReasonFRONTLOADED_NOT_ALLOWED ProposalLineItemError_Reason = "FRONTLOADED_NOT_ALLOWED"

	//
	// Roadblocking to display all creatives is not allowed.
	//
	ProposalLineItemError_ReasonALL_ROADBLOCK_NOT_ALLOWED ProposalLineItemError_Reason = "ALL_ROADBLOCK_NOT_ALLOWED"

	//
	// Display all companions is not allowed.
	//
	ProposalLineItemError_ReasonALL_COMPANION_DELIVERY_NOT_ALLOWED ProposalLineItemError_Reason = "ALL_COMPANION_DELIVERY_NOT_ALLOWED"

	//
	// Roadblocking to display all master and companion creative set is not allowed.
	//
	ProposalLineItemError_ReasonCREATIVE_SET_ROADBLOCK_NOT_ALLOWED ProposalLineItemError_Reason = "CREATIVE_SET_ROADBLOCK_NOT_ALLOWED"

	//
	// Some changes may not be allowed because the related line item has already started.
	//
	ProposalLineItemError_ReasonALREADY_STARTED ProposalLineItemError_Reason = "ALREADY_STARTED"

	//
	// The setting is conflict with product's restriction.
	//
	ProposalLineItemError_ReasonCONFLICT_WITH_PRODUCT ProposalLineItemError_Reason = "CONFLICT_WITH_PRODUCT"

	//
	// The proposal line item's setting violates the product's built-in targeting
	// compatibility restriction.
	//
	ProposalLineItemError_ReasonVIOLATE_BUILT_IN_TARGETING_COMPATIBILITY_RESTRICTION ProposalLineItemError_Reason = "VIOLATE_BUILT_IN_TARGETING_COMPATIBILITY_RESTRICTION"

	//
	// The proposal line item's setting violates the product's built-in targeting
	// locked restriction.
	//
	ProposalLineItemError_ReasonVIOLATE_BUILT_IN_TARGETING_LOCKED_RESTRICTION ProposalLineItemError_Reason = "VIOLATE_BUILT_IN_TARGETING_LOCKED_RESTRICTION"

	//
	// Cannot target mobile-only targeting criteria.
	//
	ProposalLineItemError_ReasonMOBILE_TECH_CRITERIA_NOT_SUPPORTED ProposalLineItemError_Reason = "MOBILE_TECH_CRITERIA_NOT_SUPPORTED"

	//
	// The targeting criteria type is unsupported.
	//
	ProposalLineItemError_ReasonUNSUPPORTED_TARGETING_TYPE ProposalLineItemError_Reason = "UNSUPPORTED_TARGETING_TYPE"

	//
	// The contracted cost does not match with what calculated from final rate and units bought.
	//
	ProposalLineItemError_ReasonWRONG_COST ProposalLineItemError_Reason = "WRONG_COST"

	//
	// The proposal line item targets an inventory type for which the network does not have a
	// corresponding web property.
	//
	ProposalLineItemError_ReasonNO_WEB_PROPERTY_FOR_TARGETED_REQUEST_PLATFORM ProposalLineItemError_Reason = "NO_WEB_PROPERTY_FOR_TARGETED_REQUEST_PLATFORM"

	//
	// The cost calculated from cost per unit and units is too high.
	//
	ProposalLineItemError_ReasonCALCULATED_COST_TOO_HIGH ProposalLineItemError_Reason = "CALCULATED_COST_TOO_HIGH"

	//
	// The line item priority is invalid if it's different than the default.
	//
	ProposalLineItemError_ReasonINVALID_PRIORITY_FOR_LINE_ITEM_TYPE ProposalLineItemError_Reason = "INVALID_PRIORITY_FOR_LINE_ITEM_TYPE"

	//
	// Propsoal line item cannot update when it is archived.
	//
	ProposalLineItemError_ReasonUPDATE_PROPOSAL_LINE_ITEM_NOT_ALLOWED ProposalLineItemError_Reason = "UPDATE_PROPOSAL_LINE_ITEM_NOT_ALLOWED"

	//
	// A proposal line item cannot be updated from having
	// {@link RoadblockingType#CREATIVE_SET} to having a different
	// RoadblockingType, or vice versa.
	//
	ProposalLineItemError_ReasonCANNOT_UPDATE_TO_OR_FROM_CREATIVE_SET_ROADBLOCK ProposalLineItemError_Reason = "CANNOT_UPDATE_TO_OR_FROM_CREATIVE_SET_ROADBLOCK"

	//
	// Serving creatives exactly in sequential order is not allowed.
	//
	ProposalLineItemError_ReasonSEQUENTIAL_CREATIVE_ROTATION_NOT_ALLOWED ProposalLineItemError_Reason = "SEQUENTIAL_CREATIVE_ROTATION_NOT_ALLOWED"

	//
	// Proposal line item cannot update its reservation detail once start delivering.
	//
	ProposalLineItemError_ReasonUPDATE_RESERVATION_NOT_ALLOWED ProposalLineItemError_Reason = "UPDATE_RESERVATION_NOT_ALLOWED"

	//
	// The companion delivery option is not valid for the roadblocking type.
	//
	ProposalLineItemError_ReasonINVALID_COMPANION_DELIVERY_OPTION_FOR_ROADBLOCKING_TYPE ProposalLineItemError_Reason = "INVALID_COMPANION_DELIVERY_OPTION_FOR_ROADBLOCKING_TYPE"

	//
	// Roadblocking type is inconsistent with creative placeholders. If the roadblocking
	// type is creative set, creative placeholders should contain companions,
	// and vice versa.
	//
	ProposalLineItemError_ReasonINCONSISTENT_ROADBLOCK_TYPE ProposalLineItemError_Reason = "INCONSISTENT_ROADBLOCK_TYPE"

	//
	// ContractedQuantityBuffer is only applicable to standard line item with
	// {@link RateType#CPC}/{@link RateType#CPM}/{@link RateType#VCPM} type.
	//
	ProposalLineItemError_ReasonINVALID_CONTRACTED_QUANTITY_BUFFER ProposalLineItemError_Reason = "INVALID_CONTRACTED_QUANTITY_BUFFER"

	//
	// One or more values on the proposal line item are not valid for a
	// {@link LineItemType#CLICK_TRACKING} line item type.
	//
	ProposalLineItemError_ReasonINVALID_VALUES_FOR_CLICK_TRACKING_LINE_ITEM_TYPE ProposalLineItemError_Reason = "INVALID_VALUES_FOR_CLICK_TRACKING_LINE_ITEM_TYPE"

	//
	// Proposal line item cannot update its cost adjustment after first approval.
	//
	ProposalLineItemError_ReasonUPDATE_COST_ADJUSTMENT_NOT_ALLOWED ProposalLineItemError_Reason = "UPDATE_COST_ADJUSTMENT_NOT_ALLOWED"

	//
	// The currency code of the proposal line item's rate card is not supported by
	// the current network. All supported currencies can be found in the union of
	// {@link Network#currencyCode} and {@link Network#secondaryCurrencyCodes}.
	//
	ProposalLineItemError_ReasonUNSUPPORTED_RATE_CARD_CURRENCY_CODE ProposalLineItemError_Reason = "UNSUPPORTED_RATE_CARD_CURRENCY_CODE"

	//
	// The corresponding line item is paused, but the proposal line item's end date time is before
	// the last paused time.
	//
	ProposalLineItemError_ReasonEND_DATE_TIME_IS_BEFORE_LAST_PAUSED_TIME ProposalLineItemError_Reason = "END_DATE_TIME_IS_BEFORE_LAST_PAUSED_TIME"

	//
	// Video line items cannot have roadblocking options.
	//
	ProposalLineItemError_ReasonVIDEO_INVALID_ROADBLOCKING ProposalLineItemError_Reason = "VIDEO_INVALID_ROADBLOCKING"

	//
	// Time zone cannot be updated once the proposal line item has been sold.
	//
	ProposalLineItemError_ReasonUPDATE_TIME_ZONE_NOT_ALLOWED ProposalLineItemError_Reason = "UPDATE_TIME_ZONE_NOT_ALLOWED"

	//
	// Time zone must be network time zone if the proposal line item is {@link RateType#VCPM}.
	//
	ProposalLineItemError_ReasonINVALID_TIME_ZONE_FOR_RATE_TYPE ProposalLineItemError_Reason = "INVALID_TIME_ZONE_FOR_RATE_TYPE"

	//
	// Only the {@link Network#timeZone} is allowed for programmatic {@link Proposal proposals}.
	//
	ProposalLineItemError_ReasonINVALID_TIME_ZONE_FOR_DEALS ProposalLineItemError_Reason = "INVALID_TIME_ZONE_FOR_DEALS"

	//
	// The {@link ProposalLineItem#environmentType} is invalid.
	//
	ProposalLineItemError_ReasonINVALID_ENVIRONMENT_TYPE ProposalLineItemError_Reason = "INVALID_ENVIRONMENT_TYPE"

	//
	// At least one size must be specified.
	//
	ProposalLineItemError_ReasonSIZE_REQUIRED ProposalLineItemError_Reason = "SIZE_REQUIRED"

	//
	// A placeholder contains companions but the roadblocking type is not
	// {@link RoadblockingType#CREATIVE_SET} or the {@link ProductType product type} is offline.
	//
	ProposalLineItemError_ReasonCOMPANION_NOT_ALLOWED ProposalLineItemError_Reason = "COMPANION_NOT_ALLOWED"

	//
	// A placeholder does not contain companions but the roadblocking type is
	// {@link RoadblockingType#CREATIVE_SET}.
	//
	ProposalLineItemError_ReasonMISSING_COMPANION ProposalLineItemError_Reason = "MISSING_COMPANION"

	//
	// A placeholder's master size is the same as another placeholder's master size.
	//
	ProposalLineItemError_ReasonDUPLICATED_MASTER_SIZE ProposalLineItemError_Reason = "DUPLICATED_MASTER_SIZE"

	//
	// Only creative placeholders with standard {@link CreativePlaceholder#size sizes} can set
	// an expected creative count.
	//
	ProposalLineItemError_ReasonINVALID_EXPECTED_CREATIVE_COUNT ProposalLineItemError_Reason = "INVALID_EXPECTED_CREATIVE_COUNT"

	//
	// Non-native placeholders cannot have creative templates.
	//
	ProposalLineItemError_ReasonCANNOT_HAVE_CREATIVE_TEMPLATE ProposalLineItemError_Reason = "CANNOT_HAVE_CREATIVE_TEMPLATE"

	//
	// Placeholders can only have native creative templates.
	//
	ProposalLineItemError_ReasonNATIVE_CREATIVE_TEMPLATE_REQUIRED ProposalLineItemError_Reason = "NATIVE_CREATIVE_TEMPLATE_REQUIRED"

	//
	// Cannot include native placeholders without native creative templates.
	//
	ProposalLineItemError_ReasonCANNOT_INCLUDE_NATIVE_PLACEHOLDER_WITHOUT_TEMPLATE_ID ProposalLineItemError_Reason = "CANNOT_INCLUDE_NATIVE_PLACEHOLDER_WITHOUT_TEMPLATE_ID"

	//
	// One or more values are not valid for a {@link LineItemType#CLICK_TRACKING} line item type.
	//
	ProposalLineItemError_ReasonINVALID_CLICK_TRACKING_LINE_ITEM_TYPE ProposalLineItemError_Reason = "INVALID_CLICK_TRACKING_LINE_ITEM_TYPE"

	//
	// The targeting is not valid for a {@link LineItemType#CLICK_TRACKING} line item type.
	//
	ProposalLineItemError_ReasonINVALID_TARGETING_FOR_CLICK_TRACKING ProposalLineItemError_Reason = "INVALID_TARGETING_FOR_CLICK_TRACKING"

	//
	// The contractedUnitsBought of the proposal line item is invalid.
	//
	ProposalLineItemError_ReasonINVALID_CONTRACTED_UNITS_BOUGHT ProposalLineItemError_Reason = "INVALID_CONTRACTED_UNITS_BOUGHT"

	//
	// Only creative placeholders with standard {@link CreativePlaceholder#size sizes} can contain
	// labels.
	//
	ProposalLineItemError_ReasonPLACEHOLDER_CANNOT_CONTAIN_LABELS ProposalLineItemError_Reason = "PLACEHOLDER_CANNOT_CONTAIN_LABELS"

	//
	// One or more labels on a creative placeholder is invalid.
	//
	ProposalLineItemError_ReasonINVALID_LABEL_TYPE_IN_PLACEHOLDER ProposalLineItemError_Reason = "INVALID_LABEL_TYPE_IN_PLACEHOLDER"

	//
	// A placeholder cannot contain a negated label.
	//
	ProposalLineItemError_ReasonPLACEHOLDER_CANNOT_CONTAIN_NEGATED_LABELS ProposalLineItemError_Reason = "PLACEHOLDER_CANNOT_CONTAIN_NEGATED_LABELS"

	//
	// Contracted impressions of programmatic proposal line item must be greater than already
	// delivered impressions.
	//
	ProposalLineItemError_ReasonCONTRACTED_UNITS_LESS_THAN_DELIVERED ProposalLineItemError_Reason = "CONTRACTED_UNITS_LESS_THAN_DELIVERED"

	//
	// If AdExchangeEnvironment is DISPLAY, the proposal line item must have mobile apps as excluded
	// device capability targeting.
	//
	ProposalLineItemError_ReasonDISPLAY_ENVIRONMENT_MUST_HAVE_EXCLUDED_MOBILE_APPS_TARGETING ProposalLineItemError_Reason = "DISPLAY_ENVIRONMENT_MUST_HAVE_EXCLUDED_MOBILE_APPS_TARGETING"

	//
	// If AdExchangeEnvironment is MOBILE, the proposal line item must have mobile apps as included
	// device capability targeting.
	//
	ProposalLineItemError_ReasonMOBILE_ENVIRONMENT_MUST_HAVE_INCLUDED_MOBILE_APPS_TARGETING ProposalLineItemError_Reason = "MOBILE_ENVIRONMENT_MUST_HAVE_INCLUDED_MOBILE_APPS_TARGETING"

	//
	// The {@code SkippableAdType} is not allowed.
	//
	ProposalLineItemError_ReasonSKIPPABLE_AD_TYPE_NOT_ALLOWED ProposalLineItemError_Reason = "SKIPPABLE_AD_TYPE_NOT_ALLOWED"

	//
	// Cross sell targeting is unsupported for this proposal line item.
	//
	ProposalLineItemError_ReasonCROSS_SELL_TARGETING_UNSUPPORTED ProposalLineItemError_Reason = "CROSS_SELL_TARGETING_UNSUPPORTED"

	//
	// Can't set a video duration for non video deals.
	//
	ProposalLineItemError_ReasonCANNOT_SET_VIDEO_DURATION_ON_NON_VIDEO_DEAL ProposalLineItemError_Reason = "CANNOT_SET_VIDEO_DURATION_ON_NON_VIDEO_DEAL"

	//
	// Cannot update video creative skippability on a YouTube-targeted proposal line item once it
	// has been sold (pushed to an order line item).
	//
	ProposalLineItemError_ReasonUPDATE_VIDEO_CREATIVE_SKIPPABILITY_NOT_ALLOWED ProposalLineItemError_Reason = "UPDATE_VIDEO_CREATIVE_SKIPPABILITY_NOT_ALLOWED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalLineItemError_ReasonUNKNOWN ProposalLineItemError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ProposalLineItemMakegoodError_Reason string

const (

	//
	// The original proposal line item for this makegood already has a makegood.
	//
	ProposalLineItemMakegoodError_ReasonORIGINAL_ALREADY_HAS_MAKEGOOD ProposalLineItemMakegoodError_Reason = "ORIGINAL_ALREADY_HAS_MAKEGOOD"

	//
	// The original proposal line item for this makegood is itself a makegood.
	//
	ProposalLineItemMakegoodError_ReasonORIGINAL_IS_MAKEGOOD ProposalLineItemMakegoodError_Reason = "ORIGINAL_IS_MAKEGOOD"

	//
	// The original proposal line item for this makegood has not been sold.
	//
	ProposalLineItemMakegoodError_ReasonORIGINAL_NOT_YET_SOLD ProposalLineItemMakegoodError_Reason = "ORIGINAL_NOT_YET_SOLD"

	//
	// This makegood or its original is not a standard line item.
	//
	ProposalLineItemMakegoodError_ReasonLINE_ITEM_IS_NOT_STANDARD ProposalLineItemMakegoodError_Reason = "LINE_ITEM_IS_NOT_STANDARD"

	//
	// This makegood or its original is not a CPM line item.
	//
	ProposalLineItemMakegoodError_ReasonLINE_ITEM_IS_NOT_CPM ProposalLineItemMakegoodError_Reason = "LINE_ITEM_IS_NOT_CPM"

	//
	// This makegood or its original has a cost type not supported on makegoods.
	//
	ProposalLineItemMakegoodError_ReasonMAKEGOODS_NOT_SUPPORTED_FOR_COST_TYPE ProposalLineItemMakegoodError_Reason = "MAKEGOODS_NOT_SUPPORTED_FOR_COST_TYPE"

	//
	// The original proposal line item for this makegood is too far in the past.
	//
	ProposalLineItemMakegoodError_ReasonORIGINAL_TOO_FAR_IN_PAST ProposalLineItemMakegoodError_Reason = "ORIGINAL_TOO_FAR_IN_PAST"

	//
	// This makegood has a rate that's different from the original proposal line item.
	//
	ProposalLineItemMakegoodError_ReasonRATE_DIFFERENT_THAN_ORIGINAL ProposalLineItemMakegoodError_Reason = "RATE_DIFFERENT_THAN_ORIGINAL"

	//
	// This makegood has an impression goal greater than the original proposal line item.
	//
	ProposalLineItemMakegoodError_ReasonUNITS_MORE_THAN_ORIGINAL ProposalLineItemMakegoodError_Reason = "UNITS_MORE_THAN_ORIGINAL"

	//
	// Makegoods are not supported for non-DV360 buyers.
	//
	ProposalLineItemMakegoodError_ReasonMAKEGOODS_NOT_SUPPORTED_FOR_NON_DV360_BUYERS ProposalLineItemMakegoodError_Reason = "MAKEGOODS_NOT_SUPPORTED_FOR_NON_DV360_BUYERS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalLineItemMakegoodError_ReasonUNKNOWN ProposalLineItemMakegoodError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type ProposalLineItemProgrammaticError_Reason string

const (

	//
	// Programmatic {@link ProposalLineItem proposal line items} only support
	// {@link ProductType#DFP}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_PRODUCT_TYPE ProposalLineItemProgrammaticError_Reason = "INVALID_PRODUCT_TYPE"

	//
	// {@link EnvironmentType#VIDEO_PLAYER} is currently not supported.
	//
	ProposalLineItemProgrammaticError_ReasonVIDEO_NOT_SUPPORTED ProposalLineItemProgrammaticError_Reason = "VIDEO_NOT_SUPPORTED"

	//
	// Programmatic {@link ProposalLineItem proposal line items} do not support
	// {@link RoadblockingType#CREATIVE_SET}.
	//
	ProposalLineItemProgrammaticError_ReasonROADBLOCKING_NOT_SUPPORTED ProposalLineItemProgrammaticError_Reason = "ROADBLOCKING_NOT_SUPPORTED"

	//
	// Programmatic {@link ProposalLineItem proposal line items} do not support
	// {@link CreativeRotationType#SEQUENTIAL}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_CREATIVE_ROTATION ProposalLineItemProgrammaticError_Reason = "INVALID_CREATIVE_ROTATION"

	//
	// Programmatic {@link ProposalLineItem proposal line items} only support
	// {@link LineItemType#STANDARD}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_PROPOSAL_LINE_ITEM_TYPE ProposalLineItemProgrammaticError_Reason = "INVALID_PROPOSAL_LINE_ITEM_TYPE"

	//
	// Programmatic {@link ProposalLineItem proposal line items} only support {@link RateType#CPM}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_RATE_TYPE ProposalLineItemProgrammaticError_Reason = "INVALID_RATE_TYPE"

	//
	// Programmatic {@link ProposalLineItem proposal line items} do not support zero for
	// {@link ProposalLineItem#netRate}.
	//
	ProposalLineItemProgrammaticError_ReasonZERO_COST_PER_UNIT_NOT_SUPPORTED ProposalLineItemProgrammaticError_Reason = "ZERO_COST_PER_UNIT_NOT_SUPPORTED"

	//
	// Only programmatic {@link ProposalLineItem proposal line items} support
	// {@link ProgrammaticCreativeSource}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_PROGRAMMATIC_CREATIVE_SOURCE ProposalLineItemProgrammaticError_Reason = "INVALID_PROGRAMMATIC_CREATIVE_SOURCE"

	//
	// Programmatic {@link ProposalLineItem proposal line item} has invalid video creative
	// duration.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_MAX_VIDEO_CREATIVE_DURATION ProposalLineItemProgrammaticError_Reason = "INVALID_MAX_VIDEO_CREATIVE_DURATION"

	//
	// Cannot update programmatic creative source if the {@link ProposalLineItem proposal line item}
	// has been sent to the buyer.
	//
	ProposalLineItemProgrammaticError_ReasonCANNOT_UPDATE_PROGRAMMATIC_CREATIVE_SOURCE ProposalLineItemProgrammaticError_Reason = "CANNOT_UPDATE_PROGRAMMATIC_CREATIVE_SOURCE"

	//
	// The {@link Goal#units} value is invalid.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_NUM_UNITS ProposalLineItemProgrammaticError_Reason = "INVALID_NUM_UNITS"

	//
	// Cannot mix guaranteed and Preferred Deal proposal line items in a programmatic proposal.
	//
	ProposalLineItemProgrammaticError_ReasonMIX_GUARANTEED_AND_PREFERRED_DEAL_NOT_ALLOWED ProposalLineItemProgrammaticError_Reason = "MIX_GUARANTEED_AND_PREFERRED_DEAL_NOT_ALLOWED"

	//
	// Cannot mix native and banner size in a programmatic proposal line item.
	//
	ProposalLineItemProgrammaticError_ReasonMIX_NATIVE_AND_BANNER_SIZE_NOT_ALLOWED ProposalLineItemProgrammaticError_Reason = "MIX_NATIVE_AND_BANNER_SIZE_NOT_ALLOWED"

	//
	// Cannot update sizes when a programmatic proposal line item with publisher creative source is
	// sent to a buyer.
	//
	ProposalLineItemProgrammaticError_ReasonCANNOT_UPDATE_SIZES ProposalLineItemProgrammaticError_Reason = "CANNOT_UPDATE_SIZES"

	//
	// The {ProposalLineItem#contractedUnitsBought} cannot be {@code null} or zero for programmatic
	// {@link RateType#CPD} {@link ProposalLineItem proposal line items}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_SPONSORSHIP_CONTRACTED_UNITS_BOUGHT ProposalLineItemProgrammaticError_Reason = "INVALID_SPONSORSHIP_CONTRACTED_UNITS_BOUGHT"

	//
	// Only {@link PricingModel#NET} is supported for programmatic
	// {@link ProposalLineItem proposal line items}.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_PROGRAMMATIC_PRICING_MODEL ProposalLineItemProgrammaticError_Reason = "INVALID_PROGRAMMATIC_PRICING_MODEL"

	//
	// Buyer is currently disabled for guaranteed deals due to violation of
	// Programmatic Guaranteed service level agreement.
	//
	ProposalLineItemProgrammaticError_ReasonBUYER_DISABLED_FOR_PG_VIOLATING_SLA ProposalLineItemProgrammaticError_Reason = "BUYER_DISABLED_FOR_PG_VIOLATING_SLA"

	//
	// Deals with agencies are limited to preferred deals, private auctions, and public
	// marketplace packages.
	//
	ProposalLineItemProgrammaticError_ReasonPG_NOT_SUPPORTED_FOR_AGENCY_BUYER ProposalLineItemProgrammaticError_Reason = "PG_NOT_SUPPORTED_FOR_AGENCY_BUYER"

	//
	// Buyer not found.
	//
	ProposalLineItemProgrammaticError_ReasonBUYER_NOT_FOUND ProposalLineItemProgrammaticError_Reason = "BUYER_NOT_FOUND"

	//
	// Cannot create/update {@link ProposalLineItem proposal line items} with an invalid
	// environment and request platform pair.
	//
	ProposalLineItemProgrammaticError_ReasonINVALID_ENVIRONMENT_PLATFORM_TYPE_PAIR ProposalLineItemProgrammaticError_Reason = "INVALID_ENVIRONMENT_PLATFORM_TYPE_PAIR"

	//
	// A {@link ProposalLineItem proposal line item} must either be of video, or audio type, but not
	// both.
	//
	ProposalLineItemProgrammaticError_ReasonCANNOT_MIX_AUDIO_VIDEO_PROGRAMMATIC_LINE_ITEM ProposalLineItemProgrammaticError_Reason = "CANNOT_MIX_AUDIO_VIDEO_PROGRAMMATIC_LINE_ITEM"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalLineItemProgrammaticError_ReasonUNKNOWN ProposalLineItemProgrammaticError_Reason = "UNKNOWN"
)

//
// Describes the {@link Proposal} status.
//

type ProposalStatus string

const (

	//
	// Indicates that the {@link Proposal} has just been created or retracted but no approval
	// has been requested yet.
	//
	ProposalStatusDRAFT ProposalStatus = "DRAFT"

	//
	// Indicates that a request for approval has been made for the {@link Proposal}.
	//
	ProposalStatusPENDING_APPROVAL ProposalStatus = "PENDING_APPROVAL"

	//
	// Indicates that the {@link Proposal} has been approved and is ready to serve.
	//
	ProposalStatusAPPROVED ProposalStatus = "APPROVED"

	//
	// Indicates that the {@link Proposal} has been rejected in the approval workflow.
	//
	ProposalStatusREJECTED ProposalStatus = "REJECTED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ProposalStatusUNKNOWN ProposalStatus = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PublisherQueryLanguageContextError_Reason string

const (

	//
	// Indicates that there was an error executing the PQL.
	//
	PublisherQueryLanguageContextError_ReasonUNEXECUTABLE PublisherQueryLanguageContextError_Reason = "UNEXECUTABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageContextError_ReasonUNKNOWN PublisherQueryLanguageContextError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PublisherQueryLanguageSyntaxError_Reason string

const (

	//
	// Indicates that there was a PQL syntax error.
	//
	PublisherQueryLanguageSyntaxError_ReasonUNPARSABLE PublisherQueryLanguageSyntaxError_Reason = "UNPARSABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageSyntaxError_ReasonUNKNOWN PublisherQueryLanguageSyntaxError_Reason = "UNKNOWN"
)

type QuotaError_Reason string

const (

	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>Another way to mitigate this error is to limit requests to 8 per second for Ad Manager
	// 360 accounts, or 2 per second for Ad Manager accounts. Once again
	// this does not guarantee that every request will succeed, but may help
	// reduce the number of times you receive this error.
	//
	QuotaError_ReasonEXCEEDED_QUOTA QuotaError_Reason = "EXCEEDED_QUOTA"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	QuotaError_ReasonUNKNOWN QuotaError_Reason = "UNKNOWN"

	//
	// This user has exceeded the allowed number of new report requests per hour
	// (this includes both reports run via the UI and reports
	// run via {@link ReportService#runReportJob}).
	// The recommended approach to handle this error is to wait about 10 minutes
	// and then retry the request. Note that this does not guarantee the request
	// will succeed. If it fails again, try increasing the wait time.
	// <p>Another way to mitigate this error is to limit the number of new report
	// requests to 250 per hour per user. Once again, this does not guarantee that
	// every request will succeed, but may help reduce the number of times you
	// receive this error.
	//
	QuotaError_ReasonREPORT_JOB_LIMIT QuotaError_Reason = "REPORT_JOB_LIMIT"

	//
	// This network has exceeded the allowed number of identifiers uploaded within a 24 hour period.
	// The recommended approach to handle this error is to wait 30 minutes and then retry the
	// request. Note that this does not guarantee the request will succeed. If it fails again, try
	// increasing the wait time.
	//
	QuotaError_ReasonSEGMENT_POPULATION_LIMIT QuotaError_Reason = "SEGMENT_POPULATION_LIMIT"
)

type RangeError_Reason string

const (
	RangeError_ReasonTOO_HIGH RangeError_Reason = "TOO_HIGH"

	RangeError_ReasonTOO_LOW RangeError_Reason = "TOO_LOW"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RangeError_ReasonUNKNOWN RangeError_Reason = "UNKNOWN"
)

//
// Represents the platform which requests and renders the ad.
//

type RequestPlatform string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequestPlatformUNKNOWN RequestPlatform = "UNKNOWN"

	//
	// Represents a request made from a web browser. This includes both desktop and mobile web.
	//
	RequestPlatformBROWSER RequestPlatform = "BROWSER"

	//
	// Represents a request made from a mobile application. This includes mobile app interstitial and
	// rewarded video requests.
	//
	RequestPlatformMOBILE_APP RequestPlatform = "MOBILE_APP"

	//
	// Represents a request made from a video player that is playing publisher content. This includes
	// video players embedded in web pages and mobile applications, and connected TV screens.
	//
	RequestPlatformVIDEO_PLAYER RequestPlatform = "VIDEO_PLAYER"
)

type RequiredCollectionError_Reason string

const (

	//
	// A required collection is missing.
	//
	RequiredCollectionError_ReasonREQUIRED RequiredCollectionError_Reason = "REQUIRED"

	//
	// Collection size is too large.
	//
	RequiredCollectionError_ReasonTOO_LARGE RequiredCollectionError_Reason = "TOO_LARGE"

	//
	// Collection size is too small.
	//
	RequiredCollectionError_ReasonTOO_SMALL RequiredCollectionError_Reason = "TOO_SMALL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredCollectionError_ReasonUNKNOWN RequiredCollectionError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type RequiredError_Reason string

const (

	//
	// Missing required field.
	//
	RequiredError_ReasonREQUIRED RequiredError_Reason = "REQUIRED"
)

//
// Describes reasons for a number to be invalid.
//

type RequiredNumberError_Reason string

const (
	RequiredNumberError_ReasonREQUIRED RequiredNumberError_Reason = "REQUIRED"

	RequiredNumberError_ReasonTOO_LARGE RequiredNumberError_Reason = "TOO_LARGE"

	RequiredNumberError_ReasonTOO_SMALL RequiredNumberError_Reason = "TOO_SMALL"

	RequiredNumberError_ReasonTOO_LARGE_WITH_DETAILS RequiredNumberError_Reason = "TOO_LARGE_WITH_DETAILS"

	RequiredNumberError_ReasonTOO_SMALL_WITH_DETAILS RequiredNumberError_Reason = "TOO_SMALL_WITH_DETAILS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredNumberError_ReasonUNKNOWN RequiredNumberError_Reason = "UNKNOWN"
)

//
// Decribes the type of {@link BuyerRfp}.
//

type RfpType string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RfpTypeUNKNOWN RfpType = "UNKNOWN"

	//
	// Indicates the {@link BuyerRfp} is a Programmatic Guaranteed RFP.
	//
	RfpTypePROGRAMMATIC_GUARANTEED RfpType = "PROGRAMMATIC_GUARANTEED"

	//
	// Indicates the {@link BuyerRfp} is a Preferred Deal RFP.
	//
	RfpTypePREFERRED_DEAL RfpType = "PREFERRED_DEAL"
)

//
// Reason of the given {@link AudienceSegmentError}.
//

type AudienceSegmentError_Reason string

const (

	//
	// First party audience segment is not supported.
	//
	AudienceSegmentError_ReasonFIRST_PARTY_AUDIENCE_SEGMENT_NOT_SUPPORTED AudienceSegmentError_Reason = "FIRST_PARTY_AUDIENCE_SEGMENT_NOT_SUPPORTED"

	//
	// Only rule-based first-party audience segments can be created.
	//
	AudienceSegmentError_ReasonONLY_RULE_BASED_FIRST_PARTY_AUDIENCE_SEGMENTS_CAN_BE_CREATED AudienceSegmentError_Reason = "ONLY_RULE_BASED_FIRST_PARTY_AUDIENCE_SEGMENTS_CAN_BE_CREATED"

	//
	// Audience segment for the given id is not found.
	//
	AudienceSegmentError_ReasonAUDIENCE_SEGMENT_ID_NOT_FOUND AudienceSegmentError_Reason = "AUDIENCE_SEGMENT_ID_NOT_FOUND"

	//
	// Audience segment rule is invalid.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_RULE AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_RULE"

	//
	// Audience segment rule contains too many ad units and/or custom criteria.
	//
	AudienceSegmentError_ReasonAUDIENCE_SEGMENT_RULE_TOO_LONG AudienceSegmentError_Reason = "AUDIENCE_SEGMENT_RULE_TOO_LONG"

	//
	// Audience segment name is invalid.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_NAME AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_NAME"

	//
	// Audience segment with this name already exists.
	//
	AudienceSegmentError_ReasonDUPLICATE_AUDIENCE_SEGMENT_NAME AudienceSegmentError_Reason = "DUPLICATE_AUDIENCE_SEGMENT_NAME"

	//
	// Audience segment description is invalid.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_DESCRIPTION AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_DESCRIPTION"

	//
	// Audience segment pageviews value is invalid. It must be between 1 and 12.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_PAGEVIEWS AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_PAGEVIEWS"

	//
	// Audience segment recency value is invalid. It must be between 1 and 90 if pageviews > 1.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_RECENCY AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_RECENCY"

	//
	// Audience segment membership expiration value is invalid. It must be between 1 and 180.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_MEMBERSHIP_EXPIRATION AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_MEMBERSHIP_EXPIRATION"

	//
	// The given custom key cannot be part of audience segment rule due to unsupported characters.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_CUSTOM_KEY_NAME AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_CUSTOM_KEY_NAME"

	//
	// The given custom value cannot be part of audience segment rule due to unsupported characters.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_NAME AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_NAME"

	//
	// Broad-match custom value cannot be part of audience segment rule.
	//
	AudienceSegmentError_ReasonINVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_MATCH_TYPE AudienceSegmentError_Reason = "INVALID_AUDIENCE_SEGMENT_CUSTOM_VALUE_MATCH_TYPE"

	//
	// Audience segment rule cannot contain itself.
	//
	AudienceSegmentError_ReasonINVALID_NESTED_FIRST_PARTY_AUDIENCE_SEGMENT AudienceSegmentError_Reason = "INVALID_NESTED_FIRST_PARTY_AUDIENCE_SEGMENT"

	//
	// Audience segment rule cannot contain shared selling inventory unit.
	//
	AudienceSegmentError_ReasonSHARED_SELLING_PARTNER_ROOT_CANNOT_BE_INCLUDED AudienceSegmentError_Reason = "SHARED_SELLING_PARTNER_ROOT_CANNOT_BE_INCLUDED"

	//
	// Audience segment rule cannot contain a nested third-party segment.
	//
	AudienceSegmentError_ReasonINVALID_NESTED_THIRD_PARTY_AUDIENCE_SEGMENT AudienceSegmentError_Reason = "INVALID_NESTED_THIRD_PARTY_AUDIENCE_SEGMENT"

	//
	// Audience segment rule cannot contain a nested inactive segment.
	//
	AudienceSegmentError_ReasonINACTIVE_NESTED_AUDIENCE_SEGMENT AudienceSegmentError_Reason = "INACTIVE_NESTED_AUDIENCE_SEGMENT"

	//
	// An error occurred when purchasing global licenses.
	//
	AudienceSegmentError_ReasonAUDIENCE_SEGMENT_GLOBAL_LICENSE_ERROR AudienceSegmentError_Reason = "AUDIENCE_SEGMENT_GLOBAL_LICENSE_ERROR"

	//
	// Segment cannot be activated as it violates Google's Platform Policy.
	//
	AudienceSegmentError_ReasonSEGMENT_VIOLATED_POLICY AudienceSegmentError_Reason = "SEGMENT_VIOLATED_POLICY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AudienceSegmentError_ReasonUNKNOWN AudienceSegmentError_Reason = "UNKNOWN"
)

//
// Describes reasons for server errors
//

type ServerError_Reason string

const (

	//
	// Indicates that an unexpected error occured.
	//
	ServerError_ReasonSERVER_ERROR ServerError_Reason = "SERVER_ERROR"

	//
	// Indicates that the server is currently experiencing a high load. Please
	// wait and try your request again.
	//
	ServerError_ReasonSERVER_BUSY ServerError_Reason = "SERVER_BUSY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ServerError_ReasonUNKNOWN ServerError_Reason = "UNKNOWN"
)

type StatementError_Reason string

const (

	//
	// A bind variable has not been bound to a value.
	//
	StatementError_ReasonVARIABLE_NOT_BOUND_TO_VALUE StatementError_Reason = "VARIABLE_NOT_BOUND_TO_VALUE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StatementError_ReasonUNKNOWN StatementError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type StringFormatError_Reason string

const (
	StringFormatError_ReasonUNKNOWN StringFormatError_Reason = "UNKNOWN"

	//
	// The input string value contains disallowed characters.
	//
	StringFormatError_ReasonILLEGAL_CHARS StringFormatError_Reason = "ILLEGAL_CHARS"

	//
	// The input string value is invalid for the associated field.
	//
	StringFormatError_ReasonINVALID_FORMAT StringFormatError_Reason = "INVALID_FORMAT"
)

type StringLengthError_Reason string

const (
	StringLengthError_ReasonTOO_LONG StringLengthError_Reason = "TOO_LONG"

	StringLengthError_ReasonTOO_SHORT StringLengthError_Reason = "TOO_SHORT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StringLengthError_ReasonUNKNOWN StringLengthError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type TeamError_Reason string

const (

	//
	// User cannot use this entity because it is not on any of the user's teams.
	//
	TeamError_ReasonENTITY_NOT_ON_USERS_TEAMS TeamError_Reason = "ENTITY_NOT_ON_USERS_TEAMS"

	//
	// The targeted or excluded ad unit must be on the order's teams.
	//
	TeamError_ReasonAD_UNITS_NOT_ON_ORDER_TEAMS TeamError_Reason = "AD_UNITS_NOT_ON_ORDER_TEAMS"

	//
	// The targeted placement must be on the order's teams.
	//
	TeamError_ReasonPLACEMENTS_NOT_ON_ORDER_TEAMS TeamError_Reason = "PLACEMENTS_NOT_ON_ORDER_TEAMS"

	//
	// Entity cannot be created because it is not on any of the user's teams.
	//
	TeamError_ReasonMISSING_USERS_TEAM TeamError_Reason = "MISSING_USERS_TEAM"

	//
	// A team that gives access to all entities of a given type cannot be
	// associated with an entity of that type.
	//
	TeamError_ReasonALL_TEAM_ASSOCIATION_NOT_ALLOWED TeamError_Reason = "ALL_TEAM_ASSOCIATION_NOT_ALLOWED"

	//
	// The assignment of team to entities is invalid.
	//
	TeamError_ReasonINVALID_TEAM_ASSIGNMENT TeamError_Reason = "INVALID_TEAM_ASSIGNMENT"

	//
	// Cannot modify or create a team with an inactive status.
	//
	TeamError_ReasonCANNOT_UPDATE_INACTIVE_TEAM TeamError_Reason = "CANNOT_UPDATE_INACTIVE_TEAM"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TeamError_ReasonUNKNOWN TeamError_Reason = "UNKNOWN"
)

//
// Describes reasons for invalid timezone.
//

type TimeZoneError_Reason string

const (

	//
	// Indicates that the timezone ID provided is not supported.
	//
	TimeZoneError_ReasonINVALID_TIMEZONE_ID TimeZoneError_Reason = "INVALID_TIMEZONE_ID"

	//
	// Indicates that the timezone ID provided is in the wrong format.
	// The timezone ID must be in tz database format (e.g. "America/Los_Angeles").
	//
	TimeZoneError_ReasonTIMEZONE_ID_IN_WRONG_FORMAT TimeZoneError_Reason = "TIMEZONE_ID_IN_WRONG_FORMAT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TimeZoneError_ReasonUNKNOWN TimeZoneError_Reason = "UNKNOWN"
)

//
// Represents the options for targetable bumper positions, surrounding an ad
// pod, within a video stream. This includes before and after the supported ad
// pod positions, {@link VideoPositionType#PREROLL},
// {@link VideoPositionType#MIDROLL}, and {@link VideoPositionType#POSTROLL}.
//

type VideoBumperType string

const (

	//
	// Represents the bumper position before the ad pod.
	//
	VideoBumperTypeBEFORE VideoBumperType = "BEFORE"

	//
	// Represents the bumper position after the ad pod.
	//
	VideoBumperTypeAFTER VideoBumperType = "AFTER"
)

//
// Represents a targetable position within a video.
//

type VideoPosition_Type string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	VideoPosition_TypeUNKNOWN VideoPosition_Type = "UNKNOWN"

	//
	// This position targets all of the above video positions.
	//
	VideoPosition_TypeALL VideoPosition_Type = "ALL"

	//
	// The position defined as showing before the video starts playing.
	//
	VideoPosition_TypePREROLL VideoPosition_Type = "PREROLL"

	//
	// The position defined as showing within the middle of the playing video.
	//
	VideoPosition_TypeMIDROLL VideoPosition_Type = "MIDROLL"

	//
	// The position defined as showing after the video is completed.
	//
	VideoPosition_TypePOSTROLL VideoPosition_Type = "POSTROLL"
)

type CreateProposals struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createProposals"`

	Proposals []*Proposal `xml:"proposals,omitempty" json:"proposals,omitempty"`
}

type CreateProposalsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createProposalsResponse"`

	Rval []*Proposal `xml:"rval,omitempty" json:"rval,omitempty"`
}

type ApiExceptionFault ApiException

type GetMarketplaceCommentsByStatement struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getMarketplaceCommentsByStatement"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type GetMarketplaceCommentsByStatementResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getMarketplaceCommentsByStatementResponse"`

	Rval *MarketplaceCommentPage `xml:"rval,omitempty" json:"rval,omitempty"`
}

type GetProposalsByStatement struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getProposalsByStatement"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type GetProposalsByStatementResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getProposalsByStatementResponse"`

	Rval *ProposalPage `xml:"rval,omitempty" json:"rval,omitempty"`
}

type PerformProposalAction struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 performProposalAction"`

	ProposalAction *ProposalAction `xml:"proposalAction,omitempty" json:"proposalAction,omitempty"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type PerformProposalActionResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 performProposalActionResponse"`

	Rval *UpdateResult `xml:"rval,omitempty" json:"rval,omitempty"`
}

type UpdateProposals struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateProposals"`

	Proposals []*Proposal `xml:"proposals,omitempty" json:"proposals,omitempty"`
}

type UpdateProposalsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateProposalsResponse"`

	Rval []*Proposal `xml:"rval,omitempty" json:"rval,omitempty"`
}

type RequestHeader SoapRequestHeader

type ResponseHeader SoapResponseHeader

type ObjectValue struct {
	*_Value
}

type AdUnitTargeting struct {

	//
	// Included or excluded ad unit id.
	//
	AdUnitId string `xml:"adUnitId,omitempty" json:"adUnitId,omitempty"`

	//
	// Whether or not all descendants are included (or excluded) as part of including (or excluding)
	// this ad unit. By default, the value is {@code true} which means targeting this ad unit will
	// target all of its descendants.
	//
	IncludeDescendants bool `xml:"includeDescendants,omitempty" json:"includeDescendants,omitempty"`
}

type ApiError struct {

	//
	// The OGNL field path to identify cause of error.
	//
	FieldPath string `xml:"fieldPath,omitempty" json:"fieldPath,omitempty"`

	//
	// A parsed copy of the field path. For example, the field path "operations[1].operand"
	// corresponds to this list: {FieldPathElement(field = "operations", index = 1),
	// FieldPathElement(field = "operand", index = null)}.
	//
	FieldPathElements []*FieldPathElement `xml:"fieldPathElements,omitempty" json:"fieldPathElements,omitempty"`

	//
	// The data that caused the error.
	//
	Trigger string `xml:"trigger,omitempty" json:"trigger,omitempty"`

	//
	// A simple string representation of the error and reason.
	//
	ErrorString string `xml:"errorString,omitempty" json:"errorString,omitempty"`
}

type ApiException struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 ApiExceptionFault"`

	*ApplicationException

	//
	// List of errors.
	//
	Errors []*ApiError `xml:"errors,omitempty" json:"errors,omitempty"`
}

type TechnologyTargeting struct {

	//
	// The bandwidth groups being targeted by the {@link LineItem}.
	//
	BandwidthGroupTargeting *BandwidthGroupTargeting `xml:"bandwidthGroupTargeting,omitempty" json:"bandwidthGroupTargeting,omitempty"`

	//
	// The browsers being targeted by the {@link LineItem}.
	//
	BrowserTargeting *BrowserTargeting `xml:"browserTargeting,omitempty" json:"browserTargeting,omitempty"`

	//
	// The languages of browsers being targeted by the {@link LineItem}.
	//
	BrowserLanguageTargeting *BrowserLanguageTargeting `xml:"browserLanguageTargeting,omitempty" json:"browserLanguageTargeting,omitempty"`

	//
	// The device capabilities being targeted by the {@link LineItem}.
	//
	DeviceCapabilityTargeting *DeviceCapabilityTargeting `xml:"deviceCapabilityTargeting,omitempty" json:"deviceCapabilityTargeting,omitempty"`

	//
	// The device categories being targeted by the {@link LineItem}.
	//
	DeviceCategoryTargeting *DeviceCategoryTargeting `xml:"deviceCategoryTargeting,omitempty" json:"deviceCategoryTargeting,omitempty"`

	//
	// The device manufacturers being targeted by the {@link LineItem}.
	//
	DeviceManufacturerTargeting *DeviceManufacturerTargeting `xml:"deviceManufacturerTargeting,omitempty" json:"deviceManufacturerTargeting,omitempty"`

	//
	// The mobile carriers being targeted by the {@link LineItem}.
	//
	MobileCarrierTargeting *MobileCarrierTargeting `xml:"mobileCarrierTargeting,omitempty" json:"mobileCarrierTargeting,omitempty"`

	//
	// The mobile devices being targeted by the {@link LineItem}.
	//
	MobileDeviceTargeting *MobileDeviceTargeting `xml:"mobileDeviceTargeting,omitempty" json:"mobileDeviceTargeting,omitempty"`

	//
	// The mobile device submodels being targeted by the {@link LineItem}.
	//
	MobileDeviceSubmodelTargeting *MobileDeviceSubmodelTargeting `xml:"mobileDeviceSubmodelTargeting,omitempty" json:"mobileDeviceSubmodelTargeting,omitempty"`

	//
	// The operating systems being targeted by the {@link LineItem}.
	//
	OperatingSystemTargeting *OperatingSystemTargeting `xml:"operatingSystemTargeting,omitempty" json:"operatingSystemTargeting,omitempty"`

	//
	// The operating system versions being targeted by the {@link LineItem}.
	//
	OperatingSystemVersionTargeting *OperatingSystemVersionTargeting `xml:"operatingSystemVersionTargeting,omitempty" json:"operatingSystemVersionTargeting,omitempty"`
}

type ApiVersionError struct {
	*ApiError

	Reason *ApiVersionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ApplicationException struct {

	//
	// Error message.
	//
	Message string `xml:"message,omitempty" json:"message,omitempty"`
}

type AppliedLabel struct {

	//
	// The ID of a created {@link Label}.
	//
	LabelId int64 `xml:"labelId,omitempty" json:"labelId,omitempty"`

	//
	// {@code isNegated} should be set to {@code true} to negate the effects of {@code labelId}.
	//
	IsNegated bool `xml:"isNegated,omitempty" json:"isNegated,omitempty"`
}

type ArchiveProposals struct {
	*ProposalAction
}

type AuthenticationError struct {
	*ApiError

	Reason *AuthenticationError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type BandwidthGroup struct {
	*Technology
}

type BandwidthGroupTargeting struct {

	//
	// Indicates whether bandwidth groups should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// The bandwidth groups that are being targeted or excluded by the {@link LineItem}.
	//
	BandwidthGroups []*Technology `xml:"bandwidthGroups,omitempty" json:"bandwidthGroups,omitempty"`
}

type BaseCustomFieldValue struct {

	//
	// Id of the {@code CustomField} to which this value belongs. This attribute is required.
	//
	CustomFieldId int64 `xml:"customFieldId,omitempty" json:"customFieldId,omitempty"`
}

type BillingError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *BillingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type BooleanValue struct {
	*_Value

	//
	// The boolean value.
	//
	Value bool `xml:"value,omitempty" json:"value,omitempty"`
}

type Browser struct {
	*Technology

	//
	// Browser major version.
	//
	MajorVersion string `xml:"majorVersion,omitempty" json:"majorVersion,omitempty"`

	//
	// Browser minor version.
	//
	MinorVersion string `xml:"minorVersion,omitempty" json:"minorVersion,omitempty"`
}

type BrowserLanguage struct {
	*Technology
}

type BrowserLanguageTargeting struct {

	//
	// Indicates whether browsers languages should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Browser languages that are being targeted or excluded by the {@link LineItem}.
	//
	BrowserLanguages []*Technology `xml:"browserLanguages,omitempty" json:"browserLanguages,omitempty"`
}

type BrowserTargeting struct {

	//
	// Indicates whether browsers should be targeted or excluded. This attribute is optional and
	// defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Browsers that are being targeted or excluded by the {@link LineItem}.
	//
	Browsers []*Technology `xml:"browsers,omitempty" json:"browsers,omitempty"`
}

type BuyerRfp struct {

	//
	// CPM for the {@link Proposal} in question. Given that this field belongs to a request for
	// proposal (for which initially a {@link Proposal} does not yet exist), this field should serve
	// as guidance for publishers to create a {@link Proposal} with {@link LineItem}s reflecting this
	// CPM.
	// This attribute is read-only.
	//
	CostPerUnit *Money `xml:"costPerUnit,omitempty" json:"costPerUnit,omitempty"`

	//
	// The number of impressions per day that a buyer wishes to see in the {@link Proposal} derived
	// from the request for proposal in question.
	// This attribute is read-only.
	//
	Units int64 `xml:"units,omitempty" json:"units,omitempty"`

	//
	// Total amount of {@link Money} available to spend on this deal. In the case of Preferred Deal,
	// the budget is equal to the maximum amount of money a buyer is willing to spend on a given
	// {@link Proposal}, even though the budget might not be spent entirely, as impressions are not
	// guaranteed.
	// This attribute is read-only.
	//
	Budget *Money `xml:"budget,omitempty" json:"budget,omitempty"`

	//
	// Currency code for this deal's budget and CPM.
	// This attribute is read-only.
	//
	CurrencyCode string `xml:"currencyCode,omitempty" json:"currencyCode,omitempty"`

	//
	// The {@link DateTime} in which the proposed deal should start serving.
	// This attribute is read-only.
	//
	StartDateTime soap.XSDDateTime `xml:"startDateTime,omitempty" json:"startDateTime,omitempty"`

	//
	// The {@link DateTime} in which the proposed deal should end serving.
	// This attribute is read-only.
	//
	EndDateTime soap.XSDDateTime `xml:"endDateTime,omitempty" json:"endDateTime,omitempty"`

	//
	// A description of the proposed deal. This can be used for the buyer to tell the publisher more
	// detailed information about the deal in question.
	// This attribute is read-only.
	//
	Description string `xml:"description,omitempty" json:"description,omitempty"`

	//
	// A list of inventory sizes in which creatives will be eventually served.
	// This attribute is read-only.
	//
	CreativePlaceholders []*CreativePlaceholder `xml:"creativePlaceholders,omitempty" json:"creativePlaceholders,omitempty"`

	//
	// Targeting information for the proposal in question. Currently this field only contains {@link
	// GeoTargeting} information.
	// This attribute is read-only.
	//
	Targeting *Targeting `xml:"targeting,omitempty" json:"targeting,omitempty"`

	//
	// Additional terms of the deal in question. This field can be used to state more specific
	// targeting information for the deal, as well as any additional information regarding this deal.
	// Given that this field belongs to a request for proposal (for which initially a {@link Proposal}
	// does not yet exist), this field can be populated by buyers to specify additional information
	// that they wish publishers to incorporate into the {@link Proposal} derived from this request
	// for proposal.
	// This attribute is read-only.
	//
	AdditionalTerms string `xml:"additionalTerms,omitempty" json:"additionalTerms,omitempty"`

	//
	// Identifies the format of the inventory or "channel" through which the ad serves. Environments
	// currently supported include {@link AdExchangeEnvironment#DISPLAY}, {@link
	// AdExchangeEnvironment#VIDEO}, and {@link AdExchangeEnvironment#MOBILE}.
	// This attribute is read-only.
	//
	AdExchangeEnvironment *AdExchangeEnvironment `xml:"adExchangeEnvironment,omitempty" json:"adExchangeEnvironment,omitempty"`

	//
	// Deal type; either Programmatic Guaranteed or Preferred Deal. This field corresponds to the type
	// of {@link Proposal} that a buyer wishes to negotiate with a seller.
	// This attribute is read-only.
	//
	RfpType *RfpType `xml:"rfpType,omitempty" json:"rfpType,omitempty"`
}

type BuyerUserListTargeting struct {

	//
	// Whether the programmatic {@code LineItem} or {@code ProposalLineItem} object has buyer user
	// list targeting.
	//
	HasBuyerUserListTargeting bool `xml:"hasBuyerUserListTargeting,omitempty" json:"hasBuyerUserListTargeting,omitempty"`
}

type CollectionSizeError struct {
	*ApiError

	Reason *CollectionSizeError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CommonError struct {
	*ApiError

	Reason *CommonError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ContentTargeting struct {

	//
	// The IDs of content being targeted by the {@code LineItem}.
	//
	TargetedContentIds []int64 `xml:"targetedContentIds,omitempty" json:"targetedContentIds,omitempty"`

	//
	// The IDs of content being excluded by the {@code LineItem}.
	//
	ExcludedContentIds []int64 `xml:"excludedContentIds,omitempty" json:"excludedContentIds,omitempty"`

	//
	// A list of video content bundles, represented by {@link ContentBundle} IDs, that are being
	// targeted by the {@code LineItem}.
	//
	TargetedVideoContentBundleIds []int64 `xml:"targetedVideoContentBundleIds,omitempty" json:"targetedVideoContentBundleIds,omitempty"`

	//
	// A list of video content bundles, represented by {@link ContentBundle} IDs, that are being
	// excluded by the {@code LineItem}.
	//
	ExcludedVideoContentBundleIds []int64 `xml:"excludedVideoContentBundleIds,omitempty" json:"excludedVideoContentBundleIds,omitempty"`
}

type CreativePlaceholder struct {

	//
	// The dimensions that the creative is expected to have. This attribute is required.
	//
	Size *Size `xml:"size,omitempty" json:"size,omitempty"`

	//
	// The native creative template ID.
	//
	// <p>This value is only required if {@link #creativeSizeType} is {@link CreativeSizeType#NATIVE}.
	//
	CreativeTemplateId int64 `xml:"creativeTemplateId,omitempty" json:"creativeTemplateId,omitempty"`

	//
	// The companions that the creative is expected to have. This attribute can only be set if the
	// line item it belongs to has a {@link LineItem#environmentType} of {@link
	// EnvironmentType#VIDEO_PLAYER} or {@link LineItem#roadblockingType} of {@link
	// RoadblockingType#CREATIVE_SET}.
	//
	Companions []*CreativePlaceholder `xml:"companions,omitempty" json:"companions,omitempty"`

	//
	// The set of label frequency caps applied directly to this creative placeholder.
	//
	AppliedLabels []*AppliedLabel `xml:"appliedLabels,omitempty" json:"appliedLabels,omitempty"`

	//
	// Contains the set of labels applied directly to this creative placeholder as well as those
	// inherited from the creative template from which this creative placeholder was instantiated.
	// This field is readonly and is assigned by Google.
	//
	EffectiveAppliedLabels []*AppliedLabel `xml:"effectiveAppliedLabels,omitempty" json:"effectiveAppliedLabels,omitempty"`

	//
	// Expected number of creatives that will be uploaded corresponding to this creative placeholder.
	// This estimate is used to improve the accuracy of forecasting; for example, if label frequency
	// capping limits the number of times a creative may be served.
	//
	ExpectedCreativeCount int32 `xml:"expectedCreativeCount,omitempty" json:"expectedCreativeCount,omitempty"`

	//
	// Describes the types of sizes a creative can be. By default, the creative's size is {@link
	// CreativeSizeType#PIXEL}, which is a dimension based size (width-height pair).
	//
	CreativeSizeType *CreativeSizeType `xml:"creativeSizeType,omitempty" json:"creativeSizeType,omitempty"`

	//
	// The name of the {@link CreativeTargeting} for creatives this placeholder represents.
	//
	// <p>This attribute is optional. Specifying creative targeting here is for forecasting purposes
	// only and has no effect on serving. The same creative targeting should be specified on a {@link
	// LineItemCreativeAssociation} when associating a {@link Creative} with the {@link LineItem}.
	//
	TargetingName string `xml:"targetingName,omitempty" json:"targetingName,omitempty"`

	//
	// Indicate if the expected creative of this placeholder has an AMP only variant.
	//
	// <p>This attribute is optional. It is for forecasting purposes only and has no effect on
	// serving.
	//
	IsAmpOnly bool `xml:"isAmpOnly,omitempty" json:"isAmpOnly,omitempty"`
}

type CurrencyCodeError struct {
	*ApiError

	Reason *CurrencyCodeError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CustomCriteria struct {
	*CustomCriteriaLeaf

	//
	// The {@link CustomTargetingKey#id} of the {@link CustomTargetingKey} object that was created
	// using {@link CustomTargetingService}. This attribute is required.
	//
	KeyId int64 `xml:"keyId,omitempty" json:"keyId,omitempty"`

	//
	// The ids of {@link CustomTargetingValue} objects to target the custom targeting key with id
	// {@link CustomCriteria#keyId}. This attribute is required.
	//
	ValueIds []int64 `xml:"valueIds,omitempty" json:"valueIds,omitempty"`

	//
	// The comparison operator. This attribute is required.
	//
	Operator *CustomCriteria_ComparisonOperator `xml:"operator,omitempty" json:"operator,omitempty"`
}

type CustomCriteriaSet struct {
	*CustomCriteriaNode

	//
	// The logical operator to be applied to {@link CustomCriteriaSet#children}. This attribute is
	// required.
	// <span class="constraint Required">This attribute is required.</span>
	//
	LogicalOperator *CustomCriteriaSet_LogicalOperator `xml:"logicalOperator,omitempty" json:"logicalOperator,omitempty"`

	//
	// The custom criteria. This attribute is required.
	//
	Children []*CustomCriteriaNode `xml:"children,omitempty" json:"children,omitempty"`
}

type CustomFieldValue struct {
	*BaseCustomFieldValue

	//
	// The value for this field. The appropriate type of {@code Value} is determined by the {@link
	// CustomField#dataType} of the {@code CustomField} that this conforms to.
	//
	// <table>
	// <tr><th>{@link CustomFieldDataType}</th><th>{@link Value} type</th></tr>
	// <tr><td>{@link CustomFieldDataType#STRING STRING}</td><td>{@link TextValue}</td></tr>
	// <tr><td>{@link CustomFieldDataType#NUMBER NUMBER}</td><td>{@link NumberValue}</td></tr>
	// <tr><td>{@link CustomFieldDataType#TOGGLE TOGGLE}</td><td>{@link BooleanValue}</td></tr>
	// </table>
	//
	Value *_Value `xml:"value,omitempty" json:"value,omitempty"`
}

type CustomFieldValueError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *CustomFieldValueError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CmsMetadataCriteria struct {
	*CustomCriteriaLeaf

	//
	// The comparison operator. This attribute is required.
	//
	Operator *CmsMetadataCriteria_ComparisonOperator `xml:"operator,omitempty" json:"operator,omitempty"`

	//
	// The ids of {@link CmsMetadataValue} objects used to target CMS metadata. This attribute is
	// required.
	//
	CmsMetadataValueIds []int64 `xml:"cmsMetadataValueIds,omitempty" json:"cmsMetadataValueIds,omitempty"`
}

type CustomCriteriaLeaf struct {
	*CustomCriteriaNode
}

type CustomCriteriaNode struct {
}

type AudienceSegmentCriteria struct {
	*CustomCriteriaLeaf

	//
	// The comparison operator. This attribute is required.
	//
	Operator *AudienceSegmentCriteria_ComparisonOperator `xml:"operator,omitempty" json:"operator,omitempty"`

	//
	// The ids of {@link AudienceSegment} objects used to target audience segments. This attribute is
	// required.
	//
	AudienceSegmentIds []int64 `xml:"audienceSegmentIds,omitempty" json:"audienceSegmentIds,omitempty"`
}

type Date struct {

	//
	// Year (e.g., 2009)
	//
	Year int32 `xml:"year,omitempty" json:"year,omitempty"`

	//
	// Month (1..12)
	//
	Month int32 `xml:"month,omitempty" json:"month,omitempty"`

	//
	// Day (1..31)
	//
	Day int32 `xml:"day,omitempty" json:"day,omitempty"`
}

type DateTime struct {
	Date soap.XSDDate `xml:"date,omitempty" json:"date,omitempty"`

	Hour int32 `xml:"hour,omitempty" json:"hour,omitempty"`

	Minute int32 `xml:"minute,omitempty" json:"minute,omitempty"`

	Second int32 `xml:"second,omitempty" json:"second,omitempty"`

	TimeZoneId string `xml:"timeZoneId,omitempty" json:"timeZoneId,omitempty"`
}

type DateTimeRange struct {

	//
	// The start date time of this range. This field is optional and if it is not set then there is no
	// lower bound on the date time range. If this field is not set then {@code endDateTime} must be
	// specified.
	//
	StartDateTime soap.XSDDateTime `xml:"startDateTime,omitempty" json:"startDateTime,omitempty"`

	//
	// The end date time of this range. This field is optional and if it is not set then there is no
	// upper bound on the date time range. If this field is not set then {@code startDateTime} must be
	// specified.
	//
	EndDateTime soap.XSDDateTime `xml:"endDateTime,omitempty" json:"endDateTime,omitempty"`
}

type DateTimeRangeTargeting struct {
	TargetedDateTimeRanges []*DateTimeRange `xml:"targetedDateTimeRanges,omitempty" json:"targetedDateTimeRanges,omitempty"`
}

type DateTimeValue struct {
	*_Value

	//
	// The {@code DateTime} value.
	//
	Value soap.XSDDateTime `xml:"value,omitempty" json:"value,omitempty"`
}

type DateValue struct {
	*_Value

	//
	// The {@code Date} value.
	//
	Value soap.XSDDate `xml:"value,omitempty" json:"value,omitempty"`
}

type DayPart struct {

	//
	// Day of the week the target applies to. This field is required.
	//
	DayOfWeek *DayOfWeek `xml:"dayOfWeek,omitempty" json:"dayOfWeek,omitempty"`

	//
	// Represents the start time of the targeted period (inclusive).
	//
	StartTime *TimeOfDay `xml:"startTime,omitempty" json:"startTime,omitempty"`

	//
	// Represents the end time of the targeted period (exclusive).
	//
	EndTime *TimeOfDay `xml:"endTime,omitempty" json:"endTime,omitempty"`
}

type DayPartTargeting struct {

	//
	// Specifies days of the week and times at which a {@code LineItem} will be delivered.
	//
	// <p>If targeting all days and times, this value will be ignored.
	//
	DayParts []*DayPart `xml:"dayParts,omitempty" json:"dayParts,omitempty"`

	//
	// Specifies the time zone to be used for delivering {@link LineItem} objects. This attribute is
	// optional and defaults to {@link DeliveryTimeZone#BROWSER}.
	//
	// <p>Setting this has no effect if targeting all days and times.
	//
	TimeZone *DeliveryTimeZone `xml:"timeZone,omitempty" json:"timeZone,omitempty"`
}

type DealError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *DealError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type DeviceCapability struct {
	*Technology
}

type DeviceCapabilityTargeting struct {

	//
	// Device capabilities that are being targeted by the {@link LineItem}.
	//
	TargetedDeviceCapabilities []*Technology `xml:"targetedDeviceCapabilities,omitempty" json:"targetedDeviceCapabilities,omitempty"`

	//
	// Device capabilities that are being excluded by the {@link LineItem}.
	//
	ExcludedDeviceCapabilities []*Technology `xml:"excludedDeviceCapabilities,omitempty" json:"excludedDeviceCapabilities,omitempty"`
}

type DeviceCategory struct {
	*Technology
}

type DeviceCategoryTargeting struct {

	//
	// Device categories that are being targeted by the {@link LineItem}.
	//
	TargetedDeviceCategories []*Technology `xml:"targetedDeviceCategories,omitempty" json:"targetedDeviceCategories,omitempty"`

	//
	// Device categories that are being excluded by the {@link LineItem}.
	//
	ExcludedDeviceCategories []*Technology `xml:"excludedDeviceCategories,omitempty" json:"excludedDeviceCategories,omitempty"`
}

type DeviceManufacturer struct {
	*Technology
}

type DeviceManufacturerTargeting struct {

	//
	// Indicates whether device manufacturers should be targeted or excluded. This attribute is
	// optional and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Device manufacturers that are being targeted or excluded by the {@link LineItem}.
	//
	DeviceManufacturers []*Technology `xml:"deviceManufacturers,omitempty" json:"deviceManufacturers,omitempty"`
}

type DiscardLocalVersionEdits struct {
	*ProposalAction
}

type DropDownCustomFieldValue struct {
	*BaseCustomFieldValue

	//
	// The {@link CustomFieldOption#id ID} of the {@link CustomFieldOption} for this value.
	//
	CustomFieldOptionId int64 `xml:"customFieldOptionId,omitempty" json:"customFieldOptionId,omitempty"`
}

type EditProposalsForNegotiation struct {
	*ProposalAction
}

type EntityChildrenLimitReachedError struct {
	*ApiError

	Reason *EntityChildrenLimitReachedError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type EntityLimitReachedError struct {
	*ApiError

	Reason *EntityLimitReachedError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ExchangeRateError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ExchangeRateError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FeatureError struct {
	*ApiError

	Reason *FeatureError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FieldPathElement struct {

	//
	// The name of a field in lower camelcase. (e.g. "biddingStrategy")
	//
	Field string `xml:"field,omitempty" json:"field,omitempty"`

	//
	// For list fields, this is a 0-indexed position in the list. Null for non-list fields.
	//
	Index int32 `xml:"index,omitempty" json:"index,omitempty"`
}

type ForecastError struct {
	*ApiError

	//
	// The reason for the forecast error.
	//
	Reason *ForecastError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type GeoTargeting struct {

	//
	// The geographical locations being targeted by the {@link LineItem}.
	//
	TargetedLocations []*Location `xml:"targetedLocations,omitempty" json:"targetedLocations,omitempty"`

	//
	// The geographical locations being excluded by the {@link LineItem}.
	//
	ExcludedLocations []*Location `xml:"excludedLocations,omitempty" json:"excludedLocations,omitempty"`
}

type InternalApiError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *InternalApiError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InvalidUrlError struct {
	*ApiError

	Reason *InvalidUrlError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InventorySizeTargeting struct {

	//
	// Whether the inventory sizes should be targeted or excluded.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// A list of {@link TargetedSizeDto}s.
	//
	TargetedSizes []*TargetedSize `xml:"targetedSizes,omitempty" json:"targetedSizes,omitempty"`
}

type InventoryTargeting struct {

	//
	// A list of targeted {@link AdUnitTargeting}.
	//
	TargetedAdUnits []*AdUnitTargeting `xml:"targetedAdUnits,omitempty" json:"targetedAdUnits,omitempty"`

	//
	// A list of excluded {@link AdUnitTargeting}.
	//
	ExcludedAdUnits []*AdUnitTargeting `xml:"excludedAdUnits,omitempty" json:"excludedAdUnits,omitempty"`

	//
	// A list of targeted {@link Placement} ids.
	//
	TargetedPlacementIds []int64 `xml:"targetedPlacementIds,omitempty" json:"targetedPlacementIds,omitempty"`
}

type InventoryUrl struct {
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`
}

type InventoryUrlTargeting struct {
	TargetedUrls []*InventoryUrl `xml:"targetedUrls,omitempty" json:"targetedUrls,omitempty"`

	ExcludedUrls []*InventoryUrl `xml:"excludedUrls,omitempty" json:"excludedUrls,omitempty"`
}

type LabelEntityAssociationError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *LabelEntityAssociationError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type LineItemOperationError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *LineItemOperationError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type Location struct {

	//
	// Uniquely identifies each {@code Location}.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// The location type for this geographical entity (ex. "COUNTRY", "CITY", "STATE", "COUNTY", etc.)
	//
	Type_ string `xml:"type,omitempty" json:"type,omitempty"`

	//
	// The nearest location parent's ID for this geographical entity.
	//
	CanonicalParentId int32 `xml:"canonicalParentId,omitempty" json:"canonicalParentId,omitempty"`

	//
	// The localized name of the geographical entity.
	//
	DisplayName string `xml:"displayName,omitempty" json:"displayName,omitempty"`
}

type MarketplaceComment struct {

	//
	// The unique ID of the {@link Proposal} the comment belongs to.
	//
	ProposalId int64 `xml:"proposalId,omitempty" json:"proposalId,omitempty"`

	//
	// The comment made on the {@link Proposal}.
	//
	Comment string `xml:"comment,omitempty" json:"comment,omitempty"`

	//
	// The creation {@link DateTime} of this {@code MarketplaceComment}.
	//
	CreationTime soap.XSDDateTime `xml:"creationTime,omitempty" json:"creationTime,omitempty"`

	//
	// Indicates whether the {@code MarketplaceComment} was created by seller.
	//
	CreatedBySeller bool `xml:"createdBySeller,omitempty" json:"createdBySeller,omitempty"`
}

type MarketplaceCommentPage struct {

	//
	// The absolute index in the total result set on which this page begins.
	//
	StartIndex int32 `xml:"startIndex,omitempty" json:"startIndex,omitempty"`

	//
	// The collection of results contained within this page.
	//
	Results []*MarketplaceComment `xml:"results,omitempty" json:"results,omitempty"`
}

type ProposalMarketplaceInfo struct {

	//
	// The marketplace ID of this proposal. This is a shared ID between Ad Manager and the buy-side
	// platform. This value is null if the proposal has not been sent to the buyer.
	// This attribute is read-only.
	//
	MarketplaceId string `xml:"marketplaceId,omitempty" json:"marketplaceId,omitempty"`

	//
	// Whether the non-free-editable fields of a {@link Proposal} are opened for edit. A proposal that
	// is open for edit will not receive buyer updates from Marketplace. If the buyer updates the
	// proposal while this is open for local editing, Google will set {@link #isNewVersionFromBuyer}
	// to {@code true}. You will then need to call {@link DiscardProposalDrafts} to revert your edits
	// to get the buyer's latest changes.
	// This attribute is read-only.
	//
	HasLocalVersionEdits bool `xml:"hasLocalVersionEdits,omitempty" json:"hasLocalVersionEdits,omitempty"`

	//
	// The negotiation status of the {@link Proposal}.
	// This attribute is read-only.
	//
	NegotiationStatus *NegotiationStatus `xml:"negotiationStatus,omitempty" json:"negotiationStatus,omitempty"`

	//
	// The comment on the {@link Proposal} to be sent to the buyer.
	//
	MarketplaceComment string `xml:"marketplaceComment,omitempty" json:"marketplaceComment,omitempty"`

	//
	// Indicates that the buyer has made updates to the proposal on Marketplace. This attribute is
	// only meaningful if the proposal is open for edit (i.e., {@link #hasLocalVersionEdits} is {@code
	// true})
	// This attribute is read-only.
	//
	IsNewVersionFromBuyer bool `xml:"isNewVersionFromBuyer,omitempty" json:"isNewVersionFromBuyer,omitempty"`

	//
	// The Authorized Buyers ID of the buyer that this {@code Proposal} is being negotiated with.
	// <span class="constraint Required">This attribute is required.</span>
	//
	BuyerAccountId int64 `xml:"buyerAccountId,omitempty" json:"buyerAccountId,omitempty"`

	//
	// The ID used to represent Display & Video 360 client buyer partner ID (if Display & Video 360)
	// or Authorized Buyers client buyer account ID. This field is readonly and assigned by Google.
	// This attribute is read-only.
	//
	PartnerClientId string `xml:"partnerClientId,omitempty" json:"partnerClientId,omitempty"`
}

type MobileApplicationTargeting struct {

	//
	// The {@link MobileApplication#applicationId IDs} that are being targeted or excluded by the
	// {@link LineItem}.
	//
	MobileApplicationIds []int64 `xml:"mobileApplicationIds,omitempty" json:"mobileApplicationIds,omitempty"`

	//
	// Indicates whether mobile apps should be targeted or excluded. This attribute is optional and
	// defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`
}

type MobileCarrier struct {
	*Technology
}

type MobileCarrierTargeting struct {

	//
	// Indicates whether mobile carriers should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Mobile carriers that are being targeted or excluded by the {@link LineItem}.
	//
	MobileCarriers []*Technology `xml:"mobileCarriers,omitempty" json:"mobileCarriers,omitempty"`
}

type MobileDevice struct {
	*Technology

	//
	// Manufacturer Id.
	//
	ManufacturerCriterionId int64 `xml:"manufacturerCriterionId,omitempty" json:"manufacturerCriterionId,omitempty"`
}

type MobileDeviceSubmodel struct {
	*Technology

	//
	// The mobile device id.
	//
	MobileDeviceCriterionId int64 `xml:"mobileDeviceCriterionId,omitempty" json:"mobileDeviceCriterionId,omitempty"`

	//
	// The device manufacturer id.
	//
	DeviceManufacturerCriterionId int64 `xml:"deviceManufacturerCriterionId,omitempty" json:"deviceManufacturerCriterionId,omitempty"`
}

type MobileDeviceSubmodelTargeting struct {

	//
	// Mobile device submodels that are being targeted by the {@link LineItem}.
	//
	TargetedMobileDeviceSubmodels []*Technology `xml:"targetedMobileDeviceSubmodels,omitempty" json:"targetedMobileDeviceSubmodels,omitempty"`

	//
	// Mobile device submodels that are being excluded by the {@link LineItem}.
	//
	ExcludedMobileDeviceSubmodels []*Technology `xml:"excludedMobileDeviceSubmodels,omitempty" json:"excludedMobileDeviceSubmodels,omitempty"`
}

type MobileDeviceTargeting struct {

	//
	// Mobile devices that are being targeted by the {@link LineItem}.
	//
	TargetedMobileDevices []*Technology `xml:"targetedMobileDevices,omitempty" json:"targetedMobileDevices,omitempty"`

	//
	// Mobile devices that are being excluded by the {@link LineItem}.
	//
	ExcludedMobileDevices []*Technology `xml:"excludedMobileDevices,omitempty" json:"excludedMobileDevices,omitempty"`
}

type Money struct {

	//
	// Three letter currency code in string format.
	//
	CurrencyCode string `xml:"currencyCode,omitempty" json:"currencyCode,omitempty"`

	//
	// Money values are always specified in terms of micros which are a millionth
	// of the fundamental currency unit. For US dollars, $1 is 1,000,000 micros.
	//
	MicroAmount int64 `xml:"microAmount,omitempty" json:"microAmount,omitempty"`
}

type NotNullError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *NotNullError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type NullError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *NullError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type NumberValue struct {
	*_Value

	//
	// The numeric value represented as a string.
	//
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

type OperatingSystem struct {
	*Technology
}

type OperatingSystemTargeting struct {

	//
	// Indicates whether operating systems should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Operating systems that are being targeted or excluded by the {@link LineItem}.
	//
	OperatingSystems []*Technology `xml:"operatingSystems,omitempty" json:"operatingSystems,omitempty"`
}

type OperatingSystemVersion struct {
	*Technology

	//
	// The operating system major version.
	//
	MajorVersion int32 `xml:"majorVersion,omitempty" json:"majorVersion,omitempty"`

	//
	// The operating system minor version.
	//
	MinorVersion int32 `xml:"minorVersion,omitempty" json:"minorVersion,omitempty"`

	//
	// The operating system micro version.
	//
	MicroVersion int32 `xml:"microVersion,omitempty" json:"microVersion,omitempty"`
}

type OperatingSystemVersionTargeting struct {

	//
	// Operating system versions that are being targeted by the {@link LineItem}.
	//
	TargetedOperatingSystemVersions []*Technology `xml:"targetedOperatingSystemVersions,omitempty" json:"targetedOperatingSystemVersions,omitempty"`

	//
	// Operating system versions that are being excluded by the {@link LineItem}.
	//
	ExcludedOperatingSystemVersions []*Technology `xml:"excludedOperatingSystemVersions,omitempty" json:"excludedOperatingSystemVersions,omitempty"`
}

type ParseError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ParseError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PauseProposals struct {
	*ProposalAction

	//
	// Reason to describe why the {@link Proposal} is being paused.
	//
	Reason string `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PermissionError struct {
	*ApiError

	Reason *PermissionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PrecisionError struct {
	*ApiError

	Reason *PrecisionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProgrammaticError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProgrammaticError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalAction struct {
}

type ProposalActionError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProposalActionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalCompanyAssociation struct {

	//
	// The unique ID of the {@link Company} associated with the {@link Proposal}.
	// <span class="constraint Required">This attribute is required.</span>
	//
	CompanyId int64 `xml:"companyId,omitempty" json:"companyId,omitempty"`

	//
	// The association type of the {@link Company} and {@link Proposal}.
	// <span class="constraint Required">This attribute is required.</span>
	//
	Type_ *ProposalCompanyAssociationType `xml:"type,omitempty" json:"type,omitempty"`

	//
	// List of unique IDs for {@link Contact} objects of the {@link Company}.
	//
	ContactIds []int64 `xml:"contactIds,omitempty" json:"contactIds,omitempty"`
}

type Proposal struct {

	//
	// The unique ID of the {@code Proposal}.
	// This attribute is read-only.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// Flag that specifies whether this {@code Proposal} is for programmatic deals. This value is
	// default to {@code false}.
	//
	IsProgrammatic bool `xml:"isProgrammatic,omitempty" json:"isProgrammatic,omitempty"`

	//
	// The unique ID of corresponding {@link Order}. This will be {@code null} if the {@code Proposal}
	// has not been pushed to Ad Manager.
	// This attribute is read-only.
	//
	DfpOrderId int64 `xml:"dfpOrderId,omitempty" json:"dfpOrderId,omitempty"`

	//
	// The name of the {@code Proposal}. This value has a maximum length of 255 characters. This value
	// is copied to {@link Order#name} when the proposal turns into an order. This attribute can be
	// configured as editable after the proposal has been submitted. Please check with your network
	// administrator for editable fields configuration.
	// <span class="constraint Required">This attribute is required.</span>
	//
	Name string `xml:"name,omitempty" json:"name,omitempty"`

	//
	// The date and time at which the order and line items associated with the {@code Proposal} are
	// eligible to begin serving. This attribute is derived from the proposal line item of the
	// proposal which has the earliest {@link ProposalLineItem#startDateTime}. This attribute will be
	// null, if this proposal has no related line items, or none of its line items have a start time.
	// This attribute is read-only.
	//
	StartDateTime soap.XSDDateTime `xml:"startDateTime,omitempty" json:"startDateTime,omitempty"`

	//
	// The date and time at which the order and line items associated with the {@code Proposal} stop
	// being served. This attribute is derived from the proposal line item of the proposal which has
	// the latest {@link ProposalLineItem#endDateTime}. This attribute will be null, if this proposal
	// has no related line items, or none of its line items have an end time.
	// This attribute is read-only.
	//
	EndDateTime soap.XSDDateTime `xml:"endDateTime,omitempty" json:"endDateTime,omitempty"`

	//
	// The status of the {@code Proposal}.
	// This attribute is read-only.
	//
	Status *ProposalStatus `xml:"status,omitempty" json:"status,omitempty"`

	//
	// The archival status of the {@code Proposal}.
	// This attribute is read-only.
	//
	IsArchived bool `xml:"isArchived,omitempty" json:"isArchived,omitempty"`

	//
	// The advertiser, to which this {@code Proposal} belongs, and a set of {@link Contact} objects
	// associated with the advertiser. The {@link ProposalCompanyAssociation#type} of this attribute
	// should be {@link ProposalCompanyAssociationType#ADVERTISER}. This attribute is required when
	// the proposal turns into an order, and its {@link ProposalCompanyAssociation#companyId} will be
	// copied to {@link Order#advertiserId}. This attribute becomes readonly once the {@code Proposal}
	// has been pushed.
	//
	Advertiser *ProposalCompanyAssociation `xml:"advertiser,omitempty" json:"advertiser,omitempty"`

	//
	// List of agencies and the set of {@link Contact} objects associated with each agency. This
	// attribute is optional. A {@code Proposal} only has at most one {@link Company} with {@link
	// ProposalCompanyAssociationType#PRIMARY_AGENCY} type, but a {@link Company} can appear more than
	// once with different {@link ProposalCompanyAssociationType} values. If primary agency exists,
	// its {@link ProposalCompanyAssociation#companyId} will be copied to {@link Order#agencyId} when
	// the proposal turns into an order.
	//
	Agencies []*ProposalCompanyAssociation `xml:"agencies,omitempty" json:"agencies,omitempty"`

	//
	// Provides any additional notes that may annotate the {@code Proposal}. This attribute is
	// optional and has a maximum length of 65,535 characters. This attribute can be configured as
	// editable after the proposal has been submitted. Please check with your network administrator
	// for editable fields configuration.
	//
	InternalNotes string `xml:"internalNotes,omitempty" json:"internalNotes,omitempty"`

	//
	// The primary salesperson who brokered the transaction with the {@link #advertiser}. This
	// attribute is required when the proposal turns into an order. This attribute can be configured
	// as editable after the proposal has been submitted. Please check with your network administrator
	// for editable fields configuration.
	//
	PrimarySalesperson *SalespersonSplit `xml:"primarySalesperson,omitempty" json:"primarySalesperson,omitempty"`

	//
	// List of unique IDs of {@link User} objects who are the sales planners of the {@code Proposal}.
	// This attribute is optional. A proposal could have 8 sales planners at most. This attribute can
	// be configured as editable after the proposal has been submitted. Please check with your network
	// administrator for editable fields configuration.
	//
	SalesPlannerIds []int64 `xml:"salesPlannerIds,omitempty" json:"salesPlannerIds,omitempty"`

	//
	// The unique ID of the {@link User} who is primary trafficker and is responsible for trafficking
	// the {@code Proposal}. This attribute is required when the proposal turns into an order, and
	// will be copied to {@link Order#primaryTraffickerId} . This attribute can be configured as
	// editable after the proposal has been submitted. Please check with your network administrator
	// for editable fields configuration.
	//
	PrimaryTraffickerId int64 `xml:"primaryTraffickerId,omitempty" json:"primaryTraffickerId,omitempty"`

	//
	// {@link User users} who are the seller's contacts.
	//
	SellerContactIds []int64 `xml:"sellerContactIds,omitempty" json:"sellerContactIds,omitempty"`

	//
	// The IDs of all teams that the {@code Proposal} is on directly. This attribute is optional. This
	// attribute can be configured as editable after the proposal has been submitted. Please check
	// with your network administrator for editable fields configuration.
	//
	AppliedTeamIds []int64 `xml:"appliedTeamIds,omitempty" json:"appliedTeamIds,omitempty"`

	//
	// The values of the custom fields associated with the {@code Proposal}. This attribute is
	// optional. This attribute can be configured as editable after the proposal has been submitted.
	// Please check with your network administrator for editable fields configuration.
	//
	CustomFieldValues []*BaseCustomFieldValue `xml:"customFieldValues,omitempty" json:"customFieldValues,omitempty"`

	//
	// The set of labels applied directly to the {@code Proposal}. This attribute is optional.
	//
	AppliedLabels []*AppliedLabel `xml:"appliedLabels,omitempty" json:"appliedLabels,omitempty"`

	//
	// Contains the set of labels applied directly to the proposal as well as those inherited ones. If
	// a label has been negated, only the negated label is returned.
	// This attribute is read-only.
	//
	EffectiveAppliedLabels []*AppliedLabel `xml:"effectiveAppliedLabels,omitempty" json:"effectiveAppliedLabels,omitempty"`

	//
	// The currency code of this {@code Proposal}. This attribute is optional and defaults to
	// network's currency code.
	//
	CurrencyCode string `xml:"currencyCode,omitempty" json:"currencyCode,omitempty"`

	//
	// Indicates whether the proposal has been sold, i.e., corresponds to whether the status of an
	// {@link Order} is {@link OrderStatus#APPROVED} or {@link OrderStatus#PAUSED}.
	// This attribute is read-only.
	//
	IsSold bool `xml:"isSold,omitempty" json:"isSold,omitempty"`

	//
	// The date and time this {@code Proposal} was last modified.
	// This attribute is read-only.
	//
	LastModifiedDateTime soap.XSDDateTime `xml:"lastModifiedDateTime,omitempty" json:"lastModifiedDateTime,omitempty"`

	//
	// The marketplace info of this proposal if it has a corresponding order in Marketplace.
	//
	MarketplaceInfo *ProposalMarketplaceInfo `xml:"marketplaceInfo,omitempty" json:"marketplaceInfo,omitempty"`

	//
	// The buyer RFP associated with this {@code Proposal}, which is optional. This field will be null
	// if the proposal is not initiated from RFP.
	//
	BuyerRfp *BuyerRfp `xml:"buyerRfp,omitempty" json:"buyerRfp,omitempty"`

	//
	// Whether a {@link Proposal} contains a {@link BuyerRfp} field. If this field is true, it
	// indicates that the {@link Proposal} in question orignated from a buyer.
	//
	HasBuyerRfp bool `xml:"hasBuyerRfp,omitempty" json:"hasBuyerRfp,omitempty"`

	//
	// Whether pausing is consented for the {@code Proposal}. This field is optional and defaults to
	// true. If false, it indicates that the buyer and the seller agree that the proposal should not
	// be paused.
	//
	DeliveryPausingEnabled bool `xml:"deliveryPausingEnabled,omitempty" json:"deliveryPausingEnabled,omitempty"`
}

type ProposalError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProposalError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalLineItemError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProposalLineItemError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalLineItemMakegoodError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProposalLineItemMakegoodError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalLineItemProgrammaticError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ProposalLineItemProgrammaticError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ProposalPage struct {

	//
	// The size of the total result set to which this page belongs.
	//
	TotalResultSetSize int32 `xml:"totalResultSetSize,omitempty" json:"totalResultSetSize,omitempty"`

	//
	// The absolute index in the total result set on which this page begins.
	//
	StartIndex int32 `xml:"startIndex,omitempty" json:"startIndex,omitempty"`

	//
	// The collection of proposals contained within this page.
	//
	Results []*Proposal `xml:"results,omitempty" json:"results,omitempty"`
}

type PublisherQueryLanguageContextError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PublisherQueryLanguageContextError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PublisherQueryLanguageSyntaxError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PublisherQueryLanguageSyntaxError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type QuotaError struct {
	*ApiError

	Reason *QuotaError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RangeError struct {
	*ApiError

	Reason *RangeError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequestBuyerAcceptance struct {
	*ProposalAction

	AllowOverbook bool `xml:"allowOverbook,omitempty" json:"allowOverbook,omitempty"`
}

type RequestBuyerReview struct {
	*ProposalAction
}

type RequestPlatformTargeting struct {
	TargetedRequestPlatforms []*RequestPlatform `xml:"targetedRequestPlatforms,omitempty" json:"targetedRequestPlatforms,omitempty"`
}

type RequiredCollectionError struct {
	*ApiError

	Reason *RequiredCollectionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequiredError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *RequiredError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequiredNumberError struct {
	*ApiError

	Reason *RequiredNumberError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ReserveProposals struct {
	*ProposalAction

	AllowOverbook bool `xml:"allowOverbook,omitempty" json:"allowOverbook,omitempty"`
}

type ResumeProposals struct {
	*ProposalAction
}

type SalespersonSplit struct {

	//
	// The unique ID of the {@link User} responsible for the sales of the {@link Proposal}.
	// <span class="constraint Required">This attribute is required.</span>
	//
	UserId int64 `xml:"userId,omitempty" json:"userId,omitempty"`
}

type AudienceSegmentError struct {
	*ApiError

	Reason *AudienceSegmentError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ServerError struct {
	*ApiError

	Reason *ServerError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type SetValue struct {
	*_Value

	//
	// The values. They must all be the same type of {@code Value} and not contain duplicates.
	//
	Values []*_Value `xml:"values,omitempty" json:"values,omitempty"`
}

type Size struct {

	//
	// The width of the {@link AdUnit}, {@link LineItem} or {@link Creative}.
	//
	Width int32 `xml:"width,omitempty" json:"width,omitempty"`

	//
	// The height of the {@link AdUnit}, {@link LineItem} or {@link Creative}.
	//
	Height int32 `xml:"height,omitempty" json:"height,omitempty"`

	//
	// Whether this size represents an aspect ratio.
	//
	IsAspectRatio bool `xml:"isAspectRatio,omitempty" json:"isAspectRatio,omitempty"`
}

type SoapRequestHeader struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 RequestHeader"`

	//
	// The network code to use in the context of a request.
	//
	NetworkCode string `xml:"networkCode,omitempty" json:"networkCode,omitempty"`

	//
	// The name of client library application.
	//
	ApplicationName string `xml:"applicationName,omitempty" json:"applicationName,omitempty"`
}

type SoapResponseHeader struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 ResponseHeader"`

	RequestId string `xml:"requestId,omitempty" json:"requestId,omitempty"`

	ResponseTime int64 `xml:"responseTime,omitempty" json:"responseTime,omitempty"`
}

type Statement struct {

	//
	// Holds the query in PQL syntax. The syntax is:<br>
	// <code>[WHERE <condition> {[AND | OR] <condition> ...}]</code><br>
	// <code>[ORDER BY <property> [ASC | DESC]]</code><br>
	// <code>[LIMIT {[<offset>,] <count>} | {<count> OFFSET <offset>}]</code><br>
	// <p>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <value></code><br>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <bind variable></code><br>
	// <code><condition> := <property> IN <list></code><br>
	// <code><condition> := <property> IS NULL</code><br>
	// <code><condition> := <property> LIKE <wildcard%match></code><br>
	// <code><bind variable> := :<name></code><br>
	// </p>
	//
	Query string `xml:"query,omitempty" json:"query,omitempty"`

	//
	// Holds keys and values for bind variables and their values. The key is the
	// name of the bind variable. The value is the literal value of the variable.
	// <p>
	// In the example {@code "WHERE status = :bindStatus ORDER BY id LIMIT 30"},
	// the bind variable, represented by {@code :bindStatus} is named {@code
	// bindStatus}, which would also be the parameter map key. The bind variable's
	// value would be represented by a parameter map value of type
	// {@link TextValue}. The final result, for example, would be an entry of
	// {@code "bindStatus" => StringParam("ACTIVE")}.
	// </p>
	//
	Values []*String_ValueMapEntry `xml:"values,omitempty" json:"values,omitempty"`
}

type StatementError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *StatementError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type StringFormatError struct {
	*ApiError

	Reason *StringFormatError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type StringLengthError struct {
	*ApiError

	Reason *StringLengthError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type String_ValueMapEntry struct {
	Key string `xml:"key,omitempty" json:"key,omitempty"`

	Value *_Value `xml:"value,omitempty" json:"value,omitempty"`
}

type TargetedSize struct {
	Size *Size `xml:"size,omitempty" json:"size,omitempty"`
}

type Targeting struct {

	//
	// Specifies what geographical locations are targeted by the {@link LineItem}. This attribute is
	// optional.
	//
	GeoTargeting *GeoTargeting `xml:"geoTargeting,omitempty" json:"geoTargeting,omitempty"`

	//
	// Specifies what inventory is targeted by the {@link LineItem}. This attribute is required. The
	// line item must target at least one ad unit or placement.
	//
	InventoryTargeting *InventoryTargeting `xml:"inventoryTargeting,omitempty" json:"inventoryTargeting,omitempty"`

	//
	// Specifies the days of the week and times that are targeted by the {@link LineItem}. This
	// attribute is optional.
	//
	DayPartTargeting *DayPartTargeting `xml:"dayPartTargeting,omitempty" json:"dayPartTargeting,omitempty"`

	//
	// Specifies the dates and time ranges that are targeted by the {@link LineItem}. This attribute
	// is optional.
	//
	DateTimeRangeTargeting *DateTimeRangeTargeting `xml:"dateTimeRangeTargeting,omitempty" json:"dateTimeRangeTargeting,omitempty"`

	//
	// Specifies the browsing technologies that are targeted by the {@link LineItem}. This attribute
	// is optional.
	//
	TechnologyTargeting *TechnologyTargeting `xml:"technologyTargeting,omitempty" json:"technologyTargeting,omitempty"`

	//
	// Specifies the collection of custom criteria that is targeted by the {@link LineItem}.
	//
	// <p>Once the {@link LineItem} is updated or modified with custom targeting, the server may
	// return a normalized, but equivalent representation of the custom targeting expression.
	//
	// <p>{@code customTargeting} will have up to three levels of expressions including itself.
	//
	// <p>The top level {@code CustomCriteriaSet} i.e. the {@code customTargeting} object can only
	// contain a {@link CustomCriteriaSet.LogicalOperator#OR} of all its children.
	//
	// <p>The second level of {@code CustomCriteriaSet} objects can only contain {@link
	// CustomCriteriaSet.LogicalOperator#AND} of all their children. If a {@link CustomCriteria} is
	// placed on this level, the server will wrap it in a {@link CustomCriteriaSet}.
	//
	// <p>The third level can only comprise of {@link CustomCriteria} objects.
	//
	// <p>The resulting custom targeting tree would be of the form: <br>
	// <img
	// src="https://chart.apis.google.com/chart?cht=gv&chl=digraph{customTargeting_LogicalOperator_OR-%3ECustomCriteriaSet_LogicalOperator_AND_1-%3ECustomCriteria_1;CustomCriteriaSet_LogicalOperator_AND_1-%3Eellipsis1;customTargeting_LogicalOperator_OR-%3Eellipsis2;ellipsis1[label=%22...%22,shape=none,fontsize=32];ellipsis2[label=%22...%22,shape=none,fontsize=32]}&chs=450x200"/>
	//
	CustomTargeting *CustomCriteriaSet `xml:"customTargeting,omitempty" json:"customTargeting,omitempty"`

	//
	// Specifies the domains or subdomains that are targeted or excluded by the {@link LineItem}.
	// Users visiting from an IP address associated with those domains will be targeted or excluded.
	// This attribute is optional.
	//
	UserDomainTargeting *UserDomainTargeting `xml:"userDomainTargeting,omitempty" json:"userDomainTargeting,omitempty"`

	//
	// Specifies the video categories and individual videos targeted by the {@link LineItem}.
	//
	ContentTargeting *ContentTargeting `xml:"contentTargeting,omitempty" json:"contentTargeting,omitempty"`

	//
	// Specifies targeting against video position types.
	//
	VideoPositionTargeting *VideoPositionTargeting `xml:"videoPositionTargeting,omitempty" json:"videoPositionTargeting,omitempty"`

	//
	// Specifies targeting against mobile applications.
	//
	MobileApplicationTargeting *MobileApplicationTargeting `xml:"mobileApplicationTargeting,omitempty" json:"mobileApplicationTargeting,omitempty"`

	//
	// Specifies whether buyer user lists are targeted on a programmatic {@link LineItem} or {@link
	// ProposalLineItem}. This attribute is readonly and is populated by Google.
	//
	BuyerUserListTargeting *BuyerUserListTargeting `xml:"buyerUserListTargeting,omitempty" json:"buyerUserListTargeting,omitempty"`

	//
	// Specifies the URLs that are targeted by the entity. This is currently only supported by {@link
	// YieldGroup}.
	//
	InventoryUrlTargeting *InventoryUrlTargeting `xml:"inventoryUrlTargeting,omitempty" json:"inventoryUrlTargeting,omitempty"`

	//
	// Specifies the request platforms that are targeted by the {@link LineItem}. This attribute is
	// required for video line items and for {@link ProposalLineItem}.
	//
	// <p>This value is modifiable for video line items, but read-only for non-video line items.
	//
	// <p>This value is read-only for video line items generated from proposal line items.
	//
	RequestPlatformTargeting *RequestPlatformTargeting `xml:"requestPlatformTargeting,omitempty" json:"requestPlatformTargeting,omitempty"`

	//
	// Specifies the sizes that are targeted by the entity. This is currently only supported on {@link
	// YieldGroup} and {@link TrafficDataRequest}.
	//
	InventorySizeTargeting *InventorySizeTargeting `xml:"inventorySizeTargeting,omitempty" json:"inventorySizeTargeting,omitempty"`
}

type TeamError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *TeamError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type Technology struct {

	//
	// The unique ID of the {@code Technology}. This value is required for all forms of {@code
	// TechnologyTargeting}.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// The name of the technology being targeting. This value is read-only and is assigned by Google.
	//
	Name string `xml:"name,omitempty" json:"name,omitempty"`
}

type TerminateNegotiations struct {
	*ProposalAction
}

type TextValue struct {
	*_Value

	//
	// The string value.
	//
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

type TimeOfDay struct {

	//
	// Hour in 24 hour time (0..24). This field must be between 0 and 24,
	// inclusive. This field is required.
	//
	Hour int32 `xml:"hour,omitempty" json:"hour,omitempty"`

	//
	// Minutes in an hour. Currently, only 0, 15, 30, and 45 are supported. This
	// field is required.
	//
	Minute *MinuteOfHour `xml:"minute,omitempty" json:"minute,omitempty"`
}

type TimeZoneError struct {
	*ApiError

	Reason *TimeZoneError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type TypeError struct {
	*ApiError
}

type UnarchiveProposals struct {
	*ProposalAction
}

type UniqueError struct {
	*ApiError
}

type UpdateOrderWithSellerData struct {
	*ProposalAction
}

type UpdateResult struct {

	//
	// The number of objects that were changed as a result of performing the
	// action.
	//
	NumChanges int32 `xml:"numChanges,omitempty" json:"numChanges,omitempty"`
}

type UserDomainTargeting struct {

	//
	// The domains or subdomains that are being targeted or excluded by the {@link LineItem}. This
	// attribute is required and the maximum length of each domain is 67 characters.
	//
	Domains []string `xml:"domains,omitempty" json:"domains,omitempty"`

	//
	// Indicates whether domains should be targeted or excluded. This attribute is optional and
	// defaults to {@code true}.
	//
	Targeted bool `xml:"targeted,omitempty" json:"targeted,omitempty"`
}

type _Value struct {
}

type VideoPosition struct {

	//
	// The type of video position (pre-roll, mid-roll, or post-roll).
	//
	PositionType *VideoPosition_Type `xml:"positionType,omitempty" json:"positionType,omitempty"`

	//
	// The index of the mid-roll to target.  Only valid if the {@link positionType} is
	// {@link VideoPositionType#MIDROLL}, otherwise this field will be ignored.
	//
	MidrollIndex int32 `xml:"midrollIndex,omitempty" json:"midrollIndex,omitempty"`
}

type VideoPositionTargeting struct {

	//
	// The {@link VideoTargetingPosition} objects being targeted by the video {@link LineItem}.
	//
	TargetedPositions []*VideoPositionTarget `xml:"targetedPositions,omitempty" json:"targetedPositions,omitempty"`
}

type VideoPositionWithinPod struct {

	//
	// The specific index of the pod. The index is defined as:
	// <ul><li>1 = first</li>
	// <li>2 = second</li>
	// <li>3 = third</li>
	// <li>....</li>
	// <li>100 = last</li></ul>
	// 100 will always be the last position. For example, for a pod with 5 positions, 100 would
	// target position 5. Multiple targets against the index 100 can exist.<br>
	// Positions over 100 are not supported.
	//
	Index int32 `xml:"index,omitempty" json:"index,omitempty"`
}

type VideoPositionTarget struct {

	//
	// The video position to target.  This attribute is required.
	//
	VideoPosition *VideoPosition `xml:"videoPosition,omitempty" json:"videoPosition,omitempty"`

	//
	// The video bumper type to target. To target a video position or a pod position, this value must
	// be null. To target a bumper position this value must be populated and the line item must have a
	// bumper type. To target a custom ad spot, this value must be null.
	//
	VideoBumperType *VideoBumperType `xml:"videoBumperType,omitempty" json:"videoBumperType,omitempty"`

	//
	// The video position within a pod to target. To target a video position or a bumper position,
	// this value must be null. To target a position within a pod this value must be populated. To
	// target a custom ad spot, this value must be null.
	//
	VideoPositionWithinPod *VideoPositionWithinPod `xml:"videoPositionWithinPod,omitempty" json:"videoPositionWithinPod,omitempty"`

	//
	// A custom spot {@link AdSpot} to target. To target a video position, a bumper type or a video
	// position within a pod this value must be null.
	//
	AdSpotId int64 `xml:"adSpotId,omitempty" json:"adSpotId,omitempty"`
}

type ProposalServiceInterface interface {

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Creates new {@link Proposal} objects.

	   <p>For each proposal, the following fields are required:

	   <ul>
	   <li>{@link Proposal#name}
	   </ul>
	*/
	CreateProposals(request *CreateProposals) (*CreateProposalsResponse, error)

	CreateProposalsContext(ctx context.Context, request *CreateProposals) (*CreateProposalsResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Gets a {@link MarketplaceCommentPage} of {@link MarketplaceComment} objects that satisfy the
	   given {@link Statement#query}. This method only returns comments already sent to Marketplace,
	   local draft {@link ProposalMarketplaceInfo#marketplaceComment} are not included. The following
	   fields are supported for filtering:

	   <table>
	   <tr>
	   <th scope="col">PQL Property</th>
	   <th scope="col">Object Property</th>
	   </tr>
	   <tr>
	   <td>{@code proposalId}</td>
	   <td>{@link MarketplaceComment#proposalId}</td>
	   </tr>
	   </table>

	   The query must specify a {@code proposalId}, and only supports a subset of PQL syntax:<br>
	   <code>[WHERE <condition> {AND <condition> ...}]</code><br>
	   <code>[ORDER BY <property> [ASC | DESC]]</code><br>
	   <code>[LIMIT {[<offset>,] <count>} | {<count> OFFSET <offset>}]</code><br>

	   <p><code><condition></code><br>
	   &nbsp;&nbsp;&nbsp;&nbsp; <code>:= <property> = <value></code><br>
	   <code><condition> := <property> IN <list></code><br>
	   Only supports {@code ORDER BY} {@link MarketplaceComment#creationTime}.
	*/
	GetMarketplaceCommentsByStatement(request *GetMarketplaceCommentsByStatement) (*GetMarketplaceCommentsByStatementResponse, error)

	GetMarketplaceCommentsByStatementContext(ctx context.Context, request *GetMarketplaceCommentsByStatement) (*GetMarketplaceCommentsByStatementResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Gets a {@link ProposalPage} of {@link Proposal} objects that satisfy the given {@link
	   Statement#query}. The following fields are supported for filtering:

	   <table>
	   <tr>
	   <th scope="col">PQL Property</th>
	   <th scope="col">Object Property</th>
	   </tr>
	   <tr>
	   <td>{@code id}</td>
	   <td>{@link Proposal#id}</td>
	   </tr>
	   <tr>
	   <td>{@code dfpOrderId}</td>
	   <td>{@link Proposal#dfpOrderId}</td>
	   </tr>
	   <tr>
	   <td>{@code name}</td>
	   <td>{@link Proposal#name}</td>
	   </tr>
	   <tr>
	   <td>{@code status}</td>
	   <td>{@link Proposal#status}</td>
	   </tr>
	   <tr>
	   <td>{@code isArchived}</td>
	   <td>{@link Proposal#isArchived}</td>
	   </tr>
	   <tr>
	   <td>
	   {@code approvalStatus}
	   <div class="constraint">Only applicable for proposals using sales management</div>
	   </td>
	   <td>{@link Proposal#approvalStatus}</td>
	   </tr>
	   <tr>
	   <td>{@code lastModifiedDateTime}</td>
	   <td>{@link Proposal#lastModifiedDateTime}</td>
	   </tr>
	   <tr>
	   <td>{@code isProgrammatic}</td>
	   <td>{@link Proposal#isProgrammatic}</td>
	   </tr>
	   <tr>
	   <td>
	   {@code negotiationStatus}
	   <div class="constraint">Only applicable for programmatic proposals</div>
	   </td>
	   <td>{@link ProposalMarketplaceInfo#negotiationStatus}</td>
	   </tr>
	   </table>
	*/
	GetProposalsByStatement(request *GetProposalsByStatement) (*GetProposalsByStatementResponse, error)

	GetProposalsByStatementContext(ctx context.Context, request *GetProposalsByStatement) (*GetProposalsByStatementResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Performs actions on {@link Proposal} objects that match the given {@link Statement#query}.

	   <p>The following fields are also required when submitting proposals for approval:

	   <ul>
	   <li>{@link Proposal#advertiser}
	   <li>{@link Proposal#primarySalesperson}
	   <li>{@link Proposal#primaryTraffickerId}
	   </ul>
	*/
	PerformProposalAction(request *PerformProposalAction) (*PerformProposalActionResponse, error)

	PerformProposalActionContext(ctx context.Context, request *PerformProposalAction) (*PerformProposalActionResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Updates the specified {@link Proposal} objects.
	*/
	UpdateProposals(request *UpdateProposals) (*UpdateProposalsResponse, error)

	UpdateProposalsContext(ctx context.Context, request *UpdateProposals) (*UpdateProposalsResponse, error)
}

type proposalServiceInterface struct {
	client *soap.Client
}

func NewProposalServiceInterface(client *soap.Client) ProposalServiceInterface {
	return &proposalServiceInterface{
		client: client,
	}
}

func (service *proposalServiceInterface) CreateProposalsContext(ctx context.Context, request *CreateProposals) (*CreateProposalsResponse, error) {
	response := new(CreateProposalsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *proposalServiceInterface) CreateProposals(request *CreateProposals) (*CreateProposalsResponse, error) {
	return service.CreateProposalsContext(
		context.Background(),
		request,
	)
}

func (service *proposalServiceInterface) GetMarketplaceCommentsByStatementContext(ctx context.Context, request *GetMarketplaceCommentsByStatement) (*GetMarketplaceCommentsByStatementResponse, error) {
	response := new(GetMarketplaceCommentsByStatementResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *proposalServiceInterface) GetMarketplaceCommentsByStatement(request *GetMarketplaceCommentsByStatement) (*GetMarketplaceCommentsByStatementResponse, error) {
	return service.GetMarketplaceCommentsByStatementContext(
		context.Background(),
		request,
	)
}

func (service *proposalServiceInterface) GetProposalsByStatementContext(ctx context.Context, request *GetProposalsByStatement) (*GetProposalsByStatementResponse, error) {
	response := new(GetProposalsByStatementResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *proposalServiceInterface) GetProposalsByStatement(request *GetProposalsByStatement) (*GetProposalsByStatementResponse, error) {
	return service.GetProposalsByStatementContext(
		context.Background(),
		request,
	)
}

func (service *proposalServiceInterface) PerformProposalActionContext(ctx context.Context, request *PerformProposalAction) (*PerformProposalActionResponse, error) {
	response := new(PerformProposalActionResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *proposalServiceInterface) PerformProposalAction(request *PerformProposalAction) (*PerformProposalActionResponse, error) {
	return service.PerformProposalActionContext(
		context.Background(),
		request,
	)
}

func (service *proposalServiceInterface) UpdateProposalsContext(ctx context.Context, request *UpdateProposals) (*UpdateProposalsResponse, error) {
	response := new(UpdateProposalsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *proposalServiceInterface) UpdateProposals(request *UpdateProposals) (*UpdateProposalsResponse, error) {
	return service.UpdateProposalsContext(
		context.Background(),
		request,
	)
}
