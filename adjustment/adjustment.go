// Code generated by gowsdl DO NOT EDIT.

package adjustment

import (
	"context"
	"encoding/xml"
	"github.com/hooklift/gowsdl/soap"
	"time"
)

// against "unused imports"
var _ time.Time
var _ xml.Name

type AnyType struct {
	InnerXML string `xml:",innerxml"`
}

type AnyURI string

type NCName string

type ApiVersionError_Reason string

const (

	//
	// Indicates that the operation is not allowed in the version the request
	// was made in.
	//
	ApiVersionError_ReasonUPDATE_TO_NEWER_VERSION ApiVersionError_Reason = "UPDATE_TO_NEWER_VERSION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ApiVersionError_ReasonUNKNOWN ApiVersionError_Reason = "UNKNOWN"
)

type AuthenticationError_Reason string

const (

	//
	// The SOAP message contains a request header with an ambiguous definition of the authentication
	// header fields. This means either the {@code authToken} and {@code oAuthToken} fields were
	// both null or both were specified. Exactly one value should be specified with each request.
	//
	AuthenticationError_ReasonAMBIGUOUS_SOAP_REQUEST_HEADER AuthenticationError_Reason = "AMBIGUOUS_SOAP_REQUEST_HEADER"

	//
	// The login provided is invalid.
	//
	AuthenticationError_ReasonINVALID_EMAIL AuthenticationError_Reason = "INVALID_EMAIL"

	//
	// Tried to authenticate with provided information, but failed.
	//
	AuthenticationError_ReasonAUTHENTICATION_FAILED AuthenticationError_Reason = "AUTHENTICATION_FAILED"

	//
	// The OAuth provided is invalid.
	//
	AuthenticationError_ReasonINVALID_OAUTH_SIGNATURE AuthenticationError_Reason = "INVALID_OAUTH_SIGNATURE"

	//
	// The specified service to use was not recognized.
	//
	AuthenticationError_ReasonINVALID_SERVICE AuthenticationError_Reason = "INVALID_SERVICE"

	//
	// The SOAP message is missing a request header with an {@code authToken} and optional {@code
	// networkCode}.
	//
	AuthenticationError_ReasonMISSING_SOAP_REQUEST_HEADER AuthenticationError_Reason = "MISSING_SOAP_REQUEST_HEADER"

	//
	// The HTTP request is missing a request header with an {@code authToken}
	//
	AuthenticationError_ReasonMISSING_AUTHENTICATION_HTTP_HEADER AuthenticationError_Reason = "MISSING_AUTHENTICATION_HTTP_HEADER"

	//
	// The request is missing an {@code authToken}
	//
	AuthenticationError_ReasonMISSING_AUTHENTICATION AuthenticationError_Reason = "MISSING_AUTHENTICATION"

	//
	// The network does not have API access enabled.
	//
	AuthenticationError_ReasonNETWORK_API_ACCESS_DISABLED AuthenticationError_Reason = "NETWORK_API_ACCESS_DISABLED"

	//
	// The user is not associated with any network.
	//
	AuthenticationError_ReasonNO_NETWORKS_TO_ACCESS AuthenticationError_Reason = "NO_NETWORKS_TO_ACCESS"

	//
	// No network for the given {@code networkCode} was found.
	//
	AuthenticationError_ReasonNETWORK_NOT_FOUND AuthenticationError_Reason = "NETWORK_NOT_FOUND"

	//
	// The user has access to more than one network, but did not provide a {@code networkCode}.
	//
	AuthenticationError_ReasonNETWORK_CODE_REQUIRED AuthenticationError_Reason = "NETWORK_CODE_REQUIRED"

	//
	// An error happened on the server side during connection to authentication service.
	//
	AuthenticationError_ReasonCONNECTION_ERROR AuthenticationError_Reason = "CONNECTION_ERROR"

	//
	// The user tried to create a test network using an account that already is associated with a
	// network.
	//
	AuthenticationError_ReasonGOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK AuthenticationError_Reason = "GOOGLE_ACCOUNT_ALREADY_ASSOCIATED_WITH_NETWORK"

	//
	// The account is blocked and under investigation by the collections team. Please contact Google
	// for more information.
	//
	AuthenticationError_ReasonUNDER_INVESTIGATION AuthenticationError_Reason = "UNDER_INVESTIGATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	AuthenticationError_ReasonUNKNOWN AuthenticationError_Reason = "UNKNOWN"
)

type CollectionSizeError_Reason string

const (
	CollectionSizeError_ReasonTOO_LARGE CollectionSizeError_Reason = "TOO_LARGE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CollectionSizeError_ReasonUNKNOWN CollectionSizeError_Reason = "UNKNOWN"
)

//
// Describes reasons for common errors
//

type CommonError_Reason string

const (

	//
	// Indicates that an attempt was made to retrieve an entity that does not
	// exist.
	//
	CommonError_ReasonNOT_FOUND CommonError_Reason = "NOT_FOUND"

	//
	// Indicates that an attempt was made to create an entity that already
	// exists.
	//
	CommonError_ReasonALREADY_EXISTS CommonError_Reason = "ALREADY_EXISTS"

	//
	// Indicates that a value is not applicable for given use case.
	//
	CommonError_ReasonNOT_APPLICABLE CommonError_Reason = "NOT_APPLICABLE"

	//
	// Indicates that two elements in the collection were identical.
	//
	CommonError_ReasonDUPLICATE_OBJECT CommonError_Reason = "DUPLICATE_OBJECT"

	//
	// Indicates that an attempt was made to change an immutable field.
	//
	CommonError_ReasonCANNOT_UPDATE CommonError_Reason = "CANNOT_UPDATE"

	//
	// Indicates that the requested operation is not supported.
	//
	CommonError_ReasonUNSUPPORTED_OPERATION CommonError_Reason = "UNSUPPORTED_OPERATION"

	//
	// Indicates that another request attempted to update the same data in the same network
	// at about the same time. Please wait and try the request again.
	//
	CommonError_ReasonCONCURRENT_MODIFICATION CommonError_Reason = "CONCURRENT_MODIFICATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CommonError_ReasonUNKNOWN CommonError_Reason = "UNKNOWN"
)

//
// Specifies the available comparison operators.
//

type CustomCriteria_ComparisonOperator string

const (
	CustomCriteria_ComparisonOperatorIS CustomCriteria_ComparisonOperator = "IS"

	CustomCriteria_ComparisonOperatorIS_NOT CustomCriteria_ComparisonOperator = "IS_NOT"
)

//
// Specifies the available logical operators.
//

type CustomCriteriaSet_LogicalOperator string

const (
	CustomCriteriaSet_LogicalOperatorAND CustomCriteriaSet_LogicalOperator = "AND"

	CustomCriteriaSet_LogicalOperatorOR CustomCriteriaSet_LogicalOperator = "OR"
)

//
// Specifies the available comparison operators.
//

type CmsMetadataCriteria_ComparisonOperator string

const (
	CmsMetadataCriteria_ComparisonOperatorEQUALS CmsMetadataCriteria_ComparisonOperator = "EQUALS"

	CmsMetadataCriteria_ComparisonOperatorNOT_EQUALS CmsMetadataCriteria_ComparisonOperator = "NOT_EQUALS"
)

//
// The reasons for the target error.
//

type CustomTargetingError_Reason string

const (

	//
	// Requested {@link CustomTargetingKey} is not found.
	//
	CustomTargetingError_ReasonKEY_NOT_FOUND CustomTargetingError_Reason = "KEY_NOT_FOUND"

	//
	// Number of {@link CustomTargetingKey} objects created exceeds the limit
	// allowed for the network.
	//
	CustomTargetingError_ReasonKEY_COUNT_TOO_LARGE CustomTargetingError_Reason = "KEY_COUNT_TOO_LARGE"

	//
	// {@link CustomTargetingKey} with the same {@link CustomTargetingKey#name}
	// already exists.
	//
	CustomTargetingError_ReasonKEY_NAME_DUPLICATE CustomTargetingError_Reason = "KEY_NAME_DUPLICATE"

	//
	// {@link CustomTargetingKey#name} is empty.
	//
	CustomTargetingError_ReasonKEY_NAME_EMPTY CustomTargetingError_Reason = "KEY_NAME_EMPTY"

	//
	// {@link CustomTargetingKey#name} is too long.
	//
	CustomTargetingError_ReasonKEY_NAME_INVALID_LENGTH CustomTargetingError_Reason = "KEY_NAME_INVALID_LENGTH"

	//
	// {@link CustomTargetingKey#name} contains unsupported or reserved
	// characters.
	//
	CustomTargetingError_ReasonKEY_NAME_INVALID_CHARS CustomTargetingError_Reason = "KEY_NAME_INVALID_CHARS"

	//
	// {@link CustomTargetingKey#name} matches one of the reserved custom
	// targeting key names.
	//
	CustomTargetingError_ReasonKEY_NAME_RESERVED CustomTargetingError_Reason = "KEY_NAME_RESERVED"

	//
	// {@link CustomTargetingKey#displayName} is too long.
	//
	CustomTargetingError_ReasonKEY_DISPLAY_NAME_INVALID_LENGTH CustomTargetingError_Reason = "KEY_DISPLAY_NAME_INVALID_LENGTH"

	//
	// Key is not active.
	//
	CustomTargetingError_ReasonKEY_STATUS_NOT_ACTIVE CustomTargetingError_Reason = "KEY_STATUS_NOT_ACTIVE"

	//
	// Requested {@link CustomTargetingValue} is not found.
	//
	CustomTargetingError_ReasonVALUE_NOT_FOUND CustomTargetingError_Reason = "VALUE_NOT_FOUND"

	//
	// The {@code WHERE} clause in the {@link Statement#query} must always
	// contain {@link CustomTargetingValue#customTargetingKeyId} as one of its
	// columns in a way that it is AND'ed with the rest of the query.
	//
	CustomTargetingError_ReasonGET_VALUES_BY_STATEMENT_MUST_CONTAIN_KEY_ID CustomTargetingError_Reason = "GET_VALUES_BY_STATEMENT_MUST_CONTAIN_KEY_ID"

	//
	// The number of {@link CustomTargetingValue} objects associated with a
	// {@link CustomTargetingKey} exceeds the network limit. This is only
	// applicable for keys of type {@code CustomTargetingKey.Type#PREDEFINED}.
	//
	CustomTargetingError_ReasonVALUE_COUNT_FOR_KEY_TOO_LARGE CustomTargetingError_Reason = "VALUE_COUNT_FOR_KEY_TOO_LARGE"

	//
	// {@link CustomTargetingValue} with the same
	// {@link CustomTargetingValue#name} already exists.
	//
	CustomTargetingError_ReasonVALUE_NAME_DUPLICATE CustomTargetingError_Reason = "VALUE_NAME_DUPLICATE"

	//
	// {@link CustomTargetingValue#name} is empty.
	//
	CustomTargetingError_ReasonVALUE_NAME_EMPTY CustomTargetingError_Reason = "VALUE_NAME_EMPTY"

	//
	// {@link CustomTargetingValue#name} is too long.
	//
	CustomTargetingError_ReasonVALUE_NAME_INVALID_LENGTH CustomTargetingError_Reason = "VALUE_NAME_INVALID_LENGTH"

	//
	// {@link CustomTargetingValue#name} contains unsupported or reserved
	// characters.
	//
	CustomTargetingError_ReasonVALUE_NAME_INVALID_CHARS CustomTargetingError_Reason = "VALUE_NAME_INVALID_CHARS"

	//
	// {@link CustomTargetingValue#displayName} is too long.
	//
	CustomTargetingError_ReasonVALUE_DISPLAY_NAME_INVALID_LENGTH CustomTargetingError_Reason = "VALUE_DISPLAY_NAME_INVALID_LENGTH"

	//
	// Only Ad Manager 360 networks can have {@link CustomTargetingValue#matchType}
	// other than {@link CustomTargetingValue.MatchType#EXACT}.
	//
	CustomTargetingError_ReasonVALUE_MATCH_TYPE_NOT_ALLOWED CustomTargetingError_Reason = "VALUE_MATCH_TYPE_NOT_ALLOWED"

	//
	// You can only create {@link CustomTargetingValue} objects with match type
	// {@link CustomTargetingValue.MatchType#EXACT} when associating
	// with {@link CustomTargetingKey} objects of type
	// {@link CustomTargetingKey.Type#PREDEFINED}
	//
	CustomTargetingError_ReasonVALUE_MATCH_TYPE_NOT_EXACT_FOR_PREDEFINED_KEY CustomTargetingError_Reason = "VALUE_MATCH_TYPE_NOT_EXACT_FOR_PREDEFINED_KEY"

	//
	// {@link CustomTargetingValue} object cannot have match type of
	// {@link CustomTargetingValue.MatchType#SUFFIX} when adding a
	// {@link CustomTargetingValue} to a line item.
	//
	CustomTargetingError_ReasonSUFFIX_MATCH_TYPE_NOT_ALLOWED CustomTargetingError_Reason = "SUFFIX_MATCH_TYPE_NOT_ALLOWED"

	//
	// {@link CustomTargetingValue} object cannot have match type of
	// {@link CustomTargetingValue.MatchType#CONTAINS} when adding a
	// {@link CustomTargetingValue} to targeting expression of a line item.
	//
	CustomTargetingError_ReasonCONTAINS_MATCH_TYPE_NOT_ALLOWED CustomTargetingError_Reason = "CONTAINS_MATCH_TYPE_NOT_ALLOWED"

	//
	// Value is not active.
	//
	CustomTargetingError_ReasonVALUE_STATUS_NOT_ACTIVE CustomTargetingError_Reason = "VALUE_STATUS_NOT_ACTIVE"

	//
	// The {@link CustomTargetingKey} does not have any
	// {@link CustomTargetingValue} associated with it.
	//
	CustomTargetingError_ReasonKEY_WITH_MISSING_VALUES CustomTargetingError_Reason = "KEY_WITH_MISSING_VALUES"

	//
	// The {@link CustomTargetingKey} has a {@link CustomTargetingValue} specified for which the
	// value is not a valid child.
	//
	CustomTargetingError_ReasonINVALID_VALUE_FOR_KEY CustomTargetingError_Reason = "INVALID_VALUE_FOR_KEY"

	//
	// {@link CustomCriteriaSet.LogicalOperator#OR} operation cannot be applied
	// to values with different keys.
	//
	CustomTargetingError_ReasonCANNOT_OR_DIFFERENT_KEYS CustomTargetingError_Reason = "CANNOT_OR_DIFFERENT_KEYS"

	//
	// Targeting expression is invalid. This can happen if the sequence of
	// operators is wrong, or a node contains invalid number of children.
	//
	CustomTargetingError_ReasonINVALID_TARGETING_EXPRESSION CustomTargetingError_Reason = "INVALID_TARGETING_EXPRESSION"

	//
	// The key has been deleted. {@link CustomCriteria} cannot have deleted
	// keys.
	//
	CustomTargetingError_ReasonDELETED_KEY_CANNOT_BE_USED_FOR_TARGETING CustomTargetingError_Reason = "DELETED_KEY_CANNOT_BE_USED_FOR_TARGETING"

	//
	// The value has been deleted. {@link CustomCriteria} cannot have deleted
	// values.
	//
	CustomTargetingError_ReasonDELETED_VALUE_CANNOT_BE_USED_FOR_TARGETING CustomTargetingError_Reason = "DELETED_VALUE_CANNOT_BE_USED_FOR_TARGETING"

	//
	// The key is set as the video browse-by key, which cannot be used for
	// custom targeting.
	//
	CustomTargetingError_ReasonVIDEO_BROWSE_BY_KEY_CANNOT_BE_USED_FOR_CUSTOM_TARGETING CustomTargetingError_Reason = "VIDEO_BROWSE_BY_KEY_CANNOT_BE_USED_FOR_CUSTOM_TARGETING"

	//
	// Only active custom-criteria keys are supported in content metadata mapping.
	//
	CustomTargetingError_ReasonCANNOT_DELETE_CUSTOM_KEY_USED_IN_CONTENT_METADATA_MAPPING CustomTargetingError_Reason = "CANNOT_DELETE_CUSTOM_KEY_USED_IN_CONTENT_METADATA_MAPPING"

	//
	// Only active custom-criteria values are supported in content metadata mapping.
	//
	CustomTargetingError_ReasonCANNOT_DELETE_CUSTOM_VALUE_USED_IN_CONTENT_METADATA_MAPPING CustomTargetingError_Reason = "CANNOT_DELETE_CUSTOM_VALUE_USED_IN_CONTENT_METADATA_MAPPING"

	//
	// Cannot delete a custom criteria key that is targeted by an active partner assignment.
	//
	CustomTargetingError_ReasonCANNOT_DELETE_CUSTOM_KEY_USED_IN_PARTNER_ASSIGNMENT_TARGETING CustomTargetingError_Reason = "CANNOT_DELETE_CUSTOM_KEY_USED_IN_PARTNER_ASSIGNMENT_TARGETING"

	//
	// Cannot delete a custom criteria value that is targeted by an active partner assignment.
	//
	CustomTargetingError_ReasonCANNOT_DELETE_CUSTOM_VALUE_USED_IN_PARTNER_ASSIGNMENT_TARGETING CustomTargetingError_Reason = "CANNOT_DELETE_CUSTOM_VALUE_USED_IN_PARTNER_ASSIGNMENT_TARGETING"

	//
	// {@link AudienceSegment} object cannot be targeted.
	//
	CustomTargetingError_ReasonCANNOT_TARGET_AUDIENCE_SEGMENT CustomTargetingError_Reason = "CANNOT_TARGET_AUDIENCE_SEGMENT"

	//
	// Third party {@link AudienceSegment} cannot be targeted.
	//
	CustomTargetingError_ReasonCANNOT_TARGET_THIRD_PARTY_AUDIENCE_SEGMENT CustomTargetingError_Reason = "CANNOT_TARGET_THIRD_PARTY_AUDIENCE_SEGMENT"

	//
	// Inactive {@link AudienceSegment} object cannot be targeted.
	//
	CustomTargetingError_ReasonCANNOT_TARGET_INACTIVE_AUDIENCE_SEGMENT CustomTargetingError_Reason = "CANNOT_TARGET_INACTIVE_AUDIENCE_SEGMENT"

	//
	// Targeted {@link AudienceSegment} object is not valid.
	//
	CustomTargetingError_ReasonINVALID_AUDIENCE_SEGMENTS CustomTargetingError_Reason = "INVALID_AUDIENCE_SEGMENTS"

	//
	// Mapped metadata key-values are deprecated and cannot be targeted.
	//
	CustomTargetingError_ReasonCANNOT_TARGET_MAPPED_METADATA CustomTargetingError_Reason = "CANNOT_TARGET_MAPPED_METADATA"

	//
	// Targeted {@link AudienceSegment} objects have not been approved.
	//
	CustomTargetingError_ReasonONLY_APPROVED_AUDIENCE_SEGMENTS_CAN_BE_TARGETED CustomTargetingError_Reason = "ONLY_APPROVED_AUDIENCE_SEGMENTS_CAN_BE_TARGETED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	CustomTargetingError_ReasonUNKNOWN CustomTargetingError_Reason = "UNKNOWN"
)

//
// Specifies the available comparison operators.
//

type AudienceSegmentCriteria_ComparisonOperator string

const (
	AudienceSegmentCriteria_ComparisonOperatorIS AudienceSegmentCriteria_ComparisonOperator = "IS"

	AudienceSegmentCriteria_ComparisonOperatorIS_NOT AudienceSegmentCriteria_ComparisonOperator = "IS_NOT"
)

//
// Enumerates all possible date specific errors.
//

type DateError_Reason string

const (
	DateError_ReasonDATE_IN_PAST DateError_Reason = "DATE_IN_PAST"

	DateError_ReasonSTART_DATE_AFTER_END_DATE DateError_Reason = "START_DATE_AFTER_END_DATE"

	DateError_ReasonEND_DATE_BEFORE_START_DATE DateError_Reason = "END_DATE_BEFORE_START_DATE"

	DateError_ReasonNOT_CERTAIN_DAY_OF_MONTH DateError_Reason = "NOT_CERTAIN_DAY_OF_MONTH"

	DateError_ReasonINVALID_DATES DateError_Reason = "INVALID_DATES"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DateError_ReasonUNKNOWN DateError_Reason = "UNKNOWN"
)

//
// {@link ApiErrorReason} enum for date time range targeting error.
//

type DateTimeRangeTargetingError_Reason string

const (

	//
	// No targeted ranges exists.
	//
	DateTimeRangeTargetingError_ReasonEMPTY_RANGES DateTimeRangeTargetingError_Reason = "EMPTY_RANGES"

	//
	// Type of lineitem is not sponsorship.
	//
	DateTimeRangeTargetingError_ReasonNOT_SPONSORSHIP_LINEITEM DateTimeRangeTargetingError_Reason = "NOT_SPONSORSHIP_LINEITEM"

	//
	// Type of lineitem is not sponsorship or standard.
	//
	DateTimeRangeTargetingError_ReasonNOT_SPONSORSHIP_OR_STANDARD_LINEITEM DateTimeRangeTargetingError_Reason = "NOT_SPONSORSHIP_OR_STANDARD_LINEITEM"

	//
	// Line item must have a reservation type of sponsorship, standard or preferred deal to use date
	// time range targeting.
	//
	DateTimeRangeTargetingError_ReasonUNSUPPORTED_LINEITEM_RESERVATION_TYPE DateTimeRangeTargetingError_Reason = "UNSUPPORTED_LINEITEM_RESERVATION_TYPE"

	//
	// Past ranges are changed.
	//
	DateTimeRangeTargetingError_ReasonPAST_RANGES_CHANGED DateTimeRangeTargetingError_Reason = "PAST_RANGES_CHANGED"

	//
	// Targeted date time ranges overlap.
	//
	DateTimeRangeTargetingError_ReasonRANGES_OVERLAP DateTimeRangeTargetingError_Reason = "RANGES_OVERLAP"

	//
	// First date time does not match line item's start time.
	//
	DateTimeRangeTargetingError_ReasonFIRST_DATE_TIME_DOES_NOT_MATCH_START_TIME DateTimeRangeTargetingError_Reason = "FIRST_DATE_TIME_DOES_NOT_MATCH_START_TIME"

	//
	// Last date time does not match line item's end time.
	//
	DateTimeRangeTargetingError_ReasonLAST_DATE_TIME_DOES_NOT_MATCH_END_TIME DateTimeRangeTargetingError_Reason = "LAST_DATE_TIME_DOES_NOT_MATCH_END_TIME"

	//
	// Targeted date time ranges fall out the active period of lineitem.
	//
	DateTimeRangeTargetingError_ReasonRANGES_OUT_OF_LINEITEM_ACTIVE_PERIOD DateTimeRangeTargetingError_Reason = "RANGES_OUT_OF_LINEITEM_ACTIVE_PERIOD"

	//
	// Start time of range (except the earliest range) is not at start of day.
	// Start of day is 00:00:00.
	//
	DateTimeRangeTargetingError_ReasonSTART_TIME_IS_NOT_START_OF_DAY DateTimeRangeTargetingError_Reason = "START_TIME_IS_NOT_START_OF_DAY"

	//
	// End time of range (except the latest range) is not at end of day.
	// End of day is 23:59:59.
	//
	DateTimeRangeTargetingError_ReasonEND_TIME_IS_NOT_END_OF_DAY DateTimeRangeTargetingError_Reason = "END_TIME_IS_NOT_END_OF_DAY"

	//
	// Start date time of earliest targeted ranges is in past.
	//
	DateTimeRangeTargetingError_ReasonSTART_DATE_TIME_IS_IN_PAST DateTimeRangeTargetingError_Reason = "START_DATE_TIME_IS_IN_PAST"

	//
	// Cannot modify the start date time for date time targeting to the past.
	//
	DateTimeRangeTargetingError_ReasonMODIFY_START_DATE_TIME_TO_PAST DateTimeRangeTargetingError_Reason = "MODIFY_START_DATE_TIME_TO_PAST"

	//
	// The end time of range is before the start time.
	// Could happen when start type is IMMEDIATE or ONE_HOUR_LATER.
	//
	DateTimeRangeTargetingError_ReasonRANGE_END_TIME_BEFORE_START_TIME DateTimeRangeTargetingError_Reason = "RANGE_END_TIME_BEFORE_START_TIME"

	//
	// End date time of latest targeted ranges is too late.
	//
	DateTimeRangeTargetingError_ReasonEND_DATE_TIME_IS_TOO_LATE DateTimeRangeTargetingError_Reason = "END_DATE_TIME_IS_TOO_LATE"

	DateTimeRangeTargetingError_ReasonLIMITED_RANGES_IN_UNLIMITED_LINEITEM DateTimeRangeTargetingError_Reason = "LIMITED_RANGES_IN_UNLIMITED_LINEITEM"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DateTimeRangeTargetingError_ReasonUNKNOWN DateTimeRangeTargetingError_Reason = "UNKNOWN"
)

//
// Days of the week.
//

type DayOfWeek string

const (

	//
	// The day of week named Monday.
	//
	DayOfWeekMONDAY DayOfWeek = "MONDAY"

	//
	// The day of week named Tuesday.
	//
	DayOfWeekTUESDAY DayOfWeek = "TUESDAY"

	//
	// The day of week named Wednesday.
	//
	DayOfWeekWEDNESDAY DayOfWeek = "WEDNESDAY"

	//
	// The day of week named Thursday.
	//
	DayOfWeekTHURSDAY DayOfWeek = "THURSDAY"

	//
	// The day of week named Friday.
	//
	DayOfWeekFRIDAY DayOfWeek = "FRIDAY"

	//
	// The day of week named Saturday.
	//
	DayOfWeekSATURDAY DayOfWeek = "SATURDAY"

	//
	// The day of week named Sunday.
	//
	DayOfWeekSUNDAY DayOfWeek = "SUNDAY"
)

//
// The reasons for the target error.
//

type DayPartTargetingError_Reason string

const (

	//
	// Hour of day must be between 0 and 24, inclusive.
	//
	DayPartTargetingError_ReasonINVALID_HOUR DayPartTargetingError_Reason = "INVALID_HOUR"

	//
	// Minute of hour must be one of 0, 15,30, 45.
	//
	DayPartTargetingError_ReasonINVALID_MINUTE DayPartTargetingError_Reason = "INVALID_MINUTE"

	//
	// The {@link DayPart#endTime} cannot be after {@link DayPart#startTime}.
	//
	DayPartTargetingError_ReasonEND_TIME_NOT_AFTER_START_TIME DayPartTargetingError_Reason = "END_TIME_NOT_AFTER_START_TIME"

	//
	// Cannot create day-parts that overlap.
	//
	DayPartTargetingError_ReasonTIME_PERIODS_OVERLAP DayPartTargetingError_Reason = "TIME_PERIODS_OVERLAP"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	DayPartTargetingError_ReasonUNKNOWN DayPartTargetingError_Reason = "UNKNOWN"
)

//
// Represents the time zone to be used for {@link DayPartTargeting}.
//

type DeliveryTimeZone string

const (

	//
	// Use the time zone of the publisher.
	//
	DeliveryTimeZonePUBLISHER DeliveryTimeZone = "PUBLISHER"

	//
	// Use the time zone of the browser.
	//
	DeliveryTimeZoneBROWSER DeliveryTimeZone = "BROWSER"
)

//
// The reasons for the entity limit reached error.
//

type EntityLimitReachedError_Reason string

const (

	//
	// The number of custom targeting values exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonCUSTOM_TARGETING_VALUES_LIMIT_REACHED EntityLimitReachedError_Reason = "CUSTOM_TARGETING_VALUES_LIMIT_REACHED"

	//
	// The number of ad exclusion rules exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonAD_EXCLUSION_RULES_LIMIT_REACHED EntityLimitReachedError_Reason = "AD_EXCLUSION_RULES_LIMIT_REACHED"

	//
	// The number of first party audience segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonFIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "FIRST_PARTY_AUDIENCE_SEGMENTS_LIMIT_REACHED"

	//
	// The number of active placements exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonPLACEMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "PLACEMENTS_LIMIT_REACHED"

	//
	// The number of line items excceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonLINE_ITEMS_LIMIT_REACHED EntityLimitReachedError_Reason = "LINE_ITEMS_LIMIT_REACHED"

	//
	// The number of active line items exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonACTIVE_LINE_ITEMS_LIMIT_REACHED EntityLimitReachedError_Reason = "ACTIVE_LINE_ITEMS_LIMIT_REACHED"

	//
	// The number of not-archived encoding profiles exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonDAI_ENCODING_PROFILES_LIMIT_REACHED EntityLimitReachedError_Reason = "DAI_ENCODING_PROFILES_LIMIT_REACHED"

	//
	// The number of traffic forecast segments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonTRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "TRAFFIC_FORECAST_SEGMENTS_LIMIT_REACHED"

	//
	// The number of forecast adjustments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonFORECAST_ADJUSTMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "FORECAST_ADJUSTMENTS_LIMIT_REACHED"

	//
	// The number of active experiments exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonACTIVE_EXPERIMENTS_LIMIT_REACHED EntityLimitReachedError_Reason = "ACTIVE_EXPERIMENTS_LIMIT_REACHED"

	//
	// The number of sites exceeds the max number allowed in the network.
	//
	EntityLimitReachedError_ReasonSITES_LIMIT_REACHED EntityLimitReachedError_Reason = "SITES_LIMIT_REACHED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	EntityLimitReachedError_ReasonUNKNOWN EntityLimitReachedError_Reason = "UNKNOWN"
)

type FeatureError_Reason string

const (

	//
	// A feature is being used that is not enabled on the current network.
	//
	FeatureError_ReasonMISSING_FEATURE FeatureError_Reason = "MISSING_FEATURE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	FeatureError_ReasonUNKNOWN FeatureError_Reason = "UNKNOWN"
)

//
// Error reason types for {@link ForecastAdjustmentError}.
//

type ForecastAdjustmentError_Reason string

const (

	//
	// The adjustment has ad request source settings with a targeting expression that contains
	// request platform targeting that is not equal to the request platform targeting of the
	// targeting expression of the parent traffic forecast segment.
	//
	ForecastAdjustmentError_ReasonAD_REQUEST_SOURCE_PLATFORMS_MUST_MATCH_SEGMENT_PLATFORMS ForecastAdjustmentError_Reason = "AD_REQUEST_SOURCE_PLATFORMS_MUST_MATCH_SEGMENT_PLATFORMS"

	//
	// The adjustment has ad request historical basis settings with a source time duration that is
	// too short given the adjustment date range.
	//
	ForecastAdjustmentError_ReasonAD_REQUEST_HISTORICAL_BASIS_DATE_RANGE_TOO_SHORT_RELATIVE_TO_ADJUSTMENT ForecastAdjustmentError_Reason = "AD_REQUEST_HISTORICAL_BASIS_DATE_RANGE_TOO_SHORT_RELATIVE_TO_ADJUSTMENT"

	//
	// The adjustment contains at least one daily value above the recommended limit relative to the
	// current forecast. This error will only be thrown if adjusting the forecast above the
	// recommended limit is disallowed in the current request.
	//
	ForecastAdjustmentError_ReasonADJUSTED_VALUE_ABOVE_RECOMMENDED_RELATIVE_LIMIT ForecastAdjustmentError_Reason = "ADJUSTED_VALUE_ABOVE_RECOMMENDED_RELATIVE_LIMIT"

	//
	// The adjustment contains at least one daily value above the allowed maximum percentage of the
	// current forecast.
	//
	ForecastAdjustmentError_ReasonADJUSTED_VALUE_TOO_HIGH_RELATIVE_TO_FORECAST ForecastAdjustmentError_Reason = "ADJUSTED_VALUE_TOO_HIGH_RELATIVE_TO_FORECAST"

	//
	// The adjustment contains at least one daily value below the allowed minimum.
	//
	ForecastAdjustmentError_ReasonADJUSTED_VALUE_TOO_LOW ForecastAdjustmentError_Reason = "ADJUSTED_VALUE_TOO_LOW"

	//
	// The adjustment contains at least one daily value below the allowed minimum percentage of the
	// current forecast.
	//
	ForecastAdjustmentError_ReasonADJUSTED_VALUE_TOO_LOW_RELATIVE_TO_FORECAST ForecastAdjustmentError_Reason = "ADJUSTED_VALUE_TOO_LOW_RELATIVE_TO_FORECAST"

	//
	// The adjustment is attempting to adjust cross-sell inventory.
	//
	ForecastAdjustmentError_ReasonADJUSTS_CROSS_SELL_INVENTORY ForecastAdjustmentError_Reason = "ADJUSTS_CROSS_SELL_INVENTORY"

	//
	// The date range of the adjustment overlaps the date range of another adjustment within the
	// same traffic forecast segment.
	//
	ForecastAdjustmentError_ReasonDATE_RANGE_OVERLAPS_ANOTHER_ADJUSTMENT ForecastAdjustmentError_Reason = "DATE_RANGE_OVERLAPS_ANOTHER_ADJUSTMENT"

	//
	// The adjustment's end date is after the furthest available date in the forecast.
	//
	ForecastAdjustmentError_ReasonEND_DATE_AFTER_FURTHEST_AVAILABLE_FORECAST_DATE ForecastAdjustmentError_Reason = "END_DATE_AFTER_FURTHEST_AVAILABLE_FORECAST_DATE"

	//
	// A provided date range has an end date that is not on or after its start date.
	//
	ForecastAdjustmentError_ReasonEND_DATE_NOT_ON_OR_AFTER_START_DATE ForecastAdjustmentError_Reason = "END_DATE_NOT_ON_OR_AFTER_START_DATE"

	//
	// A historical date range is shorter than the minimum allowed length.
	//
	ForecastAdjustmentError_ReasonHISTORICAL_BASIS_DATE_RANGE_TOO_SHORT ForecastAdjustmentError_Reason = "HISTORICAL_BASIS_DATE_RANGE_TOO_SHORT"

	//
	// A historical date range has an end date not in the past.
	//
	ForecastAdjustmentError_ReasonHISTORICAL_END_DATE_NOT_IN_PAST ForecastAdjustmentError_Reason = "HISTORICAL_END_DATE_NOT_IN_PAST"

	//
	// A historical date range has a start date more than the allowed number of days before the
	// adjustment end date.
	//
	ForecastAdjustmentError_ReasonHISTORICAL_START_DATE_TOO_FAR_BEFORE_ADJUSTMENT_END_DATE ForecastAdjustmentError_Reason = "HISTORICAL_START_DATE_TOO_FAR_BEFORE_ADJUSTMENT_END_DATE"

	//
	// No volume settings were provided.
	//
	ForecastAdjustmentError_ReasonNO_VOLUME_SETTINGS_PROVIDED ForecastAdjustmentError_Reason = "NO_VOLUME_SETTINGS_PROVIDED"

	//
	// The values provided do not span the provided date range.
	//
	ForecastAdjustmentError_ReasonNUMBER_OF_VALUES_DOES_NOT_MATCH_DATE_RANGE ForecastAdjustmentError_Reason = "NUMBER_OF_VALUES_DOES_NOT_MATCH_DATE_RANGE"

	//
	// The adjustment provides historical basis ad request source settings, but the targeting of the
	// adjustment's parent traffic forecast segment is incompatible with that use.
	//
	ForecastAdjustmentError_ReasonPARENT_SEGMENT_TARGETING_INCOMPATIBLE_WITH_HISTORICAL_BASIS_AD_REQUEST_SOURCE_SETTINGS ForecastAdjustmentError_Reason = "PARENT_SEGMENT_TARGETING_INCOMPATIBLE_WITH_HISTORICAL_BASIS_AD_REQUEST_SOURCE_SETTINGS"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ForecastAdjustmentError_ReasonUNKNOWN ForecastAdjustmentError_Reason = "UNKNOWN"
)

//
// The status of a forecast adjustment. Inactive adjustments are not applied during forecasting.
//

type ForecastAdjustmentStatus string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ForecastAdjustmentStatusUNKNOWN ForecastAdjustmentStatus = "UNKNOWN"

	//
	// Indicates the current adjustment is active.
	//
	ForecastAdjustmentStatusACTIVE ForecastAdjustmentStatus = "ACTIVE"

	//
	// Indicates the current adjustment is inactive.
	//
	ForecastAdjustmentStatusINACTIVE ForecastAdjustmentStatus = "INACTIVE"
)

//
// Options for how the volume settings of a {@link ForecastAdjustment} are defined.
//

type ForecastAdjustmentVolumeType string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ForecastAdjustmentVolumeTypeUNKNOWN ForecastAdjustmentVolumeType = "UNKNOWN"

	//
	// Volume is defined by a series of daily ad opportunity counts.
	//
	ForecastAdjustmentVolumeTypeDAILY_VOLUME ForecastAdjustmentVolumeType = "DAILY_VOLUME"

	//
	// Volume is defined by a single total ad opportunity count.
	//
	ForecastAdjustmentVolumeTypeTOTAL_VOLUME ForecastAdjustmentVolumeType = "TOTAL_VOLUME"

	//
	// Volume is defined by historical volume data.
	//
	ForecastAdjustmentVolumeTypeHISTORICAL_BASIS_VOLUME ForecastAdjustmentVolumeType = "HISTORICAL_BASIS_VOLUME"
)

//
// Reason why a forecast could not be retrieved.
//

type ForecastError_Reason string

const (

	//
	// The forecast could not be retrieved due to a server side
	// connection problem. Please try again soon.
	//
	ForecastError_ReasonSERVER_NOT_AVAILABLE ForecastError_Reason = "SERVER_NOT_AVAILABLE"

	//
	// There was an unexpected internal error.
	//
	ForecastError_ReasonINTERNAL_ERROR ForecastError_Reason = "INTERNAL_ERROR"

	//
	// The forecast could not be retrieved because there is not
	// enough forecasting data available yet. It may take up to one week before
	// enough data is available.
	//
	ForecastError_ReasonNO_FORECAST_YET ForecastError_Reason = "NO_FORECAST_YET"

	//
	// There's not enough inventory for the requested reservation.
	//
	ForecastError_ReasonNOT_ENOUGH_INVENTORY ForecastError_Reason = "NOT_ENOUGH_INVENTORY"

	//
	// No error from forecast.
	//
	ForecastError_ReasonSUCCESS ForecastError_Reason = "SUCCESS"

	//
	// The requested reservation is of zero length.  No forecast is returned.
	//
	ForecastError_ReasonZERO_LENGTH_RESERVATION ForecastError_Reason = "ZERO_LENGTH_RESERVATION"

	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>
	// Another way to mitigate this error is to limit requests to 2 per second.
	// Once again this does not guarantee that every request will succeed, but
	// may help reduce the number of times you receive this error.
	// </p>
	//
	ForecastError_ReasonEXCEEDED_QUOTA ForecastError_Reason = "EXCEEDED_QUOTA"

	//
	// The request falls outside the date range of the available data.
	//
	ForecastError_ReasonOUTSIDE_AVAILABLE_DATE_RANGE ForecastError_Reason = "OUTSIDE_AVAILABLE_DATE_RANGE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ForecastError_ReasonUNKNOWN ForecastError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type GenericTargetingError_Reason string

const (

	//
	// Both including and excluding sibling criteria is disallowed.
	//
	GenericTargetingError_ReasonCONFLICTING_INCLUSION_OR_EXCLUSION_OF_SIBLINGS GenericTargetingError_Reason = "CONFLICTING_INCLUSION_OR_EXCLUSION_OF_SIBLINGS"

	//
	// Including descendants of excluded criteria is disallowed.
	//
	GenericTargetingError_ReasonINCLUDING_DESCENDANTS_OF_EXCLUDED_CRITERIA GenericTargetingError_Reason = "INCLUDING_DESCENDANTS_OF_EXCLUDED_CRITERIA"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GenericTargetingError_ReasonUNKNOWN GenericTargetingError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type GeoTargetingError_Reason string

const (

	//
	// A location that is targeted cannot also be excluded.
	//
	GeoTargetingError_ReasonTARGETED_LOCATIONS_NOT_EXCLUDABLE GeoTargetingError_Reason = "TARGETED_LOCATIONS_NOT_EXCLUDABLE"

	//
	// Excluded locations cannot have any of their children targeted.
	//
	GeoTargetingError_ReasonEXCLUDED_LOCATIONS_CANNOT_HAVE_CHILDREN_TARGETED GeoTargetingError_Reason = "EXCLUDED_LOCATIONS_CANNOT_HAVE_CHILDREN_TARGETED"

	//
	// Postal codes cannot be excluded.
	//
	GeoTargetingError_ReasonPOSTAL_CODES_CANNOT_BE_EXCLUDED GeoTargetingError_Reason = "POSTAL_CODES_CANNOT_BE_EXCLUDED"

	//
	// Indicates that location targeting is not allowed.
	//
	GeoTargetingError_ReasonUNTARGETABLE_LOCATION GeoTargetingError_Reason = "UNTARGETABLE_LOCATION"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	GeoTargetingError_ReasonUNKNOWN GeoTargetingError_Reason = "UNKNOWN"
)

//
// The single reason for the internal API error.
//

type InternalApiError_Reason string

const (

	//
	// API encountered an unexpected internal error.
	//
	InternalApiError_ReasonUNEXPECTED_INTERNAL_API_ERROR InternalApiError_Reason = "UNEXPECTED_INTERNAL_API_ERROR"

	//
	// A temporary error occurred during the request. Please retry.
	//
	InternalApiError_ReasonTRANSIENT_ERROR InternalApiError_Reason = "TRANSIENT_ERROR"

	//
	// The cause of the error is not known or only defined in newer versions.
	//
	InternalApiError_ReasonUNKNOWN InternalApiError_Reason = "UNKNOWN"

	//
	// The API is currently unavailable for a planned downtime.
	//
	InternalApiError_ReasonDOWNTIME InternalApiError_Reason = "DOWNTIME"

	//
	// Mutate succeeded but server was unable to build response. Client should not retry mutate.
	//
	InternalApiError_ReasonERROR_GENERATING_RESPONSE InternalApiError_Reason = "ERROR_GENERATING_RESPONSE"
)

type InvalidUrlError_Reason string

const (

	//
	// The URL contains invalid characters.
	//
	InvalidUrlError_ReasonILLEGAL_CHARACTERS InvalidUrlError_Reason = "ILLEGAL_CHARACTERS"

	//
	// The format of the URL is not allowed. This could occur for a number of
	// reasons. For example, if an invalid scheme is specified (like "ftp://")
	// or if a port is specified when not required, or if a query was specified
	// when not required.
	//
	InvalidUrlError_ReasonINVALID_FORMAT InvalidUrlError_Reason = "INVALID_FORMAT"

	//
	// URL contains insecure scheme.
	//
	InvalidUrlError_ReasonINSECURE_SCHEME InvalidUrlError_Reason = "INSECURE_SCHEME"

	//
	// The URL does not contain a scheme.
	//
	InvalidUrlError_ReasonNO_SCHEME InvalidUrlError_Reason = "NO_SCHEME"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InvalidUrlError_ReasonUNKNOWN InvalidUrlError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type InventoryTargetingError_Reason string

const (

	//
	// At least one placement or inventory unit is required
	//
	InventoryTargetingError_ReasonAT_LEAST_ONE_PLACEMENT_OR_INVENTORY_UNIT_REQUIRED InventoryTargetingError_Reason = "AT_LEAST_ONE_PLACEMENT_OR_INVENTORY_UNIT_REQUIRED"

	//
	// The same inventory unit or placement cannot be targeted and excluded at
	// the same time
	//
	InventoryTargetingError_ReasonINVENTORY_CANNOT_BE_TARGETED_AND_EXCLUDED InventoryTargetingError_Reason = "INVENTORY_CANNOT_BE_TARGETED_AND_EXCLUDED"

	//
	// A child inventory unit cannot be targeted if its ancestor inventory unit
	// is also targeted.
	//
	InventoryTargetingError_ReasonINVENTORY_UNIT_CANNOT_BE_TARGETED_IF_ANCESTOR_IS_TARGETED InventoryTargetingError_Reason = "INVENTORY_UNIT_CANNOT_BE_TARGETED_IF_ANCESTOR_IS_TARGETED"

	//
	// A child inventory unit cannot be targeted if its ancestor inventory unit
	// is excluded.
	//
	InventoryTargetingError_ReasonINVENTORY_UNIT_CANNOT_BE_TARGETED_IF_ANCESTOR_IS_EXCLUDED InventoryTargetingError_Reason = "INVENTORY_UNIT_CANNOT_BE_TARGETED_IF_ANCESTOR_IS_EXCLUDED"

	//
	// A child inventory unit cannot be excluded if its ancestor inventory unit
	// is also excluded.
	//
	InventoryTargetingError_ReasonINVENTORY_UNIT_CANNOT_BE_EXCLUDED_IF_ANCESTOR_IS_EXCLUDED InventoryTargetingError_Reason = "INVENTORY_UNIT_CANNOT_BE_EXCLUDED_IF_ANCESTOR_IS_EXCLUDED"

	//
	// An explicitly targeted inventory unit cannot be targeted.
	//
	InventoryTargetingError_ReasonEXPLICITLY_TARGETED_INVENTORY_UNIT_CANNOT_BE_TARGETED InventoryTargetingError_Reason = "EXPLICITLY_TARGETED_INVENTORY_UNIT_CANNOT_BE_TARGETED"

	//
	// An explicitly targeted inventory unit cannot be excluded.
	//
	InventoryTargetingError_ReasonEXPLICITLY_TARGETED_INVENTORY_UNIT_CANNOT_BE_EXCLUDED InventoryTargetingError_Reason = "EXPLICITLY_TARGETED_INVENTORY_UNIT_CANNOT_BE_EXCLUDED"

	//
	// A landing page-only ad unit cannot be targeted.
	//
	InventoryTargetingError_ReasonSELF_ONLY_INVENTORY_UNIT_NOT_ALLOWED InventoryTargetingError_Reason = "SELF_ONLY_INVENTORY_UNIT_NOT_ALLOWED"

	//
	// A landing page-only ad unit cannot be targeted if it doesn't have any
	// children.
	//
	InventoryTargetingError_ReasonSELF_ONLY_INVENTORY_UNIT_WITHOUT_DESCENDANTS InventoryTargetingError_Reason = "SELF_ONLY_INVENTORY_UNIT_WITHOUT_DESCENDANTS"

	//
	// Audience segments shared from YouTube can only be targeted with inventory shared
	// from YouTube for cross selling.
	//
	InventoryTargetingError_ReasonYOUTUBE_AUDIENCE_SEGMENTS_CAN_ONLY_BE_TARGETED_WITH_YOUTUBE_SHARED_INVENTORY InventoryTargetingError_Reason = "YOUTUBE_AUDIENCE_SEGMENTS_CAN_ONLY_BE_TARGETED_WITH_YOUTUBE_SHARED_INVENTORY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InventoryTargetingError_ReasonUNKNOWN InventoryTargetingError_Reason = "UNKNOWN"
)

//
// Possible reasons for the error.
//

type InventoryUnitError_Reason string

const (

	//
	// {@link AdUnit#explicitlyTargeted} can be set to {@code true} only in an
	// Ad Manager 360 account.
	//
	InventoryUnitError_ReasonEXPLICIT_TARGETING_NOT_ALLOWED InventoryUnitError_Reason = "EXPLICIT_TARGETING_NOT_ALLOWED"

	//
	// The specified target platform is not applicable for the inventory unit.
	//
	InventoryUnitError_ReasonTARGET_PLATFORM_NOT_APPLICABLE InventoryUnitError_Reason = "TARGET_PLATFORM_NOT_APPLICABLE"

	//
	// AdSense cannot be enabled on this inventory unit if it is disabled for the network.
	//
	InventoryUnitError_ReasonADSENSE_CANNOT_BE_ENABLED InventoryUnitError_Reason = "ADSENSE_CANNOT_BE_ENABLED"

	//
	// A root unit cannot be deactivated.
	//
	InventoryUnitError_ReasonROOT_UNIT_CANNOT_BE_DEACTIVATED InventoryUnitError_Reason = "ROOT_UNIT_CANNOT_BE_DEACTIVATED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InventoryUnitError_ReasonUNKNOWN InventoryUnitError_Reason = "UNKNOWN"
)

//
// All possible reasons the error can be thrown.
//

type InventoryUnitSizesError_Reason string

const (

	//
	// A size in the ad unit is too large or too small.
	//
	InventoryUnitSizesError_ReasonINVALID_SIZES InventoryUnitSizesError_Reason = "INVALID_SIZES"

	//
	// A size is an aspect ratio, but the ad unit is not a mobile ad unit.
	//
	InventoryUnitSizesError_ReasonINVALID_SIZE_FOR_PLATFORM InventoryUnitSizesError_Reason = "INVALID_SIZE_FOR_PLATFORM"

	//
	// A size is video, but the video feature is not enabled.
	//
	InventoryUnitSizesError_ReasonVIDEO_FEATURE_MISSING InventoryUnitSizesError_Reason = "VIDEO_FEATURE_MISSING"

	//
	// A size is video in a mobile ad unit,
	// but the mobile video feature is not enabled.
	//
	InventoryUnitSizesError_ReasonVIDEO_MOBILE_LINE_ITEM_FEATURE_MISSING InventoryUnitSizesError_Reason = "VIDEO_MOBILE_LINE_ITEM_FEATURE_MISSING"

	//
	// A size that has companions must have an environment of VIDEO_PLAYER.
	//
	InventoryUnitSizesError_ReasonINVALID_SIZE_FOR_MASTER InventoryUnitSizesError_Reason = "INVALID_SIZE_FOR_MASTER"

	//
	// A size that is a companion must have an environment of BROWSER.
	//
	InventoryUnitSizesError_ReasonINVALID_SIZE_FOR_COMPANION InventoryUnitSizesError_Reason = "INVALID_SIZE_FOR_COMPANION"

	//
	// Duplicate video master sizes are not allowed.
	//
	InventoryUnitSizesError_ReasonDUPLICATE_MASTER_SIZES InventoryUnitSizesError_Reason = "DUPLICATE_MASTER_SIZES"

	//
	// A size is an aspect ratio, but aspect ratio sizes are not enabled.
	//
	InventoryUnitSizesError_ReasonASPECT_RATIO_NOT_SUPPORTED InventoryUnitSizesError_Reason = "ASPECT_RATIO_NOT_SUPPORTED"

	//
	// A video size has companions, but companions are not allowed for the network
	//
	InventoryUnitSizesError_ReasonVIDEO_COMPANIONS_NOT_SUPPORTED InventoryUnitSizesError_Reason = "VIDEO_COMPANIONS_NOT_SUPPORTED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	InventoryUnitSizesError_ReasonUNKNOWN InventoryUnitSizesError_Reason = "UNKNOWN"
)

//
// Minutes in an hour. Currently, only 0, 15, 30, and 45 are supported. This
// field is required.
//

type MinuteOfHour string

const (

	//
	// Zero minutes past hour.
	//
	MinuteOfHourZERO MinuteOfHour = "ZERO"

	//
	// Fifteen minutes past hour.
	//
	MinuteOfHourFIFTEEN MinuteOfHour = "FIFTEEN"

	//
	// Thirty minutes past hour.
	//
	MinuteOfHourTHIRTY MinuteOfHour = "THIRTY"

	//
	// Forty-five minutes past hour.
	//
	MinuteOfHourFORTY_FIVE MinuteOfHour = "FORTY_FIVE"
)

//
// The reasons for the target error.
//

type NotNullError_Reason string

const (

	//
	// Assuming that a method will not have more than 3 arguments, if it does,
	// return NULL
	//
	NotNullError_ReasonARG1_NULL NotNullError_Reason = "ARG1_NULL"

	NotNullError_ReasonARG2_NULL NotNullError_Reason = "ARG2_NULL"

	NotNullError_ReasonARG3_NULL NotNullError_Reason = "ARG3_NULL"

	NotNullError_ReasonNULL NotNullError_Reason = "NULL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	NotNullError_ReasonUNKNOWN NotNullError_Reason = "UNKNOWN"
)

//
// The reasons for the validation error.
//

type NullError_Reason string

const (

	//
	// Specified list/container must not contain any null elements
	//
	NullError_ReasonNULL_CONTENT NullError_Reason = "NULL_CONTENT"
)

//
// The reasons for the target error.
//

type ParseError_Reason string

const (

	//
	// Indicates an error in parsing an attribute.
	//
	ParseError_ReasonUNPARSABLE ParseError_Reason = "UNPARSABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ParseError_ReasonUNKNOWN ParseError_Reason = "UNKNOWN"
)

//
// Describes reasons for permission errors.
//

type PermissionError_Reason string

const (

	//
	// User does not have the required permission for the request.
	//
	PermissionError_ReasonPERMISSION_DENIED PermissionError_Reason = "PERMISSION_DENIED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PermissionError_ReasonUNKNOWN PermissionError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PublisherQueryLanguageContextError_Reason string

const (

	//
	// Indicates that there was an error executing the PQL.
	//
	PublisherQueryLanguageContextError_ReasonUNEXECUTABLE PublisherQueryLanguageContextError_Reason = "UNEXECUTABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageContextError_ReasonUNKNOWN PublisherQueryLanguageContextError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type PublisherQueryLanguageSyntaxError_Reason string

const (

	//
	// Indicates that there was a PQL syntax error.
	//
	PublisherQueryLanguageSyntaxError_ReasonUNPARSABLE PublisherQueryLanguageSyntaxError_Reason = "UNPARSABLE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	PublisherQueryLanguageSyntaxError_ReasonUNKNOWN PublisherQueryLanguageSyntaxError_Reason = "UNKNOWN"
)

type QuotaError_Reason string

const (

	//
	// The number of requests made per second is too high and has exceeded the
	// allowable limit. The recommended approach to handle this error is to wait
	// about 5 seconds and then retry the request. Note that this does not
	// guarantee the request will succeed. If it fails again, try increasing the
	// wait time.
	// <p>Another way to mitigate this error is to limit requests to 8 per second for Ad Manager
	// 360 accounts, or 2 per second for Ad Manager accounts. Once again
	// this does not guarantee that every request will succeed, but may help
	// reduce the number of times you receive this error.
	//
	QuotaError_ReasonEXCEEDED_QUOTA QuotaError_Reason = "EXCEEDED_QUOTA"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	QuotaError_ReasonUNKNOWN QuotaError_Reason = "UNKNOWN"

	//
	// This user has exceeded the allowed number of new report requests per hour
	// (this includes both reports run via the UI and reports
	// run via {@link ReportService#runReportJob}).
	// The recommended approach to handle this error is to wait about 10 minutes
	// and then retry the request. Note that this does not guarantee the request
	// will succeed. If it fails again, try increasing the wait time.
	// <p>Another way to mitigate this error is to limit the number of new report
	// requests to 250 per hour per user. Once again, this does not guarantee that
	// every request will succeed, but may help reduce the number of times you
	// receive this error.
	//
	QuotaError_ReasonREPORT_JOB_LIMIT QuotaError_Reason = "REPORT_JOB_LIMIT"

	//
	// This network has exceeded the allowed number of identifiers uploaded within a 24 hour period.
	// The recommended approach to handle this error is to wait 30 minutes and then retry the
	// request. Note that this does not guarantee the request will succeed. If it fails again, try
	// increasing the wait time.
	//
	QuotaError_ReasonSEGMENT_POPULATION_LIMIT QuotaError_Reason = "SEGMENT_POPULATION_LIMIT"
)

//
// Represents the platform which requests and renders the ad.
//

type RequestPlatform string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequestPlatformUNKNOWN RequestPlatform = "UNKNOWN"

	//
	// Represents a request made from a web browser. This includes both desktop and mobile web.
	//
	RequestPlatformBROWSER RequestPlatform = "BROWSER"

	//
	// Represents a request made from a mobile application. This includes mobile app interstitial and
	// rewarded video requests.
	//
	RequestPlatformMOBILE_APP RequestPlatform = "MOBILE_APP"

	//
	// Represents a request made from a video player that is playing publisher content. This includes
	// video players embedded in web pages and mobile applications, and connected TV screens.
	//
	RequestPlatformVIDEO_PLAYER RequestPlatform = "VIDEO_PLAYER"
)

type RequiredCollectionError_Reason string

const (

	//
	// A required collection is missing.
	//
	RequiredCollectionError_ReasonREQUIRED RequiredCollectionError_Reason = "REQUIRED"

	//
	// Collection size is too large.
	//
	RequiredCollectionError_ReasonTOO_LARGE RequiredCollectionError_Reason = "TOO_LARGE"

	//
	// Collection size is too small.
	//
	RequiredCollectionError_ReasonTOO_SMALL RequiredCollectionError_Reason = "TOO_SMALL"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	RequiredCollectionError_ReasonUNKNOWN RequiredCollectionError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type RequiredError_Reason string

const (

	//
	// Missing required field.
	//
	RequiredError_ReasonREQUIRED RequiredError_Reason = "REQUIRED"
)

//
// Describes reasons for server errors
//

type ServerError_Reason string

const (

	//
	// Indicates that an unexpected error occured.
	//
	ServerError_ReasonSERVER_ERROR ServerError_Reason = "SERVER_ERROR"

	//
	// Indicates that the server is currently experiencing a high load. Please
	// wait and try your request again.
	//
	ServerError_ReasonSERVER_BUSY ServerError_Reason = "SERVER_BUSY"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	ServerError_ReasonUNKNOWN ServerError_Reason = "UNKNOWN"
)

type StatementError_Reason string

const (

	//
	// A bind variable has not been bound to a value.
	//
	StatementError_ReasonVARIABLE_NOT_BOUND_TO_VALUE StatementError_Reason = "VARIABLE_NOT_BOUND_TO_VALUE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StatementError_ReasonUNKNOWN StatementError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type StringFormatError_Reason string

const (
	StringFormatError_ReasonUNKNOWN StringFormatError_Reason = "UNKNOWN"

	//
	// The input string value contains disallowed characters.
	//
	StringFormatError_ReasonILLEGAL_CHARS StringFormatError_Reason = "ILLEGAL_CHARS"

	//
	// The input string value is invalid for the associated field.
	//
	StringFormatError_ReasonINVALID_FORMAT StringFormatError_Reason = "INVALID_FORMAT"
)

type StringLengthError_Reason string

const (
	StringLengthError_ReasonTOO_LONG StringLengthError_Reason = "TOO_LONG"

	StringLengthError_ReasonTOO_SHORT StringLengthError_Reason = "TOO_SHORT"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	StringLengthError_ReasonUNKNOWN StringLengthError_Reason = "UNKNOWN"
)

//
// The reasons for the target error.
//

type TechnologyTargetingError_Reason string

const (

	//
	// Mobile line item cannot target web-only targeting criteria.
	//
	TechnologyTargetingError_ReasonMOBILE_LINE_ITEM_CONTAINS_WEB_TECH_CRITERIA TechnologyTargetingError_Reason = "MOBILE_LINE_ITEM_CONTAINS_WEB_TECH_CRITERIA"

	//
	// Web line item cannot target mobile-only targeting criteria.
	//
	TechnologyTargetingError_ReasonWEB_LINE_ITEM_CONTAINS_MOBILE_TECH_CRITERIA TechnologyTargetingError_Reason = "WEB_LINE_ITEM_CONTAINS_MOBILE_TECH_CRITERIA"

	//
	// The mobile carrier targeting feature is not enabled.
	//
	TechnologyTargetingError_ReasonMOBILE_CARRIER_TARGETING_FEATURE_NOT_ENABLED TechnologyTargetingError_Reason = "MOBILE_CARRIER_TARGETING_FEATURE_NOT_ENABLED"

	//
	// The device capability targeting feature is not enabled.
	//
	TechnologyTargetingError_ReasonDEVICE_CAPABILITY_TARGETING_FEATURE_NOT_ENABLED TechnologyTargetingError_Reason = "DEVICE_CAPABILITY_TARGETING_FEATURE_NOT_ENABLED"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TechnologyTargetingError_ReasonUNKNOWN TechnologyTargetingError_Reason = "UNKNOWN"
)

//
// Error reason types for {@link TrafficForecastSegmentError}.
//

type TrafficForecastSegmentError_Reason string

const (

	//
	// Segment targeting cannot be changed after segment creation.
	//
	TrafficForecastSegmentError_ReasonCANNOT_UPDATE_TARGETING_AFTER_CREATION TrafficForecastSegmentError_Reason = "CANNOT_UPDATE_TARGETING_AFTER_CREATION"

	//
	// The targeting expression that defines the segment is not unique within the given network's
	// segments.
	//
	// <p>The ID of the colliding segment will be provided in the {@link ApiError#trigger}.
	//
	TrafficForecastSegmentError_ReasonTARGETING_NOT_UNIQUE TrafficForecastSegmentError_Reason = "TARGETING_NOT_UNIQUE"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	TrafficForecastSegmentError_ReasonUNKNOWN TrafficForecastSegmentError_Reason = "UNKNOWN"
)

//
// {@link ApiErrorReason} enum for user domain targeting error.
//

type UserDomainTargetingError_Reason string

const (

	//
	// Invalid domain names. Domain names must be at most 67 characters long.
	// And must contain only alphanumeric characters and hyphens.
	//
	UserDomainTargetingError_ReasonINVALID_DOMAIN_NAMES UserDomainTargetingError_Reason = "INVALID_DOMAIN_NAMES"

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	UserDomainTargetingError_ReasonUNKNOWN UserDomainTargetingError_Reason = "UNKNOWN"
)

//
// Represents the options for targetable bumper positions, surrounding an ad
// pod, within a video stream. This includes before and after the supported ad
// pod positions, {@link VideoPositionType#PREROLL},
// {@link VideoPositionType#MIDROLL}, and {@link VideoPositionType#POSTROLL}.
//

type VideoBumperType string

const (

	//
	// Represents the bumper position before the ad pod.
	//
	VideoBumperTypeBEFORE VideoBumperType = "BEFORE"

	//
	// Represents the bumper position after the ad pod.
	//
	VideoBumperTypeAFTER VideoBumperType = "AFTER"
)

//
// Represents a targetable position within a video.
//

type VideoPosition_Type string

const (

	//
	// The value returned if the actual value is not exposed by the requested API version.
	//
	VideoPosition_TypeUNKNOWN VideoPosition_Type = "UNKNOWN"

	//
	// This position targets all of the above video positions.
	//
	VideoPosition_TypeALL VideoPosition_Type = "ALL"

	//
	// The position defined as showing before the video starts playing.
	//
	VideoPosition_TypePREROLL VideoPosition_Type = "PREROLL"

	//
	// The position defined as showing within the middle of the playing video.
	//
	VideoPosition_TypeMIDROLL VideoPosition_Type = "MIDROLL"

	//
	// The position defined as showing after the video is completed.
	//
	VideoPosition_TypePOSTROLL VideoPosition_Type = "POSTROLL"
)

type CalculateDailyAdOpportunityCounts struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 calculateDailyAdOpportunityCounts"`

	ForecastAdjustment *ForecastAdjustment `xml:"forecastAdjustment,omitempty" json:"forecastAdjustment,omitempty"`
}

type CalculateDailyAdOpportunityCountsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 calculateDailyAdOpportunityCountsResponse"`

	Rval *ForecastAdjustment `xml:"rval,omitempty" json:"rval,omitempty"`
}

type ApiExceptionFault ApiException

type CreateForecastAdjustments struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createForecastAdjustments"`

	ForecastAdjustments []*ForecastAdjustment `xml:"forecastAdjustments,omitempty" json:"forecastAdjustments,omitempty"`
}

type CreateForecastAdjustmentsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createForecastAdjustmentsResponse"`

	Rval []*ForecastAdjustment `xml:"rval,omitempty" json:"rval,omitempty"`
}

type CreateTrafficForecastSegments struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createTrafficForecastSegments"`

	TrafficForecastSegments []*TrafficForecastSegment `xml:"trafficForecastSegments,omitempty" json:"trafficForecastSegments,omitempty"`
}

type CreateTrafficForecastSegmentsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 createTrafficForecastSegmentsResponse"`

	Rval []*TrafficForecastSegment `xml:"rval,omitempty" json:"rval,omitempty"`
}

type GetForecastAdjustmentsByStatement struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getForecastAdjustmentsByStatement"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type GetForecastAdjustmentsByStatementResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getForecastAdjustmentsByStatementResponse"`

	Rval *ForecastAdjustmentPage `xml:"rval,omitempty" json:"rval,omitempty"`
}

type GetTrafficForecastSegmentsByStatement struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getTrafficForecastSegmentsByStatement"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type GetTrafficForecastSegmentsByStatementResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 getTrafficForecastSegmentsByStatementResponse"`

	Rval *TrafficForecastSegmentPage `xml:"rval,omitempty" json:"rval,omitempty"`
}

type PerformForecastAdjustmentAction struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 performForecastAdjustmentAction"`

	ForecastAdjustmentAction *ForecastAdjustmentAction `xml:"forecastAdjustmentAction,omitempty" json:"forecastAdjustmentAction,omitempty"`

	FilterStatement *Statement `xml:"filterStatement,omitempty" json:"filterStatement,omitempty"`
}

type PerformForecastAdjustmentActionResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 performForecastAdjustmentActionResponse"`

	Rval *UpdateResult `xml:"rval,omitempty" json:"rval,omitempty"`
}

type UpdateForecastAdjustments struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateForecastAdjustments"`

	ForecastAdjustments []*ForecastAdjustment `xml:"forecastAdjustments,omitempty" json:"forecastAdjustments,omitempty"`
}

type UpdateForecastAdjustmentsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateForecastAdjustmentsResponse"`

	Rval []*ForecastAdjustment `xml:"rval,omitempty" json:"rval,omitempty"`
}

type UpdateTrafficForecastSegments struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateTrafficForecastSegments"`

	TrafficForecastSegments []*TrafficForecastSegment `xml:"trafficForecastSegments,omitempty" json:"trafficForecastSegments,omitempty"`
}

type UpdateTrafficForecastSegmentsResponse struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 updateTrafficForecastSegmentsResponse"`

	Rval []*TrafficForecastSegment `xml:"rval,omitempty" json:"rval,omitempty"`
}

type RequestHeader SoapRequestHeader

type ResponseHeader SoapResponseHeader

type ObjectValue struct {
	*_Value
}

type ActivateForecastAdjustments struct {
	*ForecastAdjustmentAction
}

type AdUnitTargeting struct {

	//
	// Included or excluded ad unit id.
	//
	AdUnitId string `xml:"adUnitId,omitempty" json:"adUnitId,omitempty"`

	//
	// Whether or not all descendants are included (or excluded) as part of including (or excluding)
	// this ad unit. By default, the value is {@code true} which means targeting this ad unit will
	// target all of its descendants.
	//
	IncludeDescendants bool `xml:"includeDescendants,omitempty" json:"includeDescendants,omitempty"`
}

type ApiError struct {

	//
	// The OGNL field path to identify cause of error.
	//
	FieldPath string `xml:"fieldPath,omitempty" json:"fieldPath,omitempty"`

	//
	// A parsed copy of the field path. For example, the field path "operations[1].operand"
	// corresponds to this list: {FieldPathElement(field = "operations", index = 1),
	// FieldPathElement(field = "operand", index = null)}.
	//
	FieldPathElements []*FieldPathElement `xml:"fieldPathElements,omitempty" json:"fieldPathElements,omitempty"`

	//
	// The data that caused the error.
	//
	Trigger string `xml:"trigger,omitempty" json:"trigger,omitempty"`

	//
	// A simple string representation of the error and reason.
	//
	ErrorString string `xml:"errorString,omitempty" json:"errorString,omitempty"`
}

type ApiException struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 ApiExceptionFault"`

	*ApplicationException

	//
	// List of errors.
	//
	Errors []*ApiError `xml:"errors,omitempty" json:"errors,omitempty"`
}

type TechnologyTargeting struct {

	//
	// The bandwidth groups being targeted by the {@link LineItem}.
	//
	BandwidthGroupTargeting *BandwidthGroupTargeting `xml:"bandwidthGroupTargeting,omitempty" json:"bandwidthGroupTargeting,omitempty"`

	//
	// The browsers being targeted by the {@link LineItem}.
	//
	BrowserTargeting *BrowserTargeting `xml:"browserTargeting,omitempty" json:"browserTargeting,omitempty"`

	//
	// The languages of browsers being targeted by the {@link LineItem}.
	//
	BrowserLanguageTargeting *BrowserLanguageTargeting `xml:"browserLanguageTargeting,omitempty" json:"browserLanguageTargeting,omitempty"`

	//
	// The device capabilities being targeted by the {@link LineItem}.
	//
	DeviceCapabilityTargeting *DeviceCapabilityTargeting `xml:"deviceCapabilityTargeting,omitempty" json:"deviceCapabilityTargeting,omitempty"`

	//
	// The device categories being targeted by the {@link LineItem}.
	//
	DeviceCategoryTargeting *DeviceCategoryTargeting `xml:"deviceCategoryTargeting,omitempty" json:"deviceCategoryTargeting,omitempty"`

	//
	// The device manufacturers being targeted by the {@link LineItem}.
	//
	DeviceManufacturerTargeting *DeviceManufacturerTargeting `xml:"deviceManufacturerTargeting,omitempty" json:"deviceManufacturerTargeting,omitempty"`

	//
	// The mobile carriers being targeted by the {@link LineItem}.
	//
	MobileCarrierTargeting *MobileCarrierTargeting `xml:"mobileCarrierTargeting,omitempty" json:"mobileCarrierTargeting,omitempty"`

	//
	// The mobile devices being targeted by the {@link LineItem}.
	//
	MobileDeviceTargeting *MobileDeviceTargeting `xml:"mobileDeviceTargeting,omitempty" json:"mobileDeviceTargeting,omitempty"`

	//
	// The mobile device submodels being targeted by the {@link LineItem}.
	//
	MobileDeviceSubmodelTargeting *MobileDeviceSubmodelTargeting `xml:"mobileDeviceSubmodelTargeting,omitempty" json:"mobileDeviceSubmodelTargeting,omitempty"`

	//
	// The operating systems being targeted by the {@link LineItem}.
	//
	OperatingSystemTargeting *OperatingSystemTargeting `xml:"operatingSystemTargeting,omitempty" json:"operatingSystemTargeting,omitempty"`

	//
	// The operating system versions being targeted by the {@link LineItem}.
	//
	OperatingSystemVersionTargeting *OperatingSystemVersionTargeting `xml:"operatingSystemVersionTargeting,omitempty" json:"operatingSystemVersionTargeting,omitempty"`
}

type ApiVersionError struct {
	*ApiError

	Reason *ApiVersionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ApplicationException struct {

	//
	// Error message.
	//
	Message string `xml:"message,omitempty" json:"message,omitempty"`
}

type AuthenticationError struct {
	*ApiError

	Reason *AuthenticationError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type BandwidthGroup struct {
	*Technology
}

type BandwidthGroupTargeting struct {

	//
	// Indicates whether bandwidth groups should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// The bandwidth groups that are being targeted or excluded by the {@link LineItem}.
	//
	BandwidthGroups []*Technology `xml:"bandwidthGroups,omitempty" json:"bandwidthGroups,omitempty"`
}

type BooleanValue struct {
	*_Value

	//
	// The boolean value.
	//
	Value bool `xml:"value,omitempty" json:"value,omitempty"`
}

type Browser struct {
	*Technology

	//
	// Browser major version.
	//
	MajorVersion string `xml:"majorVersion,omitempty" json:"majorVersion,omitempty"`

	//
	// Browser minor version.
	//
	MinorVersion string `xml:"minorVersion,omitempty" json:"minorVersion,omitempty"`
}

type BrowserLanguage struct {
	*Technology
}

type BrowserLanguageTargeting struct {

	//
	// Indicates whether browsers languages should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Browser languages that are being targeted or excluded by the {@link LineItem}.
	//
	BrowserLanguages []*Technology `xml:"browserLanguages,omitempty" json:"browserLanguages,omitempty"`
}

type BrowserTargeting struct {

	//
	// Indicates whether browsers should be targeted or excluded. This attribute is optional and
	// defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Browsers that are being targeted or excluded by the {@link LineItem}.
	//
	Browsers []*Technology `xml:"browsers,omitempty" json:"browsers,omitempty"`
}

type BuyerUserListTargeting struct {

	//
	// Whether the programmatic {@code LineItem} or {@code ProposalLineItem} object has buyer user
	// list targeting.
	//
	HasBuyerUserListTargeting bool `xml:"hasBuyerUserListTargeting,omitempty" json:"hasBuyerUserListTargeting,omitempty"`
}

type CollectionSizeError struct {
	*ApiError

	Reason *CollectionSizeError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CommonError struct {
	*ApiError

	Reason *CommonError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ContentTargeting struct {

	//
	// The IDs of content being targeted by the {@code LineItem}.
	//
	TargetedContentIds []int64 `xml:"targetedContentIds,omitempty" json:"targetedContentIds,omitempty"`

	//
	// The IDs of content being excluded by the {@code LineItem}.
	//
	ExcludedContentIds []int64 `xml:"excludedContentIds,omitempty" json:"excludedContentIds,omitempty"`

	//
	// A list of video content bundles, represented by {@link ContentBundle} IDs, that are being
	// targeted by the {@code LineItem}.
	//
	TargetedVideoContentBundleIds []int64 `xml:"targetedVideoContentBundleIds,omitempty" json:"targetedVideoContentBundleIds,omitempty"`

	//
	// A list of video content bundles, represented by {@link ContentBundle} IDs, that are being
	// excluded by the {@code LineItem}.
	//
	ExcludedVideoContentBundleIds []int64 `xml:"excludedVideoContentBundleIds,omitempty" json:"excludedVideoContentBundleIds,omitempty"`
}

type CustomCriteria struct {
	*CustomCriteriaLeaf

	//
	// The {@link CustomTargetingKey#id} of the {@link CustomTargetingKey} object that was created
	// using {@link CustomTargetingService}. This attribute is required.
	//
	KeyId int64 `xml:"keyId,omitempty" json:"keyId,omitempty"`

	//
	// The ids of {@link CustomTargetingValue} objects to target the custom targeting key with id
	// {@link CustomCriteria#keyId}. This attribute is required.
	//
	ValueIds []int64 `xml:"valueIds,omitempty" json:"valueIds,omitempty"`

	//
	// The comparison operator. This attribute is required.
	//
	Operator *CustomCriteria_ComparisonOperator `xml:"operator,omitempty" json:"operator,omitempty"`
}

type CustomCriteriaSet struct {
	*CustomCriteriaNode

	//
	// The logical operator to be applied to {@link CustomCriteriaSet#children}. This attribute is
	// required.
	// <span class="constraint Required">This attribute is required.</span>
	//
	LogicalOperator *CustomCriteriaSet_LogicalOperator `xml:"logicalOperator,omitempty" json:"logicalOperator,omitempty"`

	//
	// The custom criteria. This attribute is required.
	//
	Children []*CustomCriteriaNode `xml:"children,omitempty" json:"children,omitempty"`
}

type CmsMetadataCriteria struct {
	*CustomCriteriaLeaf

	//
	// The comparison operator. This attribute is required.
	//
	Operator *CmsMetadataCriteria_ComparisonOperator `xml:"operator,omitempty" json:"operator,omitempty"`

	//
	// The ids of {@link CmsMetadataValue} objects used to target CMS metadata. This attribute is
	// required.
	//
	CmsMetadataValueIds []int64 `xml:"cmsMetadataValueIds,omitempty" json:"cmsMetadataValueIds,omitempty"`
}

type CustomTargetingError struct {
	*ApiError

	Reason *CustomTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type CustomCriteriaLeaf struct {
	*CustomCriteriaNode
}

type CustomCriteriaNode struct {
}

type AudienceSegmentCriteria struct {
	*CustomCriteriaLeaf

	//
	// The comparison operator. This attribute is required.
	//
	Operator *AudienceSegmentCriteria_ComparisonOperator `xml:"operator,omitempty" json:"operator,omitempty"`

	//
	// The ids of {@link AudienceSegment} objects used to target audience segments. This attribute is
	// required.
	//
	AudienceSegmentIds []int64 `xml:"audienceSegmentIds,omitempty" json:"audienceSegmentIds,omitempty"`
}

type DailyVolumeSettings struct {

	//
	// The list of ad opportunity counts. Each value in this list represents the expected number of ad
	// opportunities on the corresponding day of the adjustment date range.
	//
	// <p>The number of values provided must match the number of days in the adjustment date range,
	// inclusive. For example, an adjustment date range of June 5-June 7 would need 3 values in this
	// list, one for June 5, one for June 6, and one for June 7.
	// <span class="constraint Required">This attribute is required.</span>
	//
	AdOpportunityCounts []int64 `xml:"adOpportunityCounts,omitempty" json:"adOpportunityCounts,omitempty"`
}

type Date struct {

	//
	// Year (e.g., 2009)
	//
	Year int32 `xml:"year,omitempty" json:"year,omitempty"`

	//
	// Month (1..12)
	//
	Month int32 `xml:"month,omitempty" json:"month,omitempty"`

	//
	// Day (1..31)
	//
	Day int32 `xml:"day,omitempty" json:"day,omitempty"`
}

type DateError struct {
	*ApiError

	Reason *DateError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type DateRange struct {

	//
	// The start date of this range. This field is optional and if it is not set then there is no
	// lower bound on the date range. If this field is not set then {@code endDate} must be specified.
	//
	StartDate soap.XSDDate `xml:"startDate,omitempty" json:"startDate,omitempty"`

	//
	// The end date of this range. This field is optional and if it is not set then there is no upper
	// bound on the date range. If this field is not set then {@code startDate} must be specified.
	//
	EndDate soap.XSDDate `xml:"endDate,omitempty" json:"endDate,omitempty"`
}

type DateTime struct {
	Date soap.XSDDate `xml:"date,omitempty" json:"date,omitempty"`

	Hour int32 `xml:"hour,omitempty" json:"hour,omitempty"`

	Minute int32 `xml:"minute,omitempty" json:"minute,omitempty"`

	Second int32 `xml:"second,omitempty" json:"second,omitempty"`

	TimeZoneId string `xml:"timeZoneId,omitempty" json:"timeZoneId,omitempty"`
}

type DateTimeRange struct {

	//
	// The start date time of this range. This field is optional and if it is not set then there is no
	// lower bound on the date time range. If this field is not set then {@code endDateTime} must be
	// specified.
	//
	StartDateTime soap.XSDDateTime `xml:"startDateTime,omitempty" json:"startDateTime,omitempty"`

	//
	// The end date time of this range. This field is optional and if it is not set then there is no
	// upper bound on the date time range. If this field is not set then {@code startDateTime} must be
	// specified.
	//
	EndDateTime soap.XSDDateTime `xml:"endDateTime,omitempty" json:"endDateTime,omitempty"`
}

type DateTimeRangeTargeting struct {
	TargetedDateTimeRanges []*DateTimeRange `xml:"targetedDateTimeRanges,omitempty" json:"targetedDateTimeRanges,omitempty"`
}

type DateTimeRangeTargetingError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *DateTimeRangeTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type DateTimeValue struct {
	*_Value

	//
	// The {@code DateTime} value.
	//
	Value soap.XSDDateTime `xml:"value,omitempty" json:"value,omitempty"`
}

type DateValue struct {
	*_Value

	//
	// The {@code Date} value.
	//
	Value soap.XSDDate `xml:"value,omitempty" json:"value,omitempty"`
}

type DayPart struct {

	//
	// Day of the week the target applies to. This field is required.
	//
	DayOfWeek *DayOfWeek `xml:"dayOfWeek,omitempty" json:"dayOfWeek,omitempty"`

	//
	// Represents the start time of the targeted period (inclusive).
	//
	StartTime *TimeOfDay `xml:"startTime,omitempty" json:"startTime,omitempty"`

	//
	// Represents the end time of the targeted period (exclusive).
	//
	EndTime *TimeOfDay `xml:"endTime,omitempty" json:"endTime,omitempty"`
}

type DayPartTargeting struct {

	//
	// Specifies days of the week and times at which a {@code LineItem} will be delivered.
	//
	// <p>If targeting all days and times, this value will be ignored.
	//
	DayParts []*DayPart `xml:"dayParts,omitempty" json:"dayParts,omitempty"`

	//
	// Specifies the time zone to be used for delivering {@link LineItem} objects. This attribute is
	// optional and defaults to {@link DeliveryTimeZone#BROWSER}.
	//
	// <p>Setting this has no effect if targeting all days and times.
	//
	TimeZone *DeliveryTimeZone `xml:"timeZone,omitempty" json:"timeZone,omitempty"`
}

type DayPartTargetingError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *DayPartTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type DeactivateForecastAdjustments struct {
	*ForecastAdjustmentAction
}

type DeviceCapability struct {
	*Technology
}

type DeviceCapabilityTargeting struct {

	//
	// Device capabilities that are being targeted by the {@link LineItem}.
	//
	TargetedDeviceCapabilities []*Technology `xml:"targetedDeviceCapabilities,omitempty" json:"targetedDeviceCapabilities,omitempty"`

	//
	// Device capabilities that are being excluded by the {@link LineItem}.
	//
	ExcludedDeviceCapabilities []*Technology `xml:"excludedDeviceCapabilities,omitempty" json:"excludedDeviceCapabilities,omitempty"`
}

type DeviceCategory struct {
	*Technology
}

type DeviceCategoryTargeting struct {

	//
	// Device categories that are being targeted by the {@link LineItem}.
	//
	TargetedDeviceCategories []*Technology `xml:"targetedDeviceCategories,omitempty" json:"targetedDeviceCategories,omitempty"`

	//
	// Device categories that are being excluded by the {@link LineItem}.
	//
	ExcludedDeviceCategories []*Technology `xml:"excludedDeviceCategories,omitempty" json:"excludedDeviceCategories,omitempty"`
}

type DeviceManufacturer struct {
	*Technology
}

type DeviceManufacturerTargeting struct {

	//
	// Indicates whether device manufacturers should be targeted or excluded. This attribute is
	// optional and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Device manufacturers that are being targeted or excluded by the {@link LineItem}.
	//
	DeviceManufacturers []*Technology `xml:"deviceManufacturers,omitempty" json:"deviceManufacturers,omitempty"`
}

type EntityLimitReachedError struct {
	*ApiError

	Reason *EntityLimitReachedError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FeatureError struct {
	*ApiError

	Reason *FeatureError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type FieldPathElement struct {

	//
	// The name of a field in lower camelcase. (e.g. "biddingStrategy")
	//
	Field string `xml:"field,omitempty" json:"field,omitempty"`

	//
	// For list fields, this is a 0-indexed position in the list. Null for non-list fields.
	//
	Index int32 `xml:"index,omitempty" json:"index,omitempty"`
}

type ForecastAdjustmentAction struct {
}

type ForecastAdjustment struct {

	//
	// The unique ID of the ForecastAdjustment. This field is read-only.
	// This attribute is read-only.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// The ID of the parent TrafficForecastSegment. This field is required and immutable after
	// creation.
	// <span class="constraint Required">This attribute is required.</span>
	//
	TrafficForecastSegmentId int64 `xml:"trafficForecastSegmentId,omitempty" json:"trafficForecastSegmentId,omitempty"`

	//
	// Name of the ForecastAdjustment.
	// <span class="constraint Required">This attribute is required.</span>
	//
	Name string `xml:"name,omitempty" json:"name,omitempty"`

	//
	// The start and end date range of the adjustment.
	// <span class="constraint Required">This attribute is required.</span>
	//
	DateRange *DateRange `xml:"dateRange,omitempty" json:"dateRange,omitempty"`

	//
	// The status of the adjustment. Changes to this field should be made via {@code
	// performForecastAdjustmentAction}
	// This attribute is read-only.
	//
	Status *ForecastAdjustmentStatus `xml:"status,omitempty" json:"status,omitempty"`

	//
	// The volume type of the adjustment.
	// <span class="constraint Required">This attribute is required.</span>
	//
	VolumeType *ForecastAdjustmentVolumeType `xml:"volumeType,omitempty" json:"volumeType,omitempty"`

	//
	// Whether to allow provided volume settings to increase the current forecast by more than 300%.
	// Due to system constraints, adjusting the forecast by more than 300% may have unintended
	// consequences for other parts of the forecast.
	//
	// <p>Note that this field will not persist on the adjustment itself, and will only affect the
	// current request.
	//
	AllowAdjustingForecastAboveRecommendedLimit bool `xml:"allowAdjustingForecastAboveRecommendedLimit,omitempty" json:"allowAdjustingForecastAboveRecommendedLimit,omitempty"`

	//
	// The daily number of ad opportunities for each day in the adjustment date range. This field is
	// required if {@code volumeType} is {@code ForecastAdjustmentVolumeType#DAILY_VOLUME} and ignored
	// othewise.
	//
	DailyVolumeSettings *DailyVolumeSettings `xml:"dailyVolumeSettings,omitempty" json:"dailyVolumeSettings,omitempty"`

	//
	// The total number of ad opportunities for the entire adjustment date range. This field is
	// required if {@code volumeType} is {@code ForecastAdjustmentVolumeType#TOTAL_VOLUME} and ignored
	// othewise.
	//
	TotalVolumeSettings *TotalVolumeSettings `xml:"totalVolumeSettings,omitempty" json:"totalVolumeSettings,omitempty"`

	//
	// The daily number of ad opportunities for each day in the adjustment date range, determined by
	// reference to the ad opportunity volume of a historical reference period. This field is required
	// if {@code volumeType} is {@code ForecastAdjustmentVolumeType#HISTORICAL_BASIS_VOLUME} and
	// ignored othewise.
	//
	HistoricalBasisVolumeSettings *HistoricalBasisVolumeSettings `xml:"historicalBasisVolumeSettings,omitempty" json:"historicalBasisVolumeSettings,omitempty"`

	//
	// The daily number of ad opportunities calculated to satisfy the provided volume settings. Each
	// value in this list represents the calculated ad opportunities on the corresponding day of the
	// adjustment date range. For example: for a {@code dateRange} of 2001-8-15 to 2001-8-17, this
	// field will contain one value for 2001-8-15, one value for 2001-8-16, and one value for
	// 2001-8-17.
	//
	// <p>This field is read-only and is populated by Google after forecast adjustment creation or
	// update.
	// This attribute is read-only.
	//
	CalculatedDailyAdOpportunityCounts []int64 `xml:"calculatedDailyAdOpportunityCounts,omitempty" json:"calculatedDailyAdOpportunityCounts,omitempty"`
}

type ForecastAdjustmentError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ForecastAdjustmentError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ForecastAdjustmentPage struct {

	//
	// The size of the total result set to which this page belongs.
	//
	TotalResultSetSize int32 `xml:"totalResultSetSize,omitempty" json:"totalResultSetSize,omitempty"`

	//
	// The absolute index in the total result set on which this page begins.
	//
	StartIndex int32 `xml:"startIndex,omitempty" json:"startIndex,omitempty"`

	//
	// The collection of forecast adjustments contained within this page.
	//
	Results []*ForecastAdjustment `xml:"results,omitempty" json:"results,omitempty"`
}

type ForecastError struct {
	*ApiError

	//
	// The reason for the forecast error.
	//
	Reason *ForecastError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type GenericTargetingError struct {
	*ApiError

	Reason *GenericTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type GeoTargeting struct {

	//
	// The geographical locations being targeted by the {@link LineItem}.
	//
	TargetedLocations []*Location `xml:"targetedLocations,omitempty" json:"targetedLocations,omitempty"`

	//
	// The geographical locations being excluded by the {@link LineItem}.
	//
	ExcludedLocations []*Location `xml:"excludedLocations,omitempty" json:"excludedLocations,omitempty"`
}

type GeoTargetingError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *GeoTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type HistoricalBasisVolumeSettings struct {

	//
	// Whether the parent traffic forecast segment targeting's or the {@code targeting}'s historical
	// volume data should be used.
	// <span class="constraint Required">This attribute is required.</span>
	//
	UseParentTrafficForecastSegmentTargeting bool `xml:"useParentTrafficForecastSegmentTargeting,omitempty" json:"useParentTrafficForecastSegmentTargeting,omitempty"`

	//
	// The targeting criteria to use as the source of the historical volume data. This field is
	// required if {@code useParentTrafficForecastSegmentTargeting} is false and ignored otherwise.
	//
	Targeting *Targeting `xml:"targeting,omitempty" json:"targeting,omitempty"`

	//
	// The date range to use for the historical ad opportunity volume.
	// <span class="constraint Required">This attribute is required.</span>
	//
	HistoricalDateRange *DateRange `xml:"historicalDateRange,omitempty" json:"historicalDateRange,omitempty"`

	//
	// The multiplier to apply to the historical traffic volume, expressed in thousandths of a
	// percent. For example, to set the forecasted traffic as 130% of the historical traffic, this
	// value would be 130,000.
	// <span class="constraint Required">This attribute is required.</span>
	//
	MultiplierMilliPercent int64 `xml:"multiplierMilliPercent,omitempty" json:"multiplierMilliPercent,omitempty"`
}

type InternalApiError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *InternalApiError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InvalidUrlError struct {
	*ApiError

	Reason *InvalidUrlError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InventorySizeTargeting struct {

	//
	// Whether the inventory sizes should be targeted or excluded.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// A list of {@link TargetedSizeDto}s.
	//
	TargetedSizes []*TargetedSize `xml:"targetedSizes,omitempty" json:"targetedSizes,omitempty"`
}

type InventoryTargeting struct {

	//
	// A list of targeted {@link AdUnitTargeting}.
	//
	TargetedAdUnits []*AdUnitTargeting `xml:"targetedAdUnits,omitempty" json:"targetedAdUnits,omitempty"`

	//
	// A list of excluded {@link AdUnitTargeting}.
	//
	ExcludedAdUnits []*AdUnitTargeting `xml:"excludedAdUnits,omitempty" json:"excludedAdUnits,omitempty"`

	//
	// A list of targeted {@link Placement} ids.
	//
	TargetedPlacementIds []int64 `xml:"targetedPlacementIds,omitempty" json:"targetedPlacementIds,omitempty"`
}

type InventoryTargetingError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *InventoryTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InventoryUnitError struct {
	*ApiError

	Reason *InventoryUnitError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InventoryUnitSizesError struct {
	*ApiError

	Reason *InventoryUnitSizesError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type InventoryUrl struct {
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`
}

type InventoryUrlTargeting struct {
	TargetedUrls []*InventoryUrl `xml:"targetedUrls,omitempty" json:"targetedUrls,omitempty"`

	ExcludedUrls []*InventoryUrl `xml:"excludedUrls,omitempty" json:"excludedUrls,omitempty"`
}

type Location struct {

	//
	// Uniquely identifies each {@code Location}.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// The location type for this geographical entity (ex. "COUNTRY", "CITY", "STATE", "COUNTY", etc.)
	//
	Type_ string `xml:"type,omitempty" json:"type,omitempty"`

	//
	// The nearest location parent's ID for this geographical entity.
	//
	CanonicalParentId int32 `xml:"canonicalParentId,omitempty" json:"canonicalParentId,omitempty"`

	//
	// The localized name of the geographical entity.
	//
	DisplayName string `xml:"displayName,omitempty" json:"displayName,omitempty"`
}

type MobileApplicationTargeting struct {

	//
	// The {@link MobileApplication#applicationId IDs} that are being targeted or excluded by the
	// {@link LineItem}.
	//
	MobileApplicationIds []int64 `xml:"mobileApplicationIds,omitempty" json:"mobileApplicationIds,omitempty"`

	//
	// Indicates whether mobile apps should be targeted or excluded. This attribute is optional and
	// defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`
}

type MobileCarrier struct {
	*Technology
}

type MobileCarrierTargeting struct {

	//
	// Indicates whether mobile carriers should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Mobile carriers that are being targeted or excluded by the {@link LineItem}.
	//
	MobileCarriers []*Technology `xml:"mobileCarriers,omitempty" json:"mobileCarriers,omitempty"`
}

type MobileDevice struct {
	*Technology

	//
	// Manufacturer Id.
	//
	ManufacturerCriterionId int64 `xml:"manufacturerCriterionId,omitempty" json:"manufacturerCriterionId,omitempty"`
}

type MobileDeviceSubmodel struct {
	*Technology

	//
	// The mobile device id.
	//
	MobileDeviceCriterionId int64 `xml:"mobileDeviceCriterionId,omitempty" json:"mobileDeviceCriterionId,omitempty"`

	//
	// The device manufacturer id.
	//
	DeviceManufacturerCriterionId int64 `xml:"deviceManufacturerCriterionId,omitempty" json:"deviceManufacturerCriterionId,omitempty"`
}

type MobileDeviceSubmodelTargeting struct {

	//
	// Mobile device submodels that are being targeted by the {@link LineItem}.
	//
	TargetedMobileDeviceSubmodels []*Technology `xml:"targetedMobileDeviceSubmodels,omitempty" json:"targetedMobileDeviceSubmodels,omitempty"`

	//
	// Mobile device submodels that are being excluded by the {@link LineItem}.
	//
	ExcludedMobileDeviceSubmodels []*Technology `xml:"excludedMobileDeviceSubmodels,omitempty" json:"excludedMobileDeviceSubmodels,omitempty"`
}

type MobileDeviceTargeting struct {

	//
	// Mobile devices that are being targeted by the {@link LineItem}.
	//
	TargetedMobileDevices []*Technology `xml:"targetedMobileDevices,omitempty" json:"targetedMobileDevices,omitempty"`

	//
	// Mobile devices that are being excluded by the {@link LineItem}.
	//
	ExcludedMobileDevices []*Technology `xml:"excludedMobileDevices,omitempty" json:"excludedMobileDevices,omitempty"`
}

type NotNullError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *NotNullError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type NullError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *NullError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type NumberValue struct {
	*_Value

	//
	// The numeric value represented as a string.
	//
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

type OperatingSystem struct {
	*Technology
}

type OperatingSystemTargeting struct {

	//
	// Indicates whether operating systems should be targeted or excluded. This attribute is optional
	// and defaults to {@code true}.
	//
	IsTargeted bool `xml:"isTargeted,omitempty" json:"isTargeted,omitempty"`

	//
	// Operating systems that are being targeted or excluded by the {@link LineItem}.
	//
	OperatingSystems []*Technology `xml:"operatingSystems,omitempty" json:"operatingSystems,omitempty"`
}

type OperatingSystemVersion struct {
	*Technology

	//
	// The operating system major version.
	//
	MajorVersion int32 `xml:"majorVersion,omitempty" json:"majorVersion,omitempty"`

	//
	// The operating system minor version.
	//
	MinorVersion int32 `xml:"minorVersion,omitempty" json:"minorVersion,omitempty"`

	//
	// The operating system micro version.
	//
	MicroVersion int32 `xml:"microVersion,omitempty" json:"microVersion,omitempty"`
}

type OperatingSystemVersionTargeting struct {

	//
	// Operating system versions that are being targeted by the {@link LineItem}.
	//
	TargetedOperatingSystemVersions []*Technology `xml:"targetedOperatingSystemVersions,omitempty" json:"targetedOperatingSystemVersions,omitempty"`

	//
	// Operating system versions that are being excluded by the {@link LineItem}.
	//
	ExcludedOperatingSystemVersions []*Technology `xml:"excludedOperatingSystemVersions,omitempty" json:"excludedOperatingSystemVersions,omitempty"`
}

type ParseError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *ParseError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PermissionError struct {
	*ApiError

	Reason *PermissionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PublisherQueryLanguageContextError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PublisherQueryLanguageContextError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type PublisherQueryLanguageSyntaxError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *PublisherQueryLanguageSyntaxError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type QuotaError struct {
	*ApiError

	Reason *QuotaError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequestPlatformTargeting struct {
	TargetedRequestPlatforms []*RequestPlatform `xml:"targetedRequestPlatforms,omitempty" json:"targetedRequestPlatforms,omitempty"`
}

type RequiredCollectionError struct {
	*ApiError

	Reason *RequiredCollectionError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type RequiredError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *RequiredError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type ServerError struct {
	*ApiError

	Reason *ServerError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type SetValue struct {
	*_Value

	//
	// The values. They must all be the same type of {@code Value} and not contain duplicates.
	//
	Values []*_Value `xml:"values,omitempty" json:"values,omitempty"`
}

type Size struct {

	//
	// The width of the {@link AdUnit}, {@link LineItem} or {@link Creative}.
	//
	Width int32 `xml:"width,omitempty" json:"width,omitempty"`

	//
	// The height of the {@link AdUnit}, {@link LineItem} or {@link Creative}.
	//
	Height int32 `xml:"height,omitempty" json:"height,omitempty"`

	//
	// Whether this size represents an aspect ratio.
	//
	IsAspectRatio bool `xml:"isAspectRatio,omitempty" json:"isAspectRatio,omitempty"`
}

type SoapRequestHeader struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 RequestHeader"`

	//
	// The network code to use in the context of a request.
	//
	NetworkCode string `xml:"networkCode,omitempty" json:"networkCode,omitempty"`

	//
	// The name of client library application.
	//
	ApplicationName string `xml:"applicationName,omitempty" json:"applicationName,omitempty"`
}

type SoapResponseHeader struct {
	XMLName xml.Name `xml:"https://www.google.com/apis/ads/publisher/v202311 ResponseHeader"`

	RequestId string `xml:"requestId,omitempty" json:"requestId,omitempty"`

	ResponseTime int64 `xml:"responseTime,omitempty" json:"responseTime,omitempty"`
}

type Statement struct {

	//
	// Holds the query in PQL syntax. The syntax is:<br>
	// <code>[WHERE <condition> {[AND | OR] <condition> ...}]</code><br>
	// <code>[ORDER BY <property> [ASC | DESC]]</code><br>
	// <code>[LIMIT {[<offset>,] <count>} | {<count> OFFSET <offset>}]</code><br>
	// <p>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <value></code><br>
	// <code><condition></code><br>
	// &nbsp;&nbsp;&nbsp;&nbsp;
	// <code>:= <property> {< | <= | > | >= | = | != } <bind variable></code><br>
	// <code><condition> := <property> IN <list></code><br>
	// <code><condition> := <property> IS NULL</code><br>
	// <code><condition> := <property> LIKE <wildcard%match></code><br>
	// <code><bind variable> := :<name></code><br>
	// </p>
	//
	Query string `xml:"query,omitempty" json:"query,omitempty"`

	//
	// Holds keys and values for bind variables and their values. The key is the
	// name of the bind variable. The value is the literal value of the variable.
	// <p>
	// In the example {@code "WHERE status = :bindStatus ORDER BY id LIMIT 30"},
	// the bind variable, represented by {@code :bindStatus} is named {@code
	// bindStatus}, which would also be the parameter map key. The bind variable's
	// value would be represented by a parameter map value of type
	// {@link TextValue}. The final result, for example, would be an entry of
	// {@code "bindStatus" => StringParam("ACTIVE")}.
	// </p>
	//
	Values []*String_ValueMapEntry `xml:"values,omitempty" json:"values,omitempty"`
}

type StatementError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *StatementError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type StringFormatError struct {
	*ApiError

	Reason *StringFormatError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type StringLengthError struct {
	*ApiError

	Reason *StringLengthError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type String_ValueMapEntry struct {
	Key string `xml:"key,omitempty" json:"key,omitempty"`

	Value *_Value `xml:"value,omitempty" json:"value,omitempty"`
}

type TargetedSize struct {
	Size *Size `xml:"size,omitempty" json:"size,omitempty"`
}

type Targeting struct {

	//
	// Specifies what geographical locations are targeted by the {@link LineItem}. This attribute is
	// optional.
	//
	GeoTargeting *GeoTargeting `xml:"geoTargeting,omitempty" json:"geoTargeting,omitempty"`

	//
	// Specifies what inventory is targeted by the {@link LineItem}. This attribute is required. The
	// line item must target at least one ad unit or placement.
	//
	InventoryTargeting *InventoryTargeting `xml:"inventoryTargeting,omitempty" json:"inventoryTargeting,omitempty"`

	//
	// Specifies the days of the week and times that are targeted by the {@link LineItem}. This
	// attribute is optional.
	//
	DayPartTargeting *DayPartTargeting `xml:"dayPartTargeting,omitempty" json:"dayPartTargeting,omitempty"`

	//
	// Specifies the dates and time ranges that are targeted by the {@link LineItem}. This attribute
	// is optional.
	//
	DateTimeRangeTargeting *DateTimeRangeTargeting `xml:"dateTimeRangeTargeting,omitempty" json:"dateTimeRangeTargeting,omitempty"`

	//
	// Specifies the browsing technologies that are targeted by the {@link LineItem}. This attribute
	// is optional.
	//
	TechnologyTargeting *TechnologyTargeting `xml:"technologyTargeting,omitempty" json:"technologyTargeting,omitempty"`

	//
	// Specifies the collection of custom criteria that is targeted by the {@link LineItem}.
	//
	// <p>Once the {@link LineItem} is updated or modified with custom targeting, the server may
	// return a normalized, but equivalent representation of the custom targeting expression.
	//
	// <p>{@code customTargeting} will have up to three levels of expressions including itself.
	//
	// <p>The top level {@code CustomCriteriaSet} i.e. the {@code customTargeting} object can only
	// contain a {@link CustomCriteriaSet.LogicalOperator#OR} of all its children.
	//
	// <p>The second level of {@code CustomCriteriaSet} objects can only contain {@link
	// CustomCriteriaSet.LogicalOperator#AND} of all their children. If a {@link CustomCriteria} is
	// placed on this level, the server will wrap it in a {@link CustomCriteriaSet}.
	//
	// <p>The third level can only comprise of {@link CustomCriteria} objects.
	//
	// <p>The resulting custom targeting tree would be of the form: <br>
	// <img
	// src="https://chart.apis.google.com/chart?cht=gv&chl=digraph{customTargeting_LogicalOperator_OR-%3ECustomCriteriaSet_LogicalOperator_AND_1-%3ECustomCriteria_1;CustomCriteriaSet_LogicalOperator_AND_1-%3Eellipsis1;customTargeting_LogicalOperator_OR-%3Eellipsis2;ellipsis1[label=%22...%22,shape=none,fontsize=32];ellipsis2[label=%22...%22,shape=none,fontsize=32]}&chs=450x200"/>
	//
	CustomTargeting *CustomCriteriaSet `xml:"customTargeting,omitempty" json:"customTargeting,omitempty"`

	//
	// Specifies the domains or subdomains that are targeted or excluded by the {@link LineItem}.
	// Users visiting from an IP address associated with those domains will be targeted or excluded.
	// This attribute is optional.
	//
	UserDomainTargeting *UserDomainTargeting `xml:"userDomainTargeting,omitempty" json:"userDomainTargeting,omitempty"`

	//
	// Specifies the video categories and individual videos targeted by the {@link LineItem}.
	//
	ContentTargeting *ContentTargeting `xml:"contentTargeting,omitempty" json:"contentTargeting,omitempty"`

	//
	// Specifies targeting against video position types.
	//
	VideoPositionTargeting *VideoPositionTargeting `xml:"videoPositionTargeting,omitempty" json:"videoPositionTargeting,omitempty"`

	//
	// Specifies targeting against mobile applications.
	//
	MobileApplicationTargeting *MobileApplicationTargeting `xml:"mobileApplicationTargeting,omitempty" json:"mobileApplicationTargeting,omitempty"`

	//
	// Specifies whether buyer user lists are targeted on a programmatic {@link LineItem} or {@link
	// ProposalLineItem}. This attribute is readonly and is populated by Google.
	//
	BuyerUserListTargeting *BuyerUserListTargeting `xml:"buyerUserListTargeting,omitempty" json:"buyerUserListTargeting,omitempty"`

	//
	// Specifies the URLs that are targeted by the entity. This is currently only supported by {@link
	// YieldGroup}.
	//
	InventoryUrlTargeting *InventoryUrlTargeting `xml:"inventoryUrlTargeting,omitempty" json:"inventoryUrlTargeting,omitempty"`

	//
	// Specifies the request platforms that are targeted by the {@link LineItem}. This attribute is
	// required for video line items and for {@link ProposalLineItem}.
	//
	// <p>This value is modifiable for video line items, but read-only for non-video line items.
	//
	// <p>This value is read-only for video line items generated from proposal line items.
	//
	RequestPlatformTargeting *RequestPlatformTargeting `xml:"requestPlatformTargeting,omitempty" json:"requestPlatformTargeting,omitempty"`

	//
	// Specifies the sizes that are targeted by the entity. This is currently only supported on {@link
	// YieldGroup} and {@link TrafficDataRequest}.
	//
	InventorySizeTargeting *InventorySizeTargeting `xml:"inventorySizeTargeting,omitempty" json:"inventorySizeTargeting,omitempty"`
}

type Technology struct {

	//
	// The unique ID of the {@code Technology}. This value is required for all forms of {@code
	// TechnologyTargeting}.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// The name of the technology being targeting. This value is read-only and is assigned by Google.
	//
	Name string `xml:"name,omitempty" json:"name,omitempty"`
}

type TechnologyTargetingError struct {
	*ApiError

	Reason *TechnologyTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type TextValue struct {
	*_Value

	//
	// The string value.
	//
	Value string `xml:"value,omitempty" json:"value,omitempty"`
}

type TimeOfDay struct {

	//
	// Hour in 24 hour time (0..24). This field must be between 0 and 24,
	// inclusive. This field is required.
	//
	Hour int32 `xml:"hour,omitempty" json:"hour,omitempty"`

	//
	// Minutes in an hour. Currently, only 0, 15, 30, and 45 are supported. This
	// field is required.
	//
	Minute *MinuteOfHour `xml:"minute,omitempty" json:"minute,omitempty"`
}

type TotalVolumeSettings struct {

	//
	// The total ad opportunity count over the entire forecast adjustment date range.
	// <span class="constraint Required">This attribute is required.</span>
	//
	AdOpportunityCount int64 `xml:"adOpportunityCount,omitempty" json:"adOpportunityCount,omitempty"`
}

type TrafficForecastSegment struct {

	//
	// The unique ID of the TrafficForecastSegment. This field is read-only and set by Google.
	// This attribute is read-only.
	//
	Id int64 `xml:"id,omitempty" json:"id,omitempty"`

	//
	// Name of the TrafficForecastSegment. This field must be unique among all segments for this
	// network.
	// <span class="constraint Required">This attribute is required.</span>
	//
	Name string `xml:"name,omitempty" json:"name,omitempty"`

	//
	// The targeting that defines a segment of traffic. Targeting cannot be changed after segment
	// creation.
	// <span class="constraint Required">This attribute is required.</span>
	//
	Targeting *Targeting `xml:"targeting,omitempty" json:"targeting,omitempty"`

	//
	// The number of active forecast adjustments associated with the TrafficForecastSegment.
	// This attribute is read-only.
	//
	ActiveForecastAdjustmentCount int32 `xml:"activeForecastAdjustmentCount,omitempty" json:"activeForecastAdjustmentCount,omitempty"`

	//
	// The date and time that the TrafficForecastSegment was created.
	// This attribute is read-only.
	//
	CreationDateTime soap.XSDDateTime `xml:"creationDateTime,omitempty" json:"creationDateTime,omitempty"`
}

type TrafficForecastSegmentError struct {
	*ApiError

	//
	// The error reason represented by an enum.
	//
	Reason *TrafficForecastSegmentError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type TrafficForecastSegmentPage struct {

	//
	// The size of the total result set to which this page belongs.
	//
	TotalResultSetSize int32 `xml:"totalResultSetSize,omitempty" json:"totalResultSetSize,omitempty"`

	//
	// The absolute index in the total result set on which this page begins.
	//
	StartIndex int32 `xml:"startIndex,omitempty" json:"startIndex,omitempty"`

	//
	// The collection of traffic forecast segments contained within this page.
	//
	Results []*TrafficForecastSegment `xml:"results,omitempty" json:"results,omitempty"`
}

type TypeError struct {
	*ApiError
}

type UniqueError struct {
	*ApiError
}

type UpdateResult struct {

	//
	// The number of objects that were changed as a result of performing the
	// action.
	//
	NumChanges int32 `xml:"numChanges,omitempty" json:"numChanges,omitempty"`
}

type UserDomainTargeting struct {

	//
	// The domains or subdomains that are being targeted or excluded by the {@link LineItem}. This
	// attribute is required and the maximum length of each domain is 67 characters.
	//
	Domains []string `xml:"domains,omitempty" json:"domains,omitempty"`

	//
	// Indicates whether domains should be targeted or excluded. This attribute is optional and
	// defaults to {@code true}.
	//
	Targeted bool `xml:"targeted,omitempty" json:"targeted,omitempty"`
}

type UserDomainTargetingError struct {
	*ApiError

	Reason *UserDomainTargetingError_Reason `xml:"reason,omitempty" json:"reason,omitempty"`
}

type _Value struct {
}

type VideoPosition struct {

	//
	// The type of video position (pre-roll, mid-roll, or post-roll).
	//
	PositionType *VideoPosition_Type `xml:"positionType,omitempty" json:"positionType,omitempty"`

	//
	// The index of the mid-roll to target.  Only valid if the {@link positionType} is
	// {@link VideoPositionType#MIDROLL}, otherwise this field will be ignored.
	//
	MidrollIndex int32 `xml:"midrollIndex,omitempty" json:"midrollIndex,omitempty"`
}

type VideoPositionTargeting struct {

	//
	// The {@link VideoTargetingPosition} objects being targeted by the video {@link LineItem}.
	//
	TargetedPositions []*VideoPositionTarget `xml:"targetedPositions,omitempty" json:"targetedPositions,omitempty"`
}

type VideoPositionWithinPod struct {

	//
	// The specific index of the pod. The index is defined as:
	// <ul><li>1 = first</li>
	// <li>2 = second</li>
	// <li>3 = third</li>
	// <li>....</li>
	// <li>100 = last</li></ul>
	// 100 will always be the last position. For example, for a pod with 5 positions, 100 would
	// target position 5. Multiple targets against the index 100 can exist.<br>
	// Positions over 100 are not supported.
	//
	Index int32 `xml:"index,omitempty" json:"index,omitempty"`
}

type VideoPositionTarget struct {

	//
	// The video position to target.  This attribute is required.
	//
	VideoPosition *VideoPosition `xml:"videoPosition,omitempty" json:"videoPosition,omitempty"`

	//
	// The video bumper type to target. To target a video position or a pod position, this value must
	// be null. To target a bumper position this value must be populated and the line item must have a
	// bumper type. To target a custom ad spot, this value must be null.
	//
	VideoBumperType *VideoBumperType `xml:"videoBumperType,omitempty" json:"videoBumperType,omitempty"`

	//
	// The video position within a pod to target. To target a video position or a bumper position,
	// this value must be null. To target a position within a pod this value must be populated. To
	// target a custom ad spot, this value must be null.
	//
	VideoPositionWithinPod *VideoPositionWithinPod `xml:"videoPositionWithinPod,omitempty" json:"videoPositionWithinPod,omitempty"`

	//
	// A custom spot {@link AdSpot} to target. To target a video position, a bumper type or a video
	// position within a pod this value must be null.
	//
	AdSpotId int64 `xml:"adSpotId,omitempty" json:"adSpotId,omitempty"`
}

type AdjustmentServiceInterface interface {

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Takes a prospective forecast adjustment and calculates the daily ad opportunity counts
	   corresponding to its provided volume settings.
	*/
	CalculateDailyAdOpportunityCounts(request *CalculateDailyAdOpportunityCounts) (*CalculateDailyAdOpportunityCountsResponse, error)

	CalculateDailyAdOpportunityCountsContext(ctx context.Context, request *CalculateDailyAdOpportunityCounts) (*CalculateDailyAdOpportunityCountsResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Creates new {@link ForecastAdjustment} objects.
	*/
	CreateForecastAdjustments(request *CreateForecastAdjustments) (*CreateForecastAdjustmentsResponse, error)

	CreateForecastAdjustmentsContext(ctx context.Context, request *CreateForecastAdjustments) (*CreateForecastAdjustmentsResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Creates new {@link TrafficForecastSegment} objects.
	*/
	CreateTrafficForecastSegments(request *CreateTrafficForecastSegments) (*CreateTrafficForecastSegmentsResponse, error)

	CreateTrafficForecastSegmentsContext(ctx context.Context, request *CreateTrafficForecastSegments) (*CreateTrafficForecastSegmentsResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Gets a {@link ForecastAdjustmentPage} of {@link ForecastAdjustment} objects that satisfy the
	   given {@link Statement#query}.

	   <p>The following fields are supported for filtering:

	   <table>
	   <tr>
	   <th scope="col">PQL Property</th> <th scope="col">Object Property</th>
	   </tr>
	   <tr>
	   <td>{@code id}</td>
	   <td>{@link ForecastAdjustment#id}</td>
	   </tr>
	   <tr>
	   <td>{@code trafficForecastSegmentId}</td>
	   <td>{@link ForecastAdjustment#trafficForecastSegmentId}</td>
	   </tr>
	   <tr>
	   <td>{@code name}</td>
	   <td>{@link ForecastAdjustment#name}</td>
	   </tr>
	   <tr>
	   <td>{@code startDate}</td>
	   <td>{@link ForecastAdjustment#startDate}</td>
	   </tr>
	   <tr>
	   <td>{@code endDate}</td>
	   <td>{@link ForecastAdjustment#endDate}</td>
	   </tr>
	   <tr>
	   <td>{@code status}</td>
	   <td>{@link ForecastAdjustment#status}</td>
	   </tr>
	   </table>
	*/
	GetForecastAdjustmentsByStatement(request *GetForecastAdjustmentsByStatement) (*GetForecastAdjustmentsByStatementResponse, error)

	GetForecastAdjustmentsByStatementContext(ctx context.Context, request *GetForecastAdjustmentsByStatement) (*GetForecastAdjustmentsByStatementResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Gets a {@link TrafficForecastSegmentPage} of {@link TrafficForecastSegment} objects that
	   satisfy the given {@link Statement#query}.

	   <p>The following fields are supported for filtering:

	   <table>
	   <tr>
	   <th scope="col">PQL Property</th> <th scope="col">Object Property</th>
	   </tr>
	   <tr>
	   <td>{@code id}</td>
	   <td>{@link TrafficForecastSegment#id}</td>
	   </tr>
	   <tr>
	   <td>{@code name}</td>
	   <td>{@link TrafficForecastSegment#name}</td>
	   </tr>
	   <tr>
	   <td>{@code creationTime}</td>
	   <td>{@link TrafficForecastSegment#creationTime}</td>
	   </tr>
	   </table>
	*/
	GetTrafficForecastSegmentsByStatement(request *GetTrafficForecastSegmentsByStatement) (*GetTrafficForecastSegmentsByStatementResponse, error)

	GetTrafficForecastSegmentsByStatementContext(ctx context.Context, request *GetTrafficForecastSegmentsByStatement) (*GetTrafficForecastSegmentsByStatementResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Performs actions on {@link ForecastAdjustment} objects that match the given {@link
	   Statement#query}.
	*/
	PerformForecastAdjustmentAction(request *PerformForecastAdjustmentAction) (*PerformForecastAdjustmentActionResponse, error)

	PerformForecastAdjustmentActionContext(ctx context.Context, request *PerformForecastAdjustmentAction) (*PerformForecastAdjustmentActionResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Updates the specified {@link ForecastAdjustment} objects.
	*/
	UpdateForecastAdjustments(request *UpdateForecastAdjustments) (*UpdateForecastAdjustmentsResponse, error)

	UpdateForecastAdjustmentsContext(ctx context.Context, request *UpdateForecastAdjustments) (*UpdateForecastAdjustmentsResponse, error)

	// Error can be either of the following types:
	//
	//   - ApiException
	/*
	   Updates the specified {@link TrafficForecastSegment} objects.
	*/
	UpdateTrafficForecastSegments(request *UpdateTrafficForecastSegments) (*UpdateTrafficForecastSegmentsResponse, error)

	UpdateTrafficForecastSegmentsContext(ctx context.Context, request *UpdateTrafficForecastSegments) (*UpdateTrafficForecastSegmentsResponse, error)
}

type adjustmentServiceInterface struct {
	client *soap.Client
}

func NewAdjustmentServiceInterface(client *soap.Client) AdjustmentServiceInterface {
	return &adjustmentServiceInterface{
		client: client,
	}
}

func (service *adjustmentServiceInterface) CalculateDailyAdOpportunityCountsContext(ctx context.Context, request *CalculateDailyAdOpportunityCounts) (*CalculateDailyAdOpportunityCountsResponse, error) {
	response := new(CalculateDailyAdOpportunityCountsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *adjustmentServiceInterface) CalculateDailyAdOpportunityCounts(request *CalculateDailyAdOpportunityCounts) (*CalculateDailyAdOpportunityCountsResponse, error) {
	return service.CalculateDailyAdOpportunityCountsContext(
		context.Background(),
		request,
	)
}

func (service *adjustmentServiceInterface) CreateForecastAdjustmentsContext(ctx context.Context, request *CreateForecastAdjustments) (*CreateForecastAdjustmentsResponse, error) {
	response := new(CreateForecastAdjustmentsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *adjustmentServiceInterface) CreateForecastAdjustments(request *CreateForecastAdjustments) (*CreateForecastAdjustmentsResponse, error) {
	return service.CreateForecastAdjustmentsContext(
		context.Background(),
		request,
	)
}

func (service *adjustmentServiceInterface) CreateTrafficForecastSegmentsContext(ctx context.Context, request *CreateTrafficForecastSegments) (*CreateTrafficForecastSegmentsResponse, error) {
	response := new(CreateTrafficForecastSegmentsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *adjustmentServiceInterface) CreateTrafficForecastSegments(request *CreateTrafficForecastSegments) (*CreateTrafficForecastSegmentsResponse, error) {
	return service.CreateTrafficForecastSegmentsContext(
		context.Background(),
		request,
	)
}

func (service *adjustmentServiceInterface) GetForecastAdjustmentsByStatementContext(ctx context.Context, request *GetForecastAdjustmentsByStatement) (*GetForecastAdjustmentsByStatementResponse, error) {
	response := new(GetForecastAdjustmentsByStatementResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *adjustmentServiceInterface) GetForecastAdjustmentsByStatement(request *GetForecastAdjustmentsByStatement) (*GetForecastAdjustmentsByStatementResponse, error) {
	return service.GetForecastAdjustmentsByStatementContext(
		context.Background(),
		request,
	)
}

func (service *adjustmentServiceInterface) GetTrafficForecastSegmentsByStatementContext(ctx context.Context, request *GetTrafficForecastSegmentsByStatement) (*GetTrafficForecastSegmentsByStatementResponse, error) {
	response := new(GetTrafficForecastSegmentsByStatementResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *adjustmentServiceInterface) GetTrafficForecastSegmentsByStatement(request *GetTrafficForecastSegmentsByStatement) (*GetTrafficForecastSegmentsByStatementResponse, error) {
	return service.GetTrafficForecastSegmentsByStatementContext(
		context.Background(),
		request,
	)
}

func (service *adjustmentServiceInterface) PerformForecastAdjustmentActionContext(ctx context.Context, request *PerformForecastAdjustmentAction) (*PerformForecastAdjustmentActionResponse, error) {
	response := new(PerformForecastAdjustmentActionResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *adjustmentServiceInterface) PerformForecastAdjustmentAction(request *PerformForecastAdjustmentAction) (*PerformForecastAdjustmentActionResponse, error) {
	return service.PerformForecastAdjustmentActionContext(
		context.Background(),
		request,
	)
}

func (service *adjustmentServiceInterface) UpdateForecastAdjustmentsContext(ctx context.Context, request *UpdateForecastAdjustments) (*UpdateForecastAdjustmentsResponse, error) {
	response := new(UpdateForecastAdjustmentsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *adjustmentServiceInterface) UpdateForecastAdjustments(request *UpdateForecastAdjustments) (*UpdateForecastAdjustmentsResponse, error) {
	return service.UpdateForecastAdjustmentsContext(
		context.Background(),
		request,
	)
}

func (service *adjustmentServiceInterface) UpdateTrafficForecastSegmentsContext(ctx context.Context, request *UpdateTrafficForecastSegments) (*UpdateTrafficForecastSegmentsResponse, error) {
	response := new(UpdateTrafficForecastSegmentsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *adjustmentServiceInterface) UpdateTrafficForecastSegments(request *UpdateTrafficForecastSegments) (*UpdateTrafficForecastSegmentsResponse, error) {
	return service.UpdateTrafficForecastSegmentsContext(
		context.Background(),
		request,
	)
}
